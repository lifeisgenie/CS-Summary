# 소프트웨어공학

## 소프트웨어 공학 개요

- **소프트웨어:** 프로그램 + 개발 과정에서 생성된 모든 산출물
    - 일반 사용자 입장 → 소프트웨어는 컴퓨터를 작동하기 위한 프로그램들의 집합

### 소프트웨어 공학의 정의와 목적

- **정의:** 소프트웨어를 개발하기 위해 요구사항 분석부터 유지보수까지 또는 개발과정부터 관리까지 전 과정을 체계적으로 관리하는 방법론
- **목적:** 사용자의 요구사항을 충족시키는 품질 좋은 소프트웨어 개발
    - 개발 대상의 명확화
    - 개발 과정의 체계화
    - 개발 수명주기 지원

### 소프트웨어의 특징과 복잡성

- **상품성:** 개발이 완료된 제품(소프트웨어)은 상품화됨
- **견고성:** 소프트웨어의 부분적 수정으로 소프트웨어 전체에 영향을 미칠 수 있음 / 따라서, 수정이나 변경이 용이하지 않음
- **복잡성:** 개발 과정은 복잡하고 까다롭기 때문에 산출물에 대한 표준화가 필요함
- **순응성:** 사용자의 요구사항이나 환경 변화에 맞춰 빠르게 변경할 수 있음
- **비가시성:** 개발이 완료될 때까지는 소프트웨어 결과물이 어떠 한지 알 수 없으며, 완성되기 전까지는 코드에 의존함
- **비마모성:** 소프트웨어는 마모되거나 없어지지 않음
- **비제조성:** 하드웨어는 제작하지만, 소프트웨어는 논리적인 사고를 가지고 개발
- **비과학성:** 소프트웨어 개발을 위해서는 시간, 인력, 노력이 필요하며 절차 중심임
- **복제성:** 소프트웨어는 무한하게 복제가 가능함 (단, 저작권 문제는 고려 필요)

### 소프트웨어 개발의 중요성과 도전 과제

- **중요성:**
    - 현대 사회에서 필수적 기술로 품질 높은 소프트웨어가 요구됨
    - 대규모 시스템 및 다양한 플랫폼 지원
- **도전 과제:**
    - **요구사항 변화:** 기술 발전과 사용자 요구 변화에 대응 필요
    - **품질 유지:** 결함 없는 소프트웨어 제공
    - **일정 관리:** 프로젝트 목표에 맞춘 효율적 일정 관리

### 소프트웨어 공학의 발전 과정

- **소프트웨어 위기 (software crisis)**
    - 1968년 NATO 소프트웨어 공학 학회에서 처음 등장
    - 컴퓨터에 의한 계산 용량과 문제의 복잡도 급증으로 새로운 소프트웨어 개발 방법의 필요성을 인식
- **해결 방향:**
    - 체계적 관리 기법 도입
    - 소프트웨어 공학적 도구와 프로세스 정립
    - 표준화된 개발 방법론 채택

## 소프트웨어 개발 생명 주기(Software Development Life Cycle, SDLC)

### SDLC 모델의 개념

소프트웨어를 만들기 위해 계획 단계부터 유지보수 단계에 이르기까지 일어나는 일련의 과정

- **목적:** 품질 높은 소프트웨어 개발 및 유지보수로 비용 절감과 신뢰성 확보

### 전통적 SDLC 모델

- **폭포수 모델 (Waterfall Model)**
    - 소프트웨어 공학의 기본, 초기에 개발된 전통적인 모델
    - **특징**
        - 계획 → 분석 → 설계 → 구현 → 테스트 → 유지보수로 진행
        - 각 단계의 산출물을 다음 단계에 입력
        - 산출물을 기반으로 이상 유무를 판단 후 다음 단계로 진행 (top-down 방식)
    - **장점**
        - 정형화된 절차로 프로젝트 관리 용이
        - 문서 중심이라 추적성 높음
    - **단점**
        - 요구사항 변경에 비효율적
        - 사용자가 초기와 최종 단계 외에 참여 제한
- **V (Verification) 모델**
    - 테스트 단계를 포함하여 검증 중심으로 확장된 폭포수 모델
    - **특징**
        - 각 개발 단계에 대응되는 테스트 단계 포함
        - 계획 및 설계 오류 조기 검출 가능
    - **단계별 테스트 유형**
        - **단위테스트:** 구현 단계에서 프로그램 개발자에 의해 수행
        - **통합 테스트:** 모듈을 결합, 하나의 시스템으로 구성하여 테스트
        - **시스템 테스트:** 통합 모듈에 대한 시스템적(비기능적) 테스트
        - **인수 테스트:** 사용자의 만족 여부를 테스트하는 품질 테스트
        - **설치 테스트:** 시스템을 설치하면서 수행, HW-SW 연결성 등 테스트
    - **장점**
        - 오류 검출 및 신뢰성 강화
        - 정밀한 검증 절차
    - **단점**
        - 반복 작업 부족
        - 초기 오류가 진행에 큰 영향

### 현대적 SDLC 모델

- **애자일(Agile)**
    - 문서화 최소화 및 반복적 개발 방식으로 사용자 요구사항을 신속히 반영
    - **특징:**
        - 짧은 반복 주기(스프린트) 활용
        - 고객 피드백을 중심으로 지속적 개선
    - **장점:**
        - 변화에 유연
        - 개발 기간 단축
    - **단점:**
        - 초보 팀에게 어려움
        - 문서화 부족 시 유지보수 어려움
- **스크럼(Scrum)**
    - 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리에 중점을 둔 방법론 (경험적 관리 기법 중 하나)
    - **동작 방식:**
        - 요구사항을 우선순위로 분류 후 반복적 개발
        - **스프린트 회의:** 목표와 일정 설정
        - **일일 스크럼:** 진행 상황 공유
        - 완료 후 회고를 통한 개선
    - **장점:**
        - 협업 효율 극대화
        - 빠른 피드백과 적응 가능
    - **단점:**
        - 빈번한 회의로 생산성 저하 가능
        - 목표 설정 오류 시 낭비 발생
- **칸반(Kanban)**
    - 작업 상태를 시각화하고, 작업 흐름을 최적화하며, 작업의 진행 상태를 관리하는 방법론
    - 특징
        - **작업 시각화:** 작업을 보드에 표시하여 상태를 쉽게 확인.
        - **WIP 제한:** 동시에 진행할 수 있는 작업 수를 제한해 과부하 방지.
        - **지속적 개선:** 주기적으로 작업 흐름을 점검하고 개선.
    - **장점**
        - 직관적인 작업 관리
        - 작업 효율성과 품질 향상
    - **단점**
        - WIP 제한이 불편할 수 있음
        - 급격한 변화에 적응하기 어려울 수 있음
    - **활용**
        - 소프트웨어 개발, IT 운영 등에서 사용됨.

### DevOps와 CI/CD

- **DevOps**
    - **정의:** 개발(Development)과 운영(Operations)의 협업을 강화하여 지속적 통합 및 배포를 실현하는 문화 및 방법론.
    - **특징:**
        - 자동화 및 모니터링 강조
        - 소프트웨어 품질 및 배포 속도 향상
    - **장점:**
        - 오류 감소, 빠른 배포
    - **단점:**
        - 초기 구축 비용 및 복잡성
- **CI/CD (Continuous Integration/Continuous Deployment)**
    - **정의:** 지속적 통합 및 배포로 소프트웨어 개발, 테스트, 배포 자동화.
    - **동작 방식:**
        - **CI:** 코드 변경 시 자동 테스트 및 통합
        - **CD:** 검증된 코드를 프로덕션에 배포
    - **장점:**
        - 빠른 피드백
        - 효율적 버그 수정
    - **단점:**
        - 설정 및 유지보수 비용 증가
    
    ```yaml
    name: CI/CD Pipeline
    
    on:
      push:
        branches:
          - main
    
    jobs:
      build:
        runs-on: ubuntu-latest
    
        steps:
        - name: Checkout code
          uses: actions/checkout@v2
    
        - name: Set up Node.js
          uses: actions/setup-node@v3
          with:
            node-version: '16'
    
        - name: Install dependencies
          run: npm install
    
        - name: Run tests
          run: npm test
    
        - name: Deploy to Production
          if: success()
          run: npm run deploy
    ```

## 요구사항 분석(requirement analysis)

사용자가 요구하는 사항을 정확히 파악하여 소프트웨어가 해결해야 할 문제를 명확히 정의하는 과정.

- **개념**
    - 요구사항 분석은 소프트웨어 개발 초기 단계에서 사용자가 필요로 하는 기능 및 품질 요건을 명확히 정의하는 작업.
    - 개발 목표와 방향성을 설정하고, 개발 과정에서 발생할 수 있는 모호성을 제거.
- **중요성**
    - 요구사항의 오류나 불명확함은 프로젝트의 실패로 이어질 수 있음.
    - 전체 소프트웨어 개발 생명주기(SDLC)에서 비용과 시간을 절약하기 위한 핵심 단계.
    - 요구사항 문제가 늦게 발견될수록 수정 비용이 증가함.
- **절차**
    - **자료 수집**: 실무자 인터뷰, 설문조사, 기존 문서 검토, 워크숍 등 다양한 방법으로 자료를 수집.
    - **요구사항 도출:** 수집한 자료를 분석하고, 핵심 요구사항을 분류하여 정의.
    - **문서화**: 요구사항 명세서 작성. 기능 요구사항과 비기능 요구사항을 명확히 구분.
    - **검증**: 사용자 및 이해관계자와 협의하여 요구사항의 정확성을 확인.

### 요구 사항의 정의와 중요성

- **정의:** 사용자와 개발자가 합의한 범위 내에서 사용자가 필요로 하는 기능
- **중요성**
    - 전체 소프트웨어 개발 수명주기에서 가장 중요한 요소, 소프트웨어 개발의 기준
    - 초기 시스템 요청보다 상세한 요구사항 목록으로 구체화
    - 요구사항의 문제점을 늦은 단계에서 발견하면 이를 수정하기 위한 많은 비용 발생

### 기능 요구 사항과 비기능 요구 사항

- **기능 요구사항 (Function Requirement)**
    - 사용자의 업무 처리와 직접 관련되어 소프트웨어 시스템이 수행해야 하는 요구 내용
    - **특징**
        - 사용자는 시스템을 통해 기능을 제공받기 바라며, 시스템은 사용자에게 필요한 기능을 제공
        - 사용자가 원하는 기능은 완전하고 일관성 있게 표현해야 하며, 시스템에도 전부 반영해야 함
- **비기능 요구사항 (Non-function Requirement)**
    - 수행 가능한 환경과 같은 제약사항, 소프트웨어의 품질 기준 등 시스템의 기능 외 요구 내용
    - **특징**
        - **운영 요구사항:** 윈도우, 리눅스, Mac OS에서 동작 가능.
        - **자원 요구사항:** 최소한의 메모리 제공 필요.
        - **성능 요구사항:** 질의 응답 시간 1초 이내, 실시간 데이터베이스 업데이트 가능.
        - **보안 요구사항:** 사용자별 접근 권한 제한, 데이터 암호화.
        - **문화적/정책적 요구사항:** 한글 및 영어 지원, 날짜 표기는 MM/DD/YYYY 형식.
- **품질 요구사항**
    - **가용성 (Availability):** 주어진 환경에서 특정 목적을 위해, 고정 없이 운영될 수 있는 확률. 즉, 서비스가 올바르게 정해진 대로 제공될 확률
    - **신뢰성 (Reliability):** 주어진 시점에서 요청된 서비스가 제공되고 운영될 수 있는 확률. 즉, 서비스를 요청했을 때, 서비스를 제공할 수 있는 확률

### 요구 사항 수집 기법

- **인터뷰**
    - 이해관계자와의 대면 인터뷰를 통해 요구사항을 수집.
    - **장점**: 구체적이고 심층적인 정보 획득 가능.
    - **단점**: 시간 소모가 크고, 인터뷰 대상자의 협조가 필수적.
    - **단계**
        - **인터뷰 준비 단계:** 인터뷰 대상자 선정 → 인터뷰 계획 수립 → 인터뷰 준비
        - **인터뷰 실시 단계:** 인터뷰 시작 → 인터뷰 실시 → 인터뷰 종료
        - **인터뷰 정리 단계:** 인터뷰 결과 정리 → 결과 공지 → 인터뷰 과정 평가
- **설문**
    - **설문 대상 선정:** 설문지 배포 대상을 적절히 선정. 대상자의 연령, 직업군, 역할 등을 고려하여 그룹을 선정
    - **설문 문항 작성:** 설문 문항의 구조화 필요. 문항 이외의 정보를 확보하기 어렵기 때문에 문항 설계에 집중 필요
    - **설문지 회수 방법:** 설문 결과를 회수하기 위한 전략 필요
    - **특징**
        - 관심있고 쉬운 질문으로 시작하고, 서로 관련성 있는 질문 내용을 그룹으로 묶어 구성
        - 끝부분에 중요한 설문 내용을 두지 않으며, 한 페이지에 너무 많은 설문을 담지 않음
        - 어렵거나 전문적인 약어사용 자제, 편향된 질문이나 답을 유도하는 형식의 질문 금지
- **관찰**
    - 사용자가 실제로 시스템을 사용하는 상황을 관찰하여 정보를 수집
    - **특징**
        - 사용자 행동을 정확히 파악할 수 있음
        - 사용자가 인지하지 못하는 문제점 발견 가능
- **워크숍**
    - 여러 이해관계자가 모여 협력하여 요구사항을 도출하는 방법
    - **특징**
        - 공동 작업으로 다양한 의견을 수집
        - 빠르게 요구사항을 합의

### 요구 사항 명세서 작성

- **요구 사항 명세서(Requiement Specification)**
    - 요구분석 단계에서 생성되는 최종 산출물이며, 시스템의 기능이 무엇인지에만 초점을 두고 정리
- **필요성**
    - 분석가와 사용자의 배경 지식이 너무 다르기 때문에 분석가가 요구분석명세서를 작성하는 일은 어려움
    - 완전한 요구분석명세서를 작성하려면 분석가는 현행 업무 내용을 충분히 파악한 후
    사용자와 대화할 수 있도록 준비
- **평가 기준**
    - **무결성 (Correctness):** 사용자 요구와 명시된 요구 중첩 부분이 정확한 요구사항임
    - **일관성 (Consistency):** 명세 내용 간의 상호 모순이 없어야 함
    - **명확성 (Unambiguousness):** 각 요구사항 명세 내용은 하나의 의미만 보유해야 함
    - **기능성 (Functionality):** How 보다는 What에 관점을 주고 기술해야 함
    - **검증 가능성 (Verifiability):** 요구사항 내용의 충족 여부와 달성 정도를 확인해야 함
    - **수정 가능성 (Modifiability):** 요구사항 변경 시 쉽게 수정 가능해야 함
    - **완전성 (Completeness):** 요구 분석 명세서는 기능 요구사항 뿐만 아니라
    성능, 제약 사항 등의 비기능 요구사항이 빠지지 않고 모두 서술되어야 완전한 것임
    - **중요성 (Importance):** 중요도와 안전성 기준 우선순위를 부여해야 함

### 요구 사항 검증 및 관리

- **검증 기법**
    - **리뷰:** 요구사항 명세서를 이해관계자와 함께 검토.
    - **프로토타이핑:** 요구사항을 기반으로 간단한 시제품을 개발하여 확인.
    - **모델링:** 다이어그램이나 시뮬레이션을 사용하여 요구사항을 시각적으로 표현.
- **요구사항 변경 관리**
    - **절차:** 변경 요청 접수 → 영향 분석 → 변경 승인/거절 → 변경 내용 반영 및 문서 업데이트.
