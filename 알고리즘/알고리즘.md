# 알고리즘

## 정렬 (Sorting)

데이터를 특정 기준에 따라 순서대로 배치하는 과정이다. 

- **기본 정렬 알고리즘**
    - **버블 정렬 (Bubble Sort)**
        - **원리**: 인접한 두 요소를 비교하여 필요에 따라 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (이미 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 간단하지만 효율성이 낮아 실제 사용은 드물다.
        - **사용 예시**: 작은 데이터셋에서 빠르게 정렬을 확인하고자 할 때 유용하다. 예를 들어, 데이터가 이미 거의 정렬되어 있는 경우에 사용될 수 있다. 실제 사용에서는 성능 문제로 거의 사용되지 않는다.
        
        ```c
        void bubbleSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        // Swap arr[j] and arr[j+1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
        ```
        
    - **선택 정렬 (Selection Sort)**
        - **원리**: 배열에서 가장 작은(또는 큰) 요소를 선택해 정렬되지 않은 부분의 맨 앞 요소와 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선/평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 비교 횟수가 많지만 교환 횟수는 적다.
        - **사용 예시**: 작은 데이터셋에서 비교 횟수를 최소화하고자 할 때 사용된다. 예를 들어, 메모리 사용이 제한된 환경에서 최소한의 교환으로 정렬하고자 할 때 활용된다.
        
        ```c
        void selectionSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                int minIdx = i;
                // arr[i+1..n-1]에서 최소값의 인덱스를 찾음
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                // arr[i]와 arr[minIdx]를 교환
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        ```
        
    - **삽입 정렬 (Insertion Sort)**
        - **원리**: 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (거의 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 작은 데이터셋에 효과적이며 안정 정렬이다.
        - **사용 예시**: 데이터가 거의 정렬되어 있을 때 빠르게 처리할 수 있다. 예를 들어, 동적으로 정렬되는 리스트에서 새로운 데이터를 추가할 때 유용하다.
        
        ```c
        void insertionSort(int arr[], int n) {
            for (int i = 1; i < n; i++) {
                int key = arr[i];
                int j = i - 1;
        
                // arr[0..i-1]의 요소 중 key보다 큰 요소들을 현재 위치보다 한 칸 뒤로 이동
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key; // key를 올바른 위치에 삽입
            }
        }
        ```
        
- **고급 정렬 알고리즘**
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누고 정렬한 후 병합.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **특징**: 안정 정렬, 재귀적 구현.
        - **사용 예시**: 데이터의 크기가 크고, 안정적인 정렬이 필요할 때 사용된다. 예를 들어, 대규모 데이터 처리, 파일 정렬, 외부 정렬 등에서 사용된다. 또한, 분할 정복 방식을 사용하기 때문에 복잡한 정렬 문제에도 적합하다.
        
        ```c
        void merge(int arr[], int l, int m, int r) {
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (int i = 0; i < n1; i++) L[i] = arr[l + i];
            for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
        
            int i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) arr[k++] = L[i++];
                else arr[k++] = R[j++];
            }
            while (i < n1) arr[k++] = L[i++];
            while (j < n2) arr[k++] = R[j++];
        }
        
        void mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }
        
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
        - **시간 복잡도**:
            - 최선/평균: O(n log n)
            - 최악: O(n²)
        - **공간 복잡도**: O(log n) (재귀 호출 스택)
        - **특징**: 빠르지만 불안정 정렬.
        - **사용 예시**: 빠른 정렬이 필요한 경우에 사용된다. 예를 들어, 일반적인 데이터 정렬에서 퀵 정렬은 평균적으로 매우 빠르게 동작하기 때문에 대부분의 상황에서 사용된다.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        
        ```
        
    - **힙 정렬 (Heap Sort)**
        - **원리**: 힙 자료구조를 사용해 최대값 또는 최소값을 반복적으로 추출.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(1)
        - **특징**: 불안정 정렬.
        - **사용 예시**: 최댓값이나 최솟값을 반복적으로 추출해야 하는 상황에서 유용하다. 예를 들어, 우선순위 큐(우선순위가 높은 데이터를 먼저 꺼내는 자료구조) 구현에 자주 사용된다.
        
        ```c
        void heapify(int arr[], int n, int i) {
            int largest = i;  // 루트
            int left = 2 * i + 1;  // 왼쪽 자식
            int right = 2 * i + 2; // 오른쪽 자식
        
            // 왼쪽 자식이 루트보다 크다면
            if (left < n && arr[left] > arr[largest])
                largest = left;
        
            // 오른쪽 자식이 현재 가장 큰 노드보다 크다면
            if (right < n && arr[right] > arr[largest])
                largest = right;
        
            // 가장 큰 노드가 루트가 아니라면 교환
            if (largest != i) {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
        
                // 재귀적으로 힙을 정렬
                heapify(arr, n, largest);
            }
        }
        
        void heapSort(int arr[], int n) {
            // 힙 생성
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
        
            // 하나씩 요소를 힙에서 제거
            for (int i = n - 1; i > 0; i--) {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
        
                // 힙 정렬
                heapify(arr, i, 0);
            }
        }
        
        ```
        
    - **기수 정렬 (Radix Sort)**
        - **원리**: 자릿수를 기준으로 데이터를 분류하고 병합하여 정렬한다.
        - **시간 복잡도**: O(nk) (n은 데이터 개수, k는 자릿수 길이)
        - **공간 복잡도**: O(n + k)
        - **특징**: 데이터의 크기나 자릿수가 제한적일 때 유용하며 안정 정렬이다.
        - **사용 예시**: 정수나 자릿수가 제한된 데이터에 적합하다. 예를 들어, 전화번호, 우편번호 등의 숫자 데이터를 빠르게 정렬할 때 사용된다.
        
        ```c
        int getMax(int arr[], int n) {
            int max = arr[0];
            for (int i = 1; i < n; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }
        
        void countingSort(int arr[], int n, int exp) {
            int output[n];
            int count[10] = {0};
        
            // 카운트 배열 생성
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;
        
            // 누적 합
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 작성
            for (int i = n - 1; i >= 0; i--) {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }
        
            // 원래 배열 업데이트
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        
        void radixSort(int arr[], int n) {
            int max = getMax(arr, n);
        
            // 각 자릿수에 대해 정렬
            for (int exp = 1; max / exp > 0; exp *= 10)
                countingSort(arr, n, exp);
        }
        ```
        
    - **계수 정렬 (Counting Sort)**
        - **원리**: 데이터의 범위를 기준으로 개수를 세고 누적하여 정렬한다.
        - **시간 복잡도**: O(n + k) (n은 데이터 개수, k는 최대값)
        - **공간 복잡도**: O(n + k)
        - **특징**: 정수 데이터에 적합하며 매우 효율적이지만 범위가 클 경우 메모리 사용량이 증가한다.
        - **사용 예시**: 정수 범위가 제한적인 데이터에서 매우 효율적으로 정렬할 수 있다. 예를 들어, 학생들의 시험 점수, 정수로 표현된 데이터를 다룰 때 매우 효과적이다.
        
        ```c
        void countingSort(int arr[], int n) {
            int output[n];
            int max = arr[0];
        
            for (int i = 1; i < n; i++)
                if (arr[i] > max) max = arr[i];
        
            int count[max + 1];
            memset(count, 0, sizeof(count));
        
            // 카운트 배열 작성
            for (int i = 0; i < n; i++)
                count[arr[i]]++;
        
            // 누적 합
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 생성
            for (int i = n - 1; i >= 0; i--) {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }
        
            // 원래 배열에 결과 복사
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        ```
        
    - **셸 정렬 (Shell Sort)**
        - **원리**: 삽입 정렬을 일반화하여 일정 간격의 요소들만 비교하고 정렬하며, 점차 간격을 좁히는 방식이다.
        - **시간 복잡도**: 평균적으로 O(n log n) ~ O(n²) (간격 선택에 따라 다름)
        - **공간 복잡도**: O(1)
        - **특징**: 비교적 간단한 구현으로 중간 규모의 데이터셋에서 유용하지만 불안정 정렬이다.
        - **사용 예시**: 중간 크기의 데이터셋에서 유용하다. 예를 들어, 데이터가 많이 정렬되어 있지 않지만 상대적으로 빠르게 정렬하고자 할 때 사용된다. 또한, 배열이 크게 분할되어 있지 않거나, 데이터 간 간격이 유리한 경우에 효과적이다.
        
        ```c
        void shellSort(int arr[], int n) {
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i];
                    int j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```
        
- **비교 기반 정렬과 비비교 기반 정렬의 차이**
    - **비교 기반 정렬**:
        - 데이터 간의 크기를 비교하며 정렬한다.
        - 병합 정렬, 퀵 정렬, 힙 정렬 등이 포함된다.
        - 일반적으로 범용적으로 사용 가능하며 시간 복잡도는 O(n log n) 이상이다.
        - **사용 예시**: 대부분의 경우에 사용된다. 예를 들어, 파일 정렬, 데이터베이스의 인덱스 정렬 등에서 사용된다.
    - **비비교 기반 정렬**:
        - 데이터 간의 크기를 비교하지 않고, 키나 자릿수 등 특성을 활용해 정렬한다.
        - 기수 정렬, 계수 정렬 등이 포함된다.
        - 데이터 특성에 따라 효율적이며 O(n)까지의 시간 복잡도를 가지지만 제한적이다.
        - **사용 예시**: 정수 범위가 정해져 있거나 자릿수 기준으로 정렬을 할 때 사용된다. 예를 들어, 전화번호, 주민등록번호 등을 정렬할 때 유용하다.
     
## 탐색 (Search)

- **기본 탐색 알고리즘**
    - **선형 탐색 (Linear Search)**
        - **원리**: 배열의 첫 번째 요소부터 끝까지 하나씩 확인하여 원하는 값을 찾는다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(1)
        - **특징**: 데이터가 정렬되지 않았을 때 사용할 수 있으며, 최악의 경우 모든 요소를 확인해야 한다.
        - **사용 예시**: 작은 데이터셋에서 사용되며, 데이터가 정렬되지 않았거나, 간단히 특정 값을 찾고자 할 때 유용하다. 예를 들어, 연락처 목록에서 특정 번호를 찾을 때 사용될 수 있다.
        
        ```c
        int linearSearch(int arr[], int n, int target) {
            for (int i = 0; i < n; i++) {
                if (arr[i] == target) {
                    return i;  // 타겟 값을 찾았으면 인덱스 반환
                }
            }
            return -1;  // 찾지 못한 경우
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누며 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀) / O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 데이터가 크면 매우 효율적이다.
        - **사용 예시**: 정렬된 데이터에서 빠르게 원하는 값을 찾고자 할 때 사용된다. 예를 들어, 대규모 데이터베이스에서 특정 항목을 찾을 때 유용하다.
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;  // 찾지 못한 경우
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;  // 타겟 값을 찾았으면 인덱스 반환
            } else if (arr[mid] > target) {
                return binarySearch(arr, left, mid - 1, target);  // 왼쪽 부분 탐색
            } else {
                return binarySearch(arr, mid + 1, right, target);  // 오른쪽 부분 탐색
            }
        }
        ```
        
    - **이진 탐색 변형 (lower/upper bound 등)**
        - **원리**: 이진 탐색을 변형하여 특정 값이 들어갈 수 있는 최솟값 (lower bound) 또는 최댓값 (upper bound)을 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1)
        - **사용 예시**: 정렬된 데이터에서 특정 범위나 위치를 찾을 때 유용하다. 예를 들어, 주식 거래에서 특정 가격을 찾을 때나, 정렬된 날짜 리스트에서 특정 날짜 이후의 항목을 찾을 때 사용된다.
        
        ```c
        int lowerBound(int arr[], int n, int target) {
            int left = 0, right = n;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] < target) {
                    left = mid + 1;  // target보다 작은 값은 left로
                } else {
                    right = mid;  // target보다 크거나 같은 값은 right로
                }
            }
            return left;  // 타겟 값을 넣을 수 있는 위치
        }
        ```
        
- **고급 탐색 알고리즘**
    - **이진 검색 트리 (Binary Search Tree) 기반 탐색**
        - **원리**: 이진 트리 구조에서 각 노드는 왼쪽 자식은 자신보다 작은 값, 오른쪽 자식은 자신보다 큰 값을 가진다. 이를 이용해 효율적으로 탐색한다.
        - **시간 복잡도**: O(log n) (평균적으로), O(n) (최악, 트리가 한 줄로 될 경우)
        - **공간 복잡도**: O(n)
        - **특징**: 트리 구조로 동적 데이터를 관리하며 삽입, 삭제가 효율적이다.
        - **사용 예시**: 동적으로 삽입과 삭제가 자주 발생하는 데이터에 대해 효율적으로 탐색하고자 할 때 사용된다. 예를 들어, 검색 엔진의 색인 시스템에서 키워드를 빠르게 찾기 위해 사용될 수 있다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->left = node->right = NULL;
            return node;
        }
        
        struct Node* insert(struct Node* root, int data) {
            if (root == NULL) return newNode(data);
            
            if (data < root->data) {
                root->left = insert(root->left, data);  // 왼쪽 서브트리에 삽입
            } else {
                root->right = insert(root->right, data);  // 오른쪽 서브트리에 삽입
            }
            return root;
        }
        
        struct Node* search(struct Node* root, int target) {
            if (root == NULL || root->data == target) return root;
            if (target < root->data) return search(root->left, target);  // 왼쪽 서브트리 탐색
            return search(root->right, target);  // 오른쪽 서브트리 탐색
        }
        ```
        
    - **해시 기반 탐색 (Hash-based Search)**
        - **원리**: 해시 테이블을 사용하여 데이터를 키 값으로 매핑하고, 해당 키에 대해 빠르게 데이터를 찾는다.
        - **시간 복잡도**: O(1) (평균적으로)
        - **공간 복잡도**: O(n)
        - **특징**: 해시 충돌이 발생할 수 있으며, 빠른 탐색 속도를 제공한다.
        - **사용 예시**: 해시 테이블을 활용해 빠른 조회를 필요로 하는 시스템에서 사용된다. 예를 들어, 사용자 정보, 세션 관리, 단어 검색 등에서 효과적이다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define TABLE_SIZE 10
        
        struct HashNode {
            int key;
            int value;
            struct HashNode* next;
        };
        
        struct HashTable {
            struct HashNode* table[TABLE_SIZE];
        };
        
        int hash(int key) {
            return key % TABLE_SIZE;
        }
        
        void insert(struct HashTable* ht, int key, int value) {
            int index = hash(key);
            struct HashNode* newNode = (struct HashNode*)malloc(sizeof(struct HashNode));
            newNode->key = key;
            newNode->value = value;
            newNode->next = ht->table[index];
            ht->table[index] = newNode;
        }
        
        struct HashNode* search(struct HashTable* ht, int key) {
            int index = hash(key);
            struct HashNode* node = ht->table[index];
            while (node != NULL) {
                if (node->key == key) return node;
                node = node->next;
            }
            return NULL;
        }
        ```
        
    - **트라이 (Trie) 기반 검색**
        - **원리**: 문자열을 트리 구조로 저장하고, 접두사 검색이 효율적이다. 주로 문자열 검색에 사용된다.
        - **시간 복잡도**: O(m) (m은 검색할 문자열의 길이)
        - **공간 복잡도**: O(n * m) (n은 문자열 개수, m은 문자열 길이)
        - **특징**: 빠른 접두사 검색이 가능하며, 자동완성 및 사전 검색에 유용하다.
        - **사용 예시**: 문자열을 빠르게 검색하고자 할 때 사용된다. 예를 들어, 자동 완성 시스템, 사전 검색, 접두사 검색 등이 있다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        #define ALPHABET_SIZE 26
        
        struct TrieNode {
            struct TrieNode* children[ALPHABET_SIZE];
            int isEndOfWord;
        };
        
        struct TrieNode* getNode(void) {
            struct TrieNode* node = (struct TrieNode*)malloc(sizeof(struct TrieNode));
            node->isEndOfWord = 0;
            for (int i = 0; i < ALPHABET_SIZE; i++) {
                node->children[i] = NULL;
            }
            return node;
        }
        
        void insert(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    node->children[index] = getNode();
                }
                node = node->children[index];
            }
            node->isEndOfWord = 1;
        }
        
        int search(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    return 0;
                }
                node = node->children[index];
            }
            return (node != NULL && node->isEndOfWord);
        }
        ```

## 재귀 및 분할 정복

- **재귀 (Recursion):** 함수가 자기 자신을 호출하는 방식이다. 문제를 동일한 형태로 분할하여 반복적으로 해결하는 방식이다.
    - **기본 재귀 및 기저 조건**
        - **원리**: 함수가 자기 자신을 호출하는 방식이다. 재귀는 항상 **기저 조건(base case)**이 있어야 하며, 이 조건을 만족하면 재귀 호출을 종료한다.
        - **시간 복잡도**: 문제에 따라 다르며, 재귀 깊이에 비례하는 경우가 많다.
        - **공간 복잡도**: 재귀 호출 시 스택에 쌓이는 호출 기록에 따라 공간 복잡도가 늘어난다.
        - **특징**: 문제를 분할하여 해결하는 방식이며, 재귀 깊이가 지나치게 깊어지면 스택 오버플로우가 발생할 수 있다.
        - **사용 예시)** 팩토리얼 계산, 피보나치 수열, 트리 탐색, 분할 정복 알고리즘 등에서 사용된다.
            - 예를 들어, 트리 순회에서 트리 구조를 탐색할 때 (예: 이진 트리의 전위/중위/후위 순회) 재귀를 자주 사용하거나 분할 정복 알고리즘에서 문제를 작은 하위 문제로 나누어 해결할 때, 재귀를 많이 사용한다.
        - **예시)** 팩토리얼 계산
        
        ```c
        int factorial(int n) {
            if (n <= 1)  // 기저 조건
                return 1;
            else
                return n * factorial(n - 1);  // 재귀 호출
        }
        ```
        
    - **꼬리 재귀 (Tail Recursion)**
        - **원리**: 재귀 함수 호출이 함수의 마지막 작업일 때, 꼬리 재귀라고 한다. 꼬리 재귀는 컴파일러 최적화가 가능하며, 스택 사용을 최소화할 수 있다.
        - **특징**: 꼬리 재귀는 재귀 호출이 끝난 후 추가적인 계산이 없기 때문에 스택 공간을 절약할 수 있다.
        - **예시)** 꼬리 재귀로 구현한 팩토리얼
        
        ```c
        int tailFactorial(int n, int accumulator) {
            if (n <= 1)  // 기저 조건
                return accumulator;
            else
                return tailFactorial(n - 1, n * accumulator);  // 재귀 호출
        }
        ```
        
    - **재귀와 반복 비교**
        - **재귀:** 문제를 더 자연스럽게 해결할 수 있지만, **반복**에 비해 성능이 떨어질 수 있다. 재귀는 함수 호출에 따른 오버헤드가 있으며, 깊이가 깊어지면 스택 공간을 많이 사용한다.
            - 
        - **반복:** 성능 면에서 효율적일 수 있지만, 때로는 복잡한 문제를 해결하기 위해 여러 가지 상태 변수를 추적해야 하므로 코드가 복잡해질 수 있다.
- **분할 정복 (Divide and Conquer):** 분할 정복은 큰 문제를 작은 문제로 나눈 후, 각각을 해결한 뒤 그 결과를 합치는 방식이다. 이 알고리즘은 재귀적 성격을 가질 때가 많다.
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누어 각각을 정렬한 후, 두 개의 정렬된 배열을 합치는 방식이다. 재귀적으로 배열을 나누며, 나누어진 배열을 병합한다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n) (배열을 임시로 저장하는 공간 필요)
        - **특징**: 안정적인 정렬 알고리즘이며, 최악의 경우에도 O(n log n)으로 성능이 일정하다.
        - **사용 예시)** 데이터 정렬이 필요한 경우 (예: 대규모 데이터의 정렬, 텍스트 파일 정렬 등)
        
        ```c
        void merge(int arr[], int left, int mid, int right) {
            int n1 = mid - left + 1;
            int n2 = right - mid;
            
            int leftArr[n1], rightArr[n2];
            
            for (int i = 0; i < n1; i++)
                leftArr[i] = arr[left + i];
            for (int i = 0; i < n2; i++)
                rightArr[i] = arr[mid + 1 + i];
            
            int i = 0, j = 0, k = left;
            while (i < n1 && j < n2) {
                if (leftArr[i] <= rightArr[j]) {
                    arr[k] = leftArr[i];
                    i++;
                } else {
                    arr[k] = rightArr[j];
                    j++;
                }
                k++;
            }
            
            while (i < n1) {
                arr[k] = leftArr[i];
                i++;
                k++;
            }
            
            while (j < n2) {
                arr[k] = rightArr[j];
                j++;
                k++;
            }
        }
        
        void mergeSort(int arr[], int left, int right) {
            if (left < right) {
                int mid = left + (right - left) / 2;
                mergeSort(arr, left, mid);
                mergeSort(arr, mid + 1, right);
                merge(arr, left, mid, right);
            }
        }
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 배열을 기준 값(pivot)을 중심으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치하며, 각 부분 배열을 재귀적으로 정렬한다.
        - **시간 복잡도**: O(n log n) (평균), O(n²) (최악)
        - **공간 복잡도**: O(log n) (최대 깊이)
        - **특징**: 평균적으로 매우 빠른 정렬 알고리즘이며, 대부분의 경우 O(n log n)으로 동작한다. 그러나 최악의 경우 O(n²)이 될 수 있다.
        - **사용 예시)** 대체로 평균적인 경우 매우 빠른 성능을 보이며, 예를 들어, 데이터베이스에서 인덱스 생성을 위한 정렬에 사용된다.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            
            for (int j = low; j <= high - 1; j++) {
                if (arr[j] <= pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                
                quickSort(arr, low, pi - 1);  // 왼쪽 부분 정렬
                quickSort(arr, pi + 1, high);  // 오른쪽 부분 정렬
            }
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누어 값을 찾는 방법이다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀), O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 매우 빠른 탐색을 제공한다.
        - **사용 예시)** 정렬된 배열에서 특정 값을 찾는 경우 (예: 정렬된 숫자 배열에서 값이 있는지 확인하거나 데이터베이스에서 특정 레코드를 빠르게 찾는 경우)
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) return mid;
            else if (arr[mid] > target) return binarySearch(arr, left, mid - 1, target);
            else return binarySearch(arr, mid + 1, right, target);
        }
        ```
        
- **백트래킹 (Backtracking):** 가능한 모든 해를 탐색하며, 유망하지 않은 경로는 더 이상 탐색하지 않고 되돌아가는 방식이다. 이는 문제를 풀어가면서 중간에 잘못된 방향으로 간다면 그 부분을 되돌려 다른 경로를 시도한다.
    - **N-Queens**
        - **원리**: N개의 퀸을 N×N 체스판에 배치하는 문제로, 퀸이 서로 공격하지 않도록 배치해야 한다.
        - **시간 복잡도**: O(N!)
        - **공간 복잡도**: O(N)
        - **특징**: 백트래킹을 사용하여 가능한 모든 배치 방법을 탐색하며 해결한다.
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 4
        
        bool isSafe(int board[N][N], int row, int col) {
            // 동일한 열에 퀸이 있는지 확인
            for (int i = 0; i < row; i++) {
                if (board[i][col] == 1) return false;
            }
            
            // 왼쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
                if (board[i][j] == 1) return false;
            }
            
            // 오른쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j < N; i--, j++) {
                if (board[i][j] == 1) return false;
            }
            
            return true;
        }
        
        bool solveNQueens(int board[N][N], int row) {
            if (row >= N) return true;
            
            for (int i = 0; i < N; i++) {
                if (isSafe(board, row, i)) {
                    board[row][i] = 1;
                    if (solveNQueens(board, row + 1)) return true;
                    board[row][i] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printSolution(int board[N][N]) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%d ", board[i][j]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int board[N][N] = {0};
            
            if (solveNQueens(board, 0)) {
                printSolution(board);
            } else {
                printf("Solution does not exist\n");
            }
            
            return 0;
        }
        ```
        
    - **Sudoku Solver**
        - **원리**: 스도쿠 퍼즐을 해결하는 문제로, 각 칸에 1부터 9까지 숫자를 채우되, 가로, 세로, 3x3 박스에 동일한 숫자가 두 번 이상 나타나지 않도록 한다.
        - **시간 복잡도**: O(9^(n*n)) (전체 가능한 숫자 배치의 수)
        - **공간 복잡도**: O(n*n) (퍼즐의 크기)
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 9
        
        // 9x9 스도쿠 판에서 (row, col)에 숫자 num을 넣을 수 있는지 확인
        bool isSafe(int grid[N][N], int row, int col, int num) {
            // 같은 행, 열에 num이 있는지 확인
            for (int x = 0; x < 9; x++) {
                if (grid[row][x] == num || grid[x][col] == num) {
                    return false;
                }
            }
            
            // 3x3 박스에 num이 있는지 확인
            int startRow = row - row % 3, startCol = col - col % 3;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] == num) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 스도쿠 해결 함수
        bool solveSudoku(int grid[N][N]) {
            int row, col;
            bool isEmpty = true;
            
            for (row = 0; row < N; row++) {
                for (col = 0; col < N; col++) {
                    if (grid[row][col] == 0) {
                        isEmpty = false;
                        break;
                    }
                }
                if (!isEmpty) break;
            }
            
            if (isEmpty) return true;  // 모든 칸이 채워지면 해결됨
            
            for (int num = 1; num <= 9; num++) {
                if (isSafe(grid, row, col, num)) {
                    grid[row][col] = num;
                    
                    if (solveSudoku(grid)) return true;
                    
                    grid[row][col] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printGrid(int grid[N][N]) {
            for (int r = 0; r < N; r++) {
                for (int d = 0; d < N; d++) {
                    printf("%d ", grid[r][d]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int grid[N][N] = {
                {5, 3, 0, 0, 7, 0, 0, 0, 0},
                {6, 0, 0, 1, 9, 5, 0, 0, 0},
                {0, 9, 8, 0, 0, 0, 0, 6, 0},
                {8, 0, 0, 0, 6, 0, 0, 0, 3},
                {4, 0, 0, 8, 0, 3, 0, 0, 1},
                {7, 0, 0, 0, 2, 0, 0, 0, 6},
                {0, 6, 0, 0, 0, 0, 2, 8, 0},
                {0, 0, 0, 4, 1, 9, 0, 0, 5},
                {0, 0, 0, 0, 8, 0, 0, 7, 9}
            };
            
            if (solveSudoku(grid)) {
                printGrid(grid);
            } else {
                printf("No solution exists\n");
            }
            
            return 0;
        }
        ```

## 그리디 알고리즘 (Greedy Algorithm)

- **개념 및 특징**
    - **개념:**
        - 그리디 알고리즘은 **매 단계에서 최적이라고 생각되는 선택을 하는 알고리즘**이다. 이를 통해 전체 문제의 최적해를 구하는 방법이지만, 모든 경우에 최적해를 보장하지는 않는다. 그리디 알고리즘은 **문제의 구조**와 **문제의 특성**에 따라 최적해를 도출할 수 있는 경우에만 사용한다.
    - **특징:**
        - **단계적 최적 선택**: 매 단계에서 최적의 선택을 하며, 이를 통해 전체 최적해를 구하는 방식이다.
        - **지역 최적화**: 각 단계에서 가장 좋은 선택을 하되, 전체적인 최적 해를 보장하지 않음.
        - **구현이 간단**: 복잡한 DP(동적 계획법) 방식에 비해 구현이 간단하고 직관적이다.
        - **결과가 항상 최적이 아닐 수 있다**: 모든 문제에 대해 항상 최적해를 보장하지 않는다.
- **대표 문제**
    - **동전 거슬러 주기 (Coin Change Problem)**
        - **문제**: 특정 금액을 최소 개수의 동전으로 거슬러 주는 문제이다. 주어진 동전의 종류를 사용하여 금액을 만들 때, 최소 동전 개수를 구하는 것이 목표이다.
        - **그리디 접근**: 가장 큰 동전부터 차례대로 거슬러 주면, 최소 개수의 동전을 사용할 수 있다.
        - **시간 복잡도**: O(n) (각 동전 종류에 대해 한번씩 탐색)
        - **공간 복잡도**: O(1)
        
        ```c
        #include <stdio.h>
        
        int coinChange(int coins[], int n, int amount) {
            int count = 0;
            for (int i = 0; i < n; i++) {
                while (amount >= coins[i]) {
                    amount -= coins[i];
                    count++;
                }
            }
            return count;
        }
        
        int main() {
            int coins[] = {25, 10, 5, 1};
            int n = sizeof(coins) / sizeof(coins[0]);
            int amount = 63;
            printf("Minimum coins required: %d\n", coinChange(coins, n, amount));
            return 0;
        }
        
        // 출력 예시:
        Minimum coins required: 6
        ```
        
    - **활동 선택 문제 (Activity Selection Problem)**
        - **문제**: 여러 활동이 주어지고, 각 활동은 시작 시간과 종료 시간을 가진다. 활동들이 겹치지 않게 최대한 많이 선택할 때, 선택할 수 있는 활동의 최대 개수를 구하는 문제이다.
        - **그리디 접근**: 종료 시간이 가장 빠른 활동을 선택하고, 그 후에 겹치지 않는 활동들을 선택하는 방식이다.
        - **시간 복잡도**: O(n log n) (정렬에 걸리는 시간)
        - **공간 복잡도**: O(1)
        
        ```c
        #include <stdio.h>
        #include <algorithm>
        
        struct Activity {
            int start, end;
        };
        
        bool compare(Activity a, Activity b) {
            return a.end < b.end;
        }
        
        int maxActivities(Activity arr[], int n) {
            std::sort(arr, arr + n, compare);
            int count = 1, lastEnd = arr[0].end;
            for (int i = 1; i < n; i++) {
                if (arr[i].start >= lastEnd) {
                    count++;
                    lastEnd = arr[i].end;
                }
            }
            return count;
        }
        
        int main() {
            Activity arr[] = {{1, 3}, {2, 5}, {4, 7}, {6, 8}};
            int n = sizeof(arr) / sizeof(arr[0]);
            printf("Maximum number of activities: %d\n", maxActivities(arr, n));
            return 0;
        }
        
        // 출력 예시:
        Maximum number of activities: 3
        ```
        
    - **최소 신장 트리 (MST)**
        - **문제**: 가중치가 부여된 연결 그래프에서 모든 정점을 포함하면서 가중치의 합이 최소가 되는 트리를 찾는 문제이다.
        - **그리디 알고리즘**을 통해 해결할 수 있으며, 대표적으로 **크루스칼 알고리즘**과 **프림 알고리즘**이 있다.
            - **크루스칼 알고리즘**
                - **원리**: 간선들을 가중치가 작은 순서대로 정렬한 후, 사이클을 만들지 않도록 간선을 추가한다.
                - **시간 복잡도**: O(E log E) (간선의 수 E에 대해 정렬이 필요함)
                - **공간 복잡도**: O(E + V)
                - **사용 예시)** 통신 네트워크 구축, 도로 네트워크 설계
                
                ```c
                #include <stdio.h>
                #include <algorithm>
                
                struct Edge {
                    int u, v, weight;
                };
                
                bool compare(Edge e1, Edge e2) {
                    return e1.weight < e2.weight;
                }
                
                int find(int parent[], int i) {
                    if (parent[i] == i)
                        return i;
                    return find(parent, parent[i]);
                }
                
                void unionSets(int parent[], int rank[], int x, int y) {
                    int rootX = find(parent, x);
                    int rootY = find(parent, y);
                
                    if (rootX != rootY) {
                        if (rank[rootX] > rank[rootY])
                            parent[rootY] = rootX;
                        else if (rank[rootX] < rank[rootY])
                            parent[rootX] = rootY;
                        else {
                            parent[rootY] = rootX;
                            rank[rootX]++;
                        }
                    }
                }
                
                int kruskal(Edge edges[], int V, int E) {
                    int parent[V], rank[V], mstWeight = 0;
                    for (int i = 0; i < V; i++) {
                        parent[i] = i;
                        rank[i] = 0;
                    }
                
                    std::sort(edges, edges + E, compare); // 간선 정렬
                
                    for (int i = 0; i < E; i++) {
                        int u = edges[i].u;
                        int v = edges[i].v;
                
                        if (find(parent, u) != find(parent, v)) {
                            unionSets(parent, rank, u, v);
                            mstWeight += edges[i].weight;
                        }
                    }
                    return mstWeight;
                }
                
                int main() {
                    Edge edges[] = {
                        {0, 1, 10}, {0, 2, 6}, {0, 3, 5}, {1, 3, 15}, {2, 3, 4}
                    };
                    int V = 4; // 정점 개수
                    int E = 5; // 간선 개수
                    printf("Minimum spanning tree weight: %d\n", kruskal(edges, V, E));
                    return 0;
                }
                
                // 출력 예시:
                Minimum spanning tree weight: 19
                ```
                
            - **프림 알고리즘**
                - **원리**: 임의의 정점에서 시작해, 그 정점과 연결된 간선들 중 가장 작은 가중치의 간선을 선택해 트리를 확장해 나간다.
                - **시간 복잡도**: O(E log V) (우선순위 큐를 사용하는 경우)
                - **공간 복잡도**: O(V)
                - **사용 예시)** 전력망 설계, 통신망 연결
                
                ```c
                #include <stdio.h>
                #include <limits.h>
                
                #define V 5 // 정점의 개수
                
                int minKey(int key[], bool mstSet[]) {
                    int min = INT_MAX, min_index;
                    for (int v = 0; v < V; v++) {
                        if (!mstSet[v] && key[v] < min) {
                            min = key[v];
                            min_index = v;
                        }
                    }
                    return min_index;
                }
                
                void prim(int graph[V][V]) {
                    int parent[V], key[V];
                    bool mstSet[V];
                
                    for (int i = 0; i < V; i++) {
                        key[i] = INT_MAX;
                        mstSet[i] = false;
                    }
                    key[0] = 0;
                    parent[0] = -1;
                
                    for (int count = 0; count < V - 1; count++) {
                        int u = minKey(key, mstSet);
                        mstSet[u] = true;
                
                        for (int v = 0; v < V; v++) {
                            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                                parent[v] = u;
                                key[v] = graph[u][v];
                            }
                        }
                    }
                
                    printf("Edge \tWeight\n");
                    for (int i = 1; i < V; i++) {
                        printf("%d - %d \t%d\n", parent[i], i, graph[i][parent[i]]);
                    }
                }
                
                int main() {
                    int graph[V][V] = {
                        {0, 2, 0, 6, 0},
                        {2, 0, 3, 8, 5},
                        {0, 3, 0, 0, 7},
                        {6, 8, 0, 0, 9},
                        {0, 5, 7, 9, 0}
                    };
                    prim(graph);
                    return 0;
                }
                
                // 출력 예시:
                Edge    Weight
                0 - 1    2
                0 - 3    6
                1 - 2    3
                1 - 4    5
                ```
                
    - **허프만 코딩 (Huffman Coding)**
        - **문제**: 주어진 문자들의 빈도수를 기반으로 각 문자를 효율적인 이진 코드로 압축하는 문제이다. 빈도가 높은 문자는 짧은 코드, 빈도가 낮은 문자는 긴 코드를 할당하여 데이터의 압축을 최적화한다.
        - **그리디 접근**: 빈도수가 낮은 두 문자를 결합하여 새로운 노드를 만들고, 이를 반복적으로 진행한다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 파일 압축, 문자열 압축
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        struct Node {
            char data;
            int freq;
            struct Node *left, *right;
        };
        
        struct MinHeap {
            int size;
            int capacity;
            struct Node** array;
        };
        
        struct Node* newNode(char data, int freq) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->freq = freq;
            node->left = node->right = NULL;
            return node;
        }
        
        struct MinHeap* createMinHeap(int capacity) {
            struct MinHeap* minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));
            minHeap->size = 0;
            minHeap->capacity = capacity;
            minHeap->array = (struct Node**)malloc(minHeap->capacity * sizeof(struct Node*));
            return minHeap;
        }
        
        void swapNode(struct Node** a, struct Node** b) {
            struct Node* temp = *a;
            *a = *b;
            *b = temp;
        }
        
        void minHeapify(struct MinHeap* minHeap, int idx) {
            int smallest = idx;
            int left = 2 * idx + 1;
            int right = 2 * idx + 2;
        
            if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)
                smallest = left;
        
            if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)
                smallest = right;
        
            if (smallest != idx) {
                swapNode(&minHeap->array[smallest], &minHeap->array[idx]);
                minHeapify(minHeap, smallest);
            }
        }
        
        void buildMinHeap(struct MinHeap* minHeap) {
            int n = minHeap->size - 1;
            for (int i = (n - 1) / 2; i >= 0; i--)
                minHeapify(minHeap, i);
        }
        
        struct Node* extractMin(struct MinHeap* minHeap) {
            struct Node* temp = minHeap->array[0];
            minHeap->array[0] = minHeap->array[minHeap->size - 1];
            --minHeap->size;
            minHeapify(minHeap, 0);
            return temp;
        }
        
        void insertMinHeap(struct MinHeap* minHeap, struct Node* node) {
            ++minHeap->size;
            int i = minHeap->size - 1;
            while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {
                minHeap->array[i] = minHeap->array[(i - 1) / 2];
                i = (i - 1) / 2;
            }
            minHeap->array[i] = node;
        }
        
        void printHuffmanCodes(struct Node* root, int arr[], int top) {
            if (root->left) {
                arr[top] = 0;
                printHuffmanCodes(root->left, arr, top + 1);
            }
        
            if (root->right) {
                arr[top] = 1;
                printHuffmanCodes(root->right, arr, top + 1);
            }
        
            if (!root->left && !root->right) {
                printf("%c: ", root->data);
                for (int i = 0; i < top; i++)
                    printf("%d", arr[i]);
                printf("\n");
            }
        }
        
        void HuffmanCodes(char data[], int freq[], int size) {
            struct Node *left, *right, *top;
        
            struct MinHeap* minHeap = createMinHeap(size);
        
            for (int i = 0; i < size; ++i)
                insertMinHeap(minHeap, newNode(data[i], freq[i]));
        
            while (minHeap->size != 1) {
                left = extractMin(minHeap);
                right = extractMin(minHeap);
        
                top = newNode('$', left->freq + right->freq);
                top->left = left;
                top->right = right;
        
                insertMinHeap(minHeap, top);
            }
        
            int arr[100], topIndex = 0;
            printHuffmanCodes(minHeap->array[0], arr, topIndex);
        }
        
        int main() {
            char data[] = {'A', 'B', 'C', 'D', 'E', 'F'};
            int freq[] = {5, 9, 12, 13, 16, 45};
            int size = sizeof(data) / sizeof(data[0]);
        
            HuffmanCodes(data, freq, size);
            return 0;
        }
        
        // 출력 예시:
        F: 0
        E: 10
        D: 110
        C: 1110
        B: 11110
        A: 11111
        ```
