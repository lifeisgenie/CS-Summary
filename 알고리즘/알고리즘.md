# 알고리즘

## 정렬 (Sorting)

데이터를 특정 기준에 따라 순서대로 배치하는 과정이다. 정렬은 알고리즘의 성능과 특성에 따라 다양하게 분류되며, 기술 면접에서도 자주 다루어지는 주제이다.

- **기본 정렬 알고리즘**
    - **버블 정렬 (Bubble Sort)**
        - **원리**: 인접한 두 요소를 비교하여 필요에 따라 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (이미 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 간단하지만 효율성이 낮아 실제 사용은 드물다.
        
        ```c
        void bubbleSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        // Swap arr[j] and arr[j+1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
        ```
        
    - **선택 정렬 (Selection Sort)**
        - **원리**: 배열에서 가장 작은(또는 큰) 요소를 선택해 정렬되지 않은 부분의 맨 앞 요소와 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선/평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 비교 횟수가 많지만 교환 횟수는 적다.
        
        ```c
        void selectionSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                int minIdx = i;
                // arr[i+1..n-1]에서 최소값의 인덱스를 찾음
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                // arr[i]와 arr[minIdx]를 교환
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        ```
        
    - **삽입 정렬 (Insertion Sort)**
        - **원리**: 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (거의 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 작은 데이터셋에 효과적이며 안정 정렬이다.
        
        ```c
        void insertionSort(int arr[], int n) {
            for (int i = 1; i < n; i++) {
                int key = arr[i];
                int j = i - 1;
        
                // arr[0..i-1]의 요소 중 key보다 큰 요소들을 현재 위치보다 한 칸 뒤로 이동
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key; // key를 올바른 위치에 삽입
            }
        }
        ```
        
- **고급 정렬 알고리즘**
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누고 정렬한 후 병합.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **특징**: 안정 정렬, 재귀적 구현.
        
        ```c
        void merge(int arr[], int l, int m, int r) {
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (int i = 0; i < n1; i++) L[i] = arr[l + i];
            for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
        
            int i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) arr[k++] = L[i++];
                else arr[k++] = R[j++];
            }
            while (i < n1) arr[k++] = L[i++];
            while (j < n2) arr[k++] = R[j++];
        }
        
        void mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }
        
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
        - **시간 복잡도**:
            - 최선/평균: O(n log n)
            - 최악: O(n²)
        - **공간 복잡도**: O(log n) (재귀 호출 스택)
        - **특징**: 빠르지만 불안정 정렬.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        
        ```
        
    - **힙 정렬 (Heap Sort)**
        - **원리**: 힙 자료구조를 사용해 최대값 또는 최소값을 반복적으로 추출.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(1)
        - **특징**: 불안정 정렬.
        
        ```c
        void heapify(int arr[], int n, int i) {
            int largest = i;  // 루트
            int left = 2 * i + 1;  // 왼쪽 자식
            int right = 2 * i + 2; // 오른쪽 자식
        
            // 왼쪽 자식이 루트보다 크다면
            if (left < n && arr[left] > arr[largest])
                largest = left;
        
            // 오른쪽 자식이 현재 가장 큰 노드보다 크다면
            if (right < n && arr[right] > arr[largest])
                largest = right;
        
            // 가장 큰 노드가 루트가 아니라면 교환
            if (largest != i) {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
        
                // 재귀적으로 힙을 정렬
                heapify(arr, n, largest);
            }
        }
        
        void heapSort(int arr[], int n) {
            // 힙 생성
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
        
            // 하나씩 요소를 힙에서 제거
            for (int i = n - 1; i > 0; i--) {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
        
                // 힙 정렬
                heapify(arr, i, 0);
            }
        }
        
        ```
        
    - **기수 정렬 (Radix Sort)**
        - **원리**: 자릿수를 기준으로 데이터를 분류하고 병합하여 정렬한다.
        - **시간 복잡도**: O(nk) (n은 데이터 개수, k는 자릿수 길이)
        - **공간 복잡도**: O(n + k)
        - **특징**: 데이터의 크기나 자릿수가 제한적일 때 유용하며 안정 정렬이다.
        
        ```c
        int getMax(int arr[], int n) {
            int max = arr[0];
            for (int i = 1; i < n; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }
        
        void countingSort(int arr[], int n, int exp) {
            int output[n];
            int count[10] = {0};
        
            // 카운트 배열 생성
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;
        
            // 누적 합
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 작성
            for (int i = n - 1; i >= 0; i--) {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }
        
            // 원래 배열 업데이트
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        
        void radixSort(int arr[], int n) {
            int max = getMax(arr, n);
        
            // 각 자릿수에 대해 정렬
            for (int exp = 1; max / exp > 0; exp *= 10)
                countingSort(arr, n, exp);
        }
        ```
        
    - **계수 정렬 (Counting Sort)**
        - **원리**: 데이터의 범위를 기준으로 개수를 세고 누적하여 정렬한다.
        - **시간 복잡도**: O(n + k) (n은 데이터 개수, k는 최대값)
        - **공간 복잡도**: O(n + k)
        - **특징**: 정수 데이터에 적합하며 매우 효율적이지만 범위가 클 경우 메모리 사용량이 증가한다.
        
        ```c
        void countingSort(int arr[], int n) {
            int output[n];
            int max = arr[0];
        
            for (int i = 1; i < n; i++)
                if (arr[i] > max) max = arr[i];
        
            int count[max + 1];
            memset(count, 0, sizeof(count));
        
            // 카운트 배열 작성
            for (int i = 0; i < n; i++)
                count[arr[i]]++;
        
            // 누적 합
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 생성
            for (int i = n - 1; i >= 0; i--) {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }
        
            // 원래 배열에 결과 복사
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        ```
        
    - **셸 정렬 (Shell Sort)**
        - **원리**: 삽입 정렬을 일반화하여 일정 간격의 요소들만 비교하고 정렬하며, 점차 간격을 좁히는 방식이다.
        - **시간 복잡도**: 평균적으로 O(n log n) ~ O(n²) (간격 선택에 따라 다름)
        - **공간 복잡도**: O(1)
        - **특징**: 비교적 간단한 구현으로 중간 규모의 데이터셋에서 유용하지만 불안정 정렬이다.
        
        ```c
        void shellSort(int arr[], int n) {
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i];
                    int j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```
        
- **비교 기반 정렬과 비비교 기반 정렬의 차이**
    - **비교 기반 정렬**:
        - 데이터 간의 크기를 비교하며 정렬한다.
        - 병합 정렬, 퀵 정렬, 힙 정렬 등이 포함된다.
        - 일반적으로 범용적으로 사용 가능하며 시간 복잡도는 O(n log n) 이상이다.
    - **비비교 기반 정렬**:
        - 데이터 간의 크기를 비교하지 않고, 키나 자릿수 등 특성을 활용해 정렬한다.
        - 기수 정렬, 계수 정렬 등이 포함된다.
        - 데이터 특성에 따라 효율적이며 O(n)까지의 시간 복잡도를 가지지만 제한적이다.
     
## 탐색 (Search)

- **기본 탐색 알고리즘**
    - **선형 탐색 (Linear Search)**
        - **원리**: 배열의 첫 번째 요소부터 끝까지 하나씩 확인하여 원하는 값을 찾는다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(1)
        - **특징**: 데이터가 정렬되지 않았을 때 사용할 수 있으며, 최악의 경우 모든 요소를 확인해야 한다.
        
        ```c
        int linearSearch(int arr[], int n, int target) {
            for (int i = 0; i < n; i++) {
                if (arr[i] == target) {
                    return i;  // 타겟 값을 찾았으면 인덱스 반환
                }
            }
            return -1;  // 찾지 못한 경우
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누며 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀) / O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 데이터가 크면 매우 효율적이다.
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;  // 찾지 못한 경우
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;  // 타겟 값을 찾았으면 인덱스 반환
            } else if (arr[mid] > target) {
                return binarySearch(arr, left, mid - 1, target);  // 왼쪽 부분 탐색
            } else {
                return binarySearch(arr, mid + 1, right, target);  // 오른쪽 부분 탐색
            }
        }
        ```
        
    - **이진 탐색 변형 (lower/upper bound 등)**
        - **원리**: 이진 탐색을 변형하여 특정 값이 들어갈 수 있는 최솟값 (lower bound) 또는 최댓값 (upper bound)을 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1)
        
        ```c
        int lowerBound(int arr[], int n, int target) {
            int left = 0, right = n;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] < target) {
                    left = mid + 1;  // target보다 작은 값은 left로
                } else {
                    right = mid;  // target보다 크거나 같은 값은 right로
                }
            }
            return left;  // 타겟 값을 넣을 수 있는 위치
        }
        ```
        
- **고급 탐색 알고리즘**
    - **이진 검색 트리 (Binary Search Tree) 기반 탐색**
        - **원리**: 이진 트리 구조에서 각 노드는 왼쪽 자식은 자신보다 작은 값, 오른쪽 자식은 자신보다 큰 값을 가진다. 이를 이용해 효율적으로 탐색한다.
        - **시간 복잡도**: O(log n) (평균적으로), O(n) (최악, 트리가 한 줄로 될 경우)
        - **공간 복잡도**: O(n)
        - **특징**: 트리 구조로 동적 데이터를 관리하며 삽입, 삭제가 효율적이다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->left = node->right = NULL;
            return node;
        }
        
        struct Node* insert(struct Node* root, int data) {
            if (root == NULL) return newNode(data);
            
            if (data < root->data) {
                root->left = insert(root->left, data);  // 왼쪽 서브트리에 삽입
            } else {
                root->right = insert(root->right, data);  // 오른쪽 서브트리에 삽입
            }
            return root;
        }
        
        struct Node* search(struct Node* root, int target) {
            if (root == NULL || root->data == target) return root;
            if (target < root->data) return search(root->left, target);  // 왼쪽 서브트리 탐색
            return search(root->right, target);  // 오른쪽 서브트리 탐색
        }
        ```
        
    - **해시 기반 탐색 (Hash-based Search)**
        - **원리**: 해시 테이블을 사용하여 데이터를 키 값으로 매핑하고, 해당 키에 대해 빠르게 데이터를 찾는다.
        - **시간 복잡도**: O(1) (평균적으로)
        - **공간 복잡도**: O(n)
        - **특징**: 해시 충돌이 발생할 수 있으며, 빠른 탐색 속도를 제공한다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define TABLE_SIZE 10
        
        struct HashNode {
            int key;
            int value;
            struct HashNode* next;
        };
        
        struct HashTable {
            struct HashNode* table[TABLE_SIZE];
        };
        
        int hash(int key) {
            return key % TABLE_SIZE;
        }
        
        void insert(struct HashTable* ht, int key, int value) {
            int index = hash(key);
            struct HashNode* newNode = (struct HashNode*)malloc(sizeof(struct HashNode));
            newNode->key = key;
            newNode->value = value;
            newNode->next = ht->table[index];
            ht->table[index] = newNode;
        }
        
        struct HashNode* search(struct HashTable* ht, int key) {
            int index = hash(key);
            struct HashNode* node = ht->table[index];
            while (node != NULL) {
                if (node->key == key) return node;
                node = node->next;
            }
            return NULL;
        }
        ```
        
    - **트라이 (Trie) 기반 검색**
        - **원리**: 문자열을 트리 구조로 저장하고, 접두사 검색이 효율적이다. 주로 문자열 검색에 사용된다.
        - **시간 복잡도**: O(m) (m은 검색할 문자열의 길이)
        - **공간 복잡도**: O(n * m) (n은 문자열 개수, m은 문자열 길이)
        - **특징**: 빠른 접두사 검색이 가능하며, 자동완성 및 사전 검색에 유용하다.
    
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        #define ALPHABET_SIZE 26
        
        struct TrieNode {
            struct TrieNode* children[ALPHABET_SIZE];
            int isEndOfWord;
        };
        
        struct TrieNode* getNode(void) {
            struct TrieNode* node = (struct TrieNode*)malloc(sizeof(struct TrieNode));
            node->isEndOfWord = 0;
            for (int i = 0; i < ALPHABET_SIZE; i++) {
                node->children[i] = NULL;
            }
            return node;
        }
        
        void insert(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    node->children[index] = getNode();
                }
                node = node->children[index];
            }
            node->isEndOfWord = 1;
        }
        
        int search(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    return 0;
                }
                node = node->children[index];
            }
            return (node != NULL && node->isEndOfWord);
        }
        ```

## 재귀 및 분할 정복

- **재귀 (Recursion)**
    - **기본 재귀 및 기저 조건**
        - **원리**: 함수가 자기 자신을 호출하는 방식이다. 재귀는 항상 **기저 조건(base case)**이 있어야 하며, 이 조건을 만족하면 재귀 호출을 종료한다.
        - **시간 복잡도**: 문제에 따라 다르며, 재귀 깊이에 비례하는 경우가 많다.
        - **공간 복잡도**: 재귀 호출 시 스택에 쌓이는 호출 기록에 따라 공간 복잡도가 늘어난다.
        - **특징**: 문제를 분할하여 해결하는 방식이며, 재귀 깊이가 지나치게 깊어지면 스택 오버플로우가 발생할 수 있다.
        - **예시)** 팩토리얼 계산
        
        ```c
        int factorial(int n) {
            if (n <= 1)  // 기저 조건
                return 1;
            else
                return n * factorial(n - 1);  // 재귀 호출
        }
        ```
        
    - **꼬리 재귀 (Tail Recursion)**
        - **원리**: 재귀 함수 호출이 함수의 마지막 작업일 때, 꼬리 재귀라고 한다. 꼬리 재귀는 컴파일러 최적화가 가능하며, 스택 사용을 최소화할 수 있다.
        - **특징**: 꼬리 재귀는 재귀 호출이 끝난 후 추가적인 계산이 없기 때문에 스택 공간을 절약할 수 있다.
        - **예시)** 꼬리 재귀로 구현한 팩토리얼
        
        ```c
        int tailFactorial(int n, int accumulator) {
            if (n <= 1)  // 기저 조건
                return accumulator;
            else
                return tailFactorial(n - 1, n * accumulator);  // 재귀 호출
        }
        ```
        
    - **재귀와 반복 비교**
        - **재귀:** 문제를 더 자연스럽게 해결할 수 있지만, **반복**에 비해 성능이 떨어질 수 있다. 재귀는 함수 호출에 따른 오버헤드가 있으며, 깊이가 깊어지면 스택 공간을 많이 사용한다.
        - **반복:** 성능 면에서 효율적일 수 있지만, 때로는 복잡한 문제를 해결하기 위해 여러 가지 상태 변수를 추적해야 하므로 코드가 복잡해질 수 있다.
- **분할 정복 (Divide and Conquer)**
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누어 각각을 정렬한 후, 두 개의 정렬된 배열을 합치는 방식이다. 재귀적으로 배열을 나누며, 나누어진 배열을 병합한다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n) (배열을 임시로 저장하는 공간 필요)
        - **특징**: 안정적인 정렬 알고리즘이며, 최악의 경우에도 O(n log n)으로 성능이 일정하다.
        
        ```c
        void merge(int arr[], int left, int mid, int right) {
            int n1 = mid - left + 1;
            int n2 = right - mid;
            
            int leftArr[n1], rightArr[n2];
            
            for (int i = 0; i < n1; i++)
                leftArr[i] = arr[left + i];
            for (int i = 0; i < n2; i++)
                rightArr[i] = arr[mid + 1 + i];
            
            int i = 0, j = 0, k = left;
            while (i < n1 && j < n2) {
                if (leftArr[i] <= rightArr[j]) {
                    arr[k] = leftArr[i];
                    i++;
                } else {
                    arr[k] = rightArr[j];
                    j++;
                }
                k++;
            }
            
            while (i < n1) {
                arr[k] = leftArr[i];
                i++;
                k++;
            }
            
            while (j < n2) {
                arr[k] = rightArr[j];
                j++;
                k++;
            }
        }
        
        void mergeSort(int arr[], int left, int right) {
            if (left < right) {
                int mid = left + (right - left) / 2;
                mergeSort(arr, left, mid);
                mergeSort(arr, mid + 1, right);
                merge(arr, left, mid, right);
            }
        }
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 배열을 기준 값(pivot)을 중심으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치하며, 각 부분 배열을 재귀적으로 정렬한다.
        - **시간 복잡도**: O(n log n) (평균), O(n²) (최악)
        - **공간 복잡도**: O(log n) (최대 깊이)
        - **특징**: 평균적으로 매우 빠른 정렬 알고리즘이며, 대부분의 경우 O(n log n)으로 동작한다. 그러나 최악의 경우 O(n²)이 될 수 있다.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            
            for (int j = low; j <= high - 1; j++) {
                if (arr[j] <= pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                
                quickSort(arr, low, pi - 1);  // 왼쪽 부분 정렬
                quickSort(arr, pi + 1, high);  // 오른쪽 부분 정렬
            }
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누어 값을 찾는 방법이다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀), O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 매우 빠른 탐색을 제공한다.
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) return mid;
            else if (arr[mid] > target) return binarySearch(arr, left, mid - 1, target);
            else return binarySearch(arr, mid + 1, right, target);
        }
        ```
        
- **백트래킹 (Backtracking)**
    - **N-Queens**
        - **원리**: N개의 퀸을 N×N 체스판에 배치하는 문제로, 퀸이 서로 공격하지 않도록 배치해야 한다.
        - **시간 복잡도**: O(N!)
        - **공간 복잡도**: O(N)
        - **특징**: 백트래킹을 사용하여 가능한 모든 배치 방법을 탐색하며 해결한다.
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 4
        
        bool isSafe(int board[N][N], int row, int col) {
            // 동일한 열에 퀸이 있는지 확인
            for (int i = 0; i < row; i++) {
                if (board[i][col] == 1) return false;
            }
            
            // 왼쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
                if (board[i][j] == 1) return false;
            }
            
            // 오른쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j < N; i--, j++) {
                if (board[i][j] == 1) return false;
            }
            
            return true;
        }
        
        bool solveNQueens(int board[N][N], int row) {
            if (row >= N) return true;
            
            for (int i = 0; i < N; i++) {
                if (isSafe(board, row, i)) {
                    board[row][i] = 1;
                    if (solveNQueens(board, row + 1)) return true;
                    board[row][i] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printSolution(int board[N][N]) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%d ", board[i][j]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int board[N][N] = {0};
            
            if (solveNQueens(board, 0)) {
                printSolution(board);
            } else {
                printf("Solution does not exist\n");
            }
            
            return 0;
        }
        ```
        
    - **Sudoku Solver**
        - **원리**: 스도쿠 퍼즐을 해결하는 문제로, 각 칸에 1부터 9까지 숫자를 채우되, 가로, 세로, 3x3 박스에 동일한 숫자가 두 번 이상 나타나지 않도록 한다.
        - **시간 복잡도**: O(9^(n*n)) (전체 가능한 숫자 배치의 수)
        - **공간 복잡도**: O(n*n) (퍼즐의 크기)
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 9
        
        // 9x9 스도쿠 판에서 (row, col)에 숫자 num을 넣을 수 있는지 확인
        bool isSafe(int grid[N][N], int row, int col, int num) {
            // 같은 행, 열에 num이 있는지 확인
            for (int x = 0; x < 9; x++) {
                if (grid[row][x] == num || grid[x][col] == num) {
                    return false;
                }
            }
            
            // 3x3 박스에 num이 있는지 확인
            int startRow = row - row % 3, startCol = col - col % 3;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] == num) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 스도쿠 해결 함수
        bool solveSudoku(int grid[N][N]) {
            int row, col;
            bool isEmpty = true;
            
            for (row = 0; row < N; row++) {
                for (col = 0; col < N; col++) {
                    if (grid[row][col] == 0) {
                        isEmpty = false;
                        break;
                    }
                }
                if (!isEmpty) break;
            }
            
            if (isEmpty) return true;  // 모든 칸이 채워지면 해결됨
            
            for (int num = 1; num <= 9; num++) {
                if (isSafe(grid, row, col, num)) {
                    grid[row][col] = num;
                    
                    if (solveSudoku(grid)) return true;
                    
                    grid[row][col] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printGrid(int grid[N][N]) {
            for (int r = 0; r < N; r++) {
                for (int d = 0; d < N; d++) {
                    printf("%d ", grid[r][d]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int grid[N][N] = {
                {5, 3, 0, 0, 7, 0, 0, 0, 0},
                {6, 0, 0, 1, 9, 5, 0, 0, 0},
                {0, 9, 8, 0, 0, 0, 0, 6, 0},
                {8, 0, 0, 0, 6, 0, 0, 0, 3},
                {4, 0, 0, 8, 0, 3, 0, 0, 1},
                {7, 0, 0, 0, 2, 0, 0, 0, 6},
                {0, 6, 0, 0, 0, 0, 2, 8, 0},
                {0, 0, 0, 4, 1, 9, 0, 0, 5},
                {0, 0, 0, 0, 8, 0, 0, 7, 9}
            };
            
            if (solveSudoku(grid)) {
                printGrid(grid);
            } else {
                printf("No solution exists\n");
            }
            
            return 0;
        }
        ```
