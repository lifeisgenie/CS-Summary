# 알고리즘

## 정렬 (Sorting)

데이터를 특정 기준에 따라 순서대로 배치하는 과정이다. 

- **기본 정렬 알고리즘**
    - **버블 정렬 (Bubble Sort)**
        - **원리**: 인접한 두 요소를 비교하여 필요에 따라 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (이미 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 간단하지만 효율성이 낮아 실제 사용은 드물다.
        - **사용 예시**: 작은 데이터셋에서 빠르게 정렬을 확인하고자 할 때 유용하다. 예를 들어, 데이터가 이미 거의 정렬되어 있는 경우에 사용될 수 있다. 실제 사용에서는 성능 문제로 거의 사용되지 않는다.
        
        ```c
        void bubbleSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        // Swap arr[j] and arr[j+1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
        ```
        
    - **선택 정렬 (Selection Sort)**
        - **원리**: 배열에서 가장 작은(또는 큰) 요소를 선택해 정렬되지 않은 부분의 맨 앞 요소와 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선/평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 비교 횟수가 많지만 교환 횟수는 적다.
        - **사용 예시**: 작은 데이터셋에서 비교 횟수를 최소화하고자 할 때 사용된다. 예를 들어, 메모리 사용이 제한된 환경에서 최소한의 교환으로 정렬하고자 할 때 활용된다.
        
        ```c
        void selectionSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                int minIdx = i;
                // arr[i+1..n-1]에서 최소값의 인덱스를 찾음
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                // arr[i]와 arr[minIdx]를 교환
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        ```
        
    - **삽입 정렬 (Insertion Sort)**
        - **원리**: 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (거의 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 작은 데이터셋에 효과적이며 안정 정렬이다.
        - **사용 예시**: 데이터가 거의 정렬되어 있을 때 빠르게 처리할 수 있다. 예를 들어, 동적으로 정렬되는 리스트에서 새로운 데이터를 추가할 때 유용하다.
        
        ```c
        void insertionSort(int arr[], int n) {
            for (int i = 1; i < n; i++) {
                int key = arr[i];
                int j = i - 1;
        
                // arr[0..i-1]의 요소 중 key보다 큰 요소들을 현재 위치보다 한 칸 뒤로 이동
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key; // key를 올바른 위치에 삽입
            }
        }
        ```
        
- **고급 정렬 알고리즘**
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누고 정렬한 후 병합.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **특징**: 안정 정렬, 재귀적 구현.
        - **사용 예시**: 데이터의 크기가 크고, 안정적인 정렬이 필요할 때 사용된다. 예를 들어, 대규모 데이터 처리, 파일 정렬, 외부 정렬 등에서 사용된다. 또한, 분할 정복 방식을 사용하기 때문에 복잡한 정렬 문제에도 적합하다.
        
        ```c
        void merge(int arr[], int l, int m, int r) {
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (int i = 0; i < n1; i++) L[i] = arr[l + i];
            for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
        
            int i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) arr[k++] = L[i++];
                else arr[k++] = R[j++];
            }
            while (i < n1) arr[k++] = L[i++];
            while (j < n2) arr[k++] = R[j++];
        }
        
        void mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }
        
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
        - **시간 복잡도**:
            - 최선/평균: O(n log n)
            - 최악: O(n²)
        - **공간 복잡도**: O(log n) (재귀 호출 스택)
        - **특징**: 빠르지만 불안정 정렬.
        - **사용 예시**: 빠른 정렬이 필요한 경우에 사용된다. 예를 들어, 일반적인 데이터 정렬에서 퀵 정렬은 평균적으로 매우 빠르게 동작하기 때문에 대부분의 상황에서 사용된다.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        
        ```
        
    - **힙 정렬 (Heap Sort)**
        - **원리**: 힙 자료구조를 사용해 최대값 또는 최소값을 반복적으로 추출.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(1)
        - **특징**: 불안정 정렬.
        - **사용 예시**: 최댓값이나 최솟값을 반복적으로 추출해야 하는 상황에서 유용하다. 예를 들어, 우선순위 큐(우선순위가 높은 데이터를 먼저 꺼내는 자료구조) 구현에 자주 사용된다.
        
        ```c
        void heapify(int arr[], int n, int i) {
            int largest = i;  // 루트
            int left = 2 * i + 1;  // 왼쪽 자식
            int right = 2 * i + 2; // 오른쪽 자식
        
            // 왼쪽 자식이 루트보다 크다면
            if (left < n && arr[left] > arr[largest])
                largest = left;
        
            // 오른쪽 자식이 현재 가장 큰 노드보다 크다면
            if (right < n && arr[right] > arr[largest])
                largest = right;
        
            // 가장 큰 노드가 루트가 아니라면 교환
            if (largest != i) {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
        
                // 재귀적으로 힙을 정렬
                heapify(arr, n, largest);
            }
        }
        
        void heapSort(int arr[], int n) {
            // 힙 생성
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
        
            // 하나씩 요소를 힙에서 제거
            for (int i = n - 1; i > 0; i--) {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
        
                // 힙 정렬
                heapify(arr, i, 0);
            }
        }
        
        ```
        
    - **기수 정렬 (Radix Sort)**
        - **원리**: 자릿수를 기준으로 데이터를 분류하고 병합하여 정렬한다.
        - **시간 복잡도**: O(nk) (n은 데이터 개수, k는 자릿수 길이)
        - **공간 복잡도**: O(n + k)
        - **특징**: 데이터의 크기나 자릿수가 제한적일 때 유용하며 안정 정렬이다.
        - **사용 예시**: 정수나 자릿수가 제한된 데이터에 적합하다. 예를 들어, 전화번호, 우편번호 등의 숫자 데이터를 빠르게 정렬할 때 사용된다.
        
        ```c
        int getMax(int arr[], int n) {
            int max = arr[0];
            for (int i = 1; i < n; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }
        
        void countingSort(int arr[], int n, int exp) {
            int output[n];
            int count[10] = {0};
        
            // 카운트 배열 생성
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;
        
            // 누적 합
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 작성
            for (int i = n - 1; i >= 0; i--) {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }
        
            // 원래 배열 업데이트
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        
        void radixSort(int arr[], int n) {
            int max = getMax(arr, n);
        
            // 각 자릿수에 대해 정렬
            for (int exp = 1; max / exp > 0; exp *= 10)
                countingSort(arr, n, exp);
        }
        ```
        
    - **계수 정렬 (Counting Sort)**
        - **원리**: 데이터의 범위를 기준으로 개수를 세고 누적하여 정렬한다.
        - **시간 복잡도**: O(n + k) (n은 데이터 개수, k는 최대값)
        - **공간 복잡도**: O(n + k)
        - **특징**: 정수 데이터에 적합하며 매우 효율적이지만 범위가 클 경우 메모리 사용량이 증가한다.
        - **사용 예시**: 정수 범위가 제한적인 데이터에서 매우 효율적으로 정렬할 수 있다. 예를 들어, 학생들의 시험 점수, 정수로 표현된 데이터를 다룰 때 매우 효과적이다.
        
        ```c
        void countingSort(int arr[], int n) {
            int output[n];
            int max = arr[0];
        
            for (int i = 1; i < n; i++)
                if (arr[i] > max) max = arr[i];
        
            int count[max + 1];
            memset(count, 0, sizeof(count));
        
            // 카운트 배열 작성
            for (int i = 0; i < n; i++)
                count[arr[i]]++;
        
            // 누적 합
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 생성
            for (int i = n - 1; i >= 0; i--) {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }
        
            // 원래 배열에 결과 복사
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        ```
        
    - **셸 정렬 (Shell Sort)**
        - **원리**: 삽입 정렬을 일반화하여 일정 간격의 요소들만 비교하고 정렬하며, 점차 간격을 좁히는 방식이다.
        - **시간 복잡도**: 평균적으로 O(n log n) ~ O(n²) (간격 선택에 따라 다름)
        - **공간 복잡도**: O(1)
        - **특징**: 비교적 간단한 구현으로 중간 규모의 데이터셋에서 유용하지만 불안정 정렬이다.
        - **사용 예시**: 중간 크기의 데이터셋에서 유용하다. 예를 들어, 데이터가 많이 정렬되어 있지 않지만 상대적으로 빠르게 정렬하고자 할 때 사용된다. 또한, 배열이 크게 분할되어 있지 않거나, 데이터 간 간격이 유리한 경우에 효과적이다.
        
        ```c
        void shellSort(int arr[], int n) {
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i];
                    int j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```
        
- **비교 기반 정렬과 비비교 기반 정렬의 차이**
    - **비교 기반 정렬**:
        - 데이터 간의 크기를 비교하며 정렬한다.
        - 병합 정렬, 퀵 정렬, 힙 정렬 등이 포함된다.
        - 일반적으로 범용적으로 사용 가능하며 시간 복잡도는 O(n log n) 이상이다.
        - **사용 예시**: 대부분의 경우에 사용된다. 예를 들어, 파일 정렬, 데이터베이스의 인덱스 정렬 등에서 사용된다.
    - **비비교 기반 정렬**:
        - 데이터 간의 크기를 비교하지 않고, 키나 자릿수 등 특성을 활용해 정렬한다.
        - 기수 정렬, 계수 정렬 등이 포함된다.
        - 데이터 특성에 따라 효율적이며 O(n)까지의 시간 복잡도를 가지지만 제한적이다.
        - **사용 예시**: 정수 범위가 정해져 있거나 자릿수 기준으로 정렬을 할 때 사용된다. 예를 들어, 전화번호, 주민등록번호 등을 정렬할 때 유용하다.
     
## 탐색 (Search)

- **기본 탐색 알고리즘**
    - **선형 탐색 (Linear Search)**
        - **원리**: 배열의 첫 번째 요소부터 끝까지 하나씩 확인하여 원하는 값을 찾는다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(1)
        - **특징**: 데이터가 정렬되지 않았을 때 사용할 수 있으며, 최악의 경우 모든 요소를 확인해야 한다.
        - **사용 예시**: 작은 데이터셋에서 사용되며, 데이터가 정렬되지 않았거나, 간단히 특정 값을 찾고자 할 때 유용하다. 예를 들어, 연락처 목록에서 특정 번호를 찾을 때 사용될 수 있다.
        
        ```c
        int linearSearch(int arr[], int n, int target) {
            for (int i = 0; i < n; i++) {
                if (arr[i] == target) {
                    return i;  // 타겟 값을 찾았으면 인덱스 반환
                }
            }
            return -1;  // 찾지 못한 경우
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누며 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀) / O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 데이터가 크면 매우 효율적이다.
        - **사용 예시**: 정렬된 데이터에서 빠르게 원하는 값을 찾고자 할 때 사용된다. 예를 들어, 대규모 데이터베이스에서 특정 항목을 찾을 때 유용하다.
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;  // 찾지 못한 경우
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;  // 타겟 값을 찾았으면 인덱스 반환
            } else if (arr[mid] > target) {
                return binarySearch(arr, left, mid - 1, target);  // 왼쪽 부분 탐색
            } else {
                return binarySearch(arr, mid + 1, right, target);  // 오른쪽 부분 탐색
            }
        }
        ```
        
    - **이진 탐색 변형 (lower/upper bound 등)**
        - **원리**: 이진 탐색을 변형하여 특정 값이 들어갈 수 있는 최솟값 (lower bound) 또는 최댓값 (upper bound)을 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1)
        - **사용 예시**: 정렬된 데이터에서 특정 범위나 위치를 찾을 때 유용하다. 예를 들어, 주식 거래에서 특정 가격을 찾을 때나, 정렬된 날짜 리스트에서 특정 날짜 이후의 항목을 찾을 때 사용된다.
        
        ```c
        int lowerBound(int arr[], int n, int target) {
            int left = 0, right = n;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] < target) {
                    left = mid + 1;  // target보다 작은 값은 left로
                } else {
                    right = mid;  // target보다 크거나 같은 값은 right로
                }
            }
            return left;  // 타겟 값을 넣을 수 있는 위치
        }
        ```
        
- **고급 탐색 알고리즘**
    - **이진 검색 트리 (Binary Search Tree) 기반 탐색**
        - **원리**: 이진 트리 구조에서 각 노드는 왼쪽 자식은 자신보다 작은 값, 오른쪽 자식은 자신보다 큰 값을 가진다. 이를 이용해 효율적으로 탐색한다.
        - **시간 복잡도**: O(log n) (평균적으로), O(n) (최악, 트리가 한 줄로 될 경우)
        - **공간 복잡도**: O(n)
        - **특징**: 트리 구조로 동적 데이터를 관리하며 삽입, 삭제가 효율적이다.
        - **사용 예시**: 동적으로 삽입과 삭제가 자주 발생하는 데이터에 대해 효율적으로 탐색하고자 할 때 사용된다. 예를 들어, 검색 엔진의 색인 시스템에서 키워드를 빠르게 찾기 위해 사용될 수 있다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->left = node->right = NULL;
            return node;
        }
        
        struct Node* insert(struct Node* root, int data) {
            if (root == NULL) return newNode(data);
            
            if (data < root->data) {
                root->left = insert(root->left, data);  // 왼쪽 서브트리에 삽입
            } else {
                root->right = insert(root->right, data);  // 오른쪽 서브트리에 삽입
            }
            return root;
        }
        
        struct Node* search(struct Node* root, int target) {
            if (root == NULL || root->data == target) return root;
            if (target < root->data) return search(root->left, target);  // 왼쪽 서브트리 탐색
            return search(root->right, target);  // 오른쪽 서브트리 탐색
        }
        ```
        
    - **해시 기반 탐색 (Hash-based Search)**
        - **원리**: 해시 테이블을 사용하여 데이터를 키 값으로 매핑하고, 해당 키에 대해 빠르게 데이터를 찾는다.
        - **시간 복잡도**: O(1) (평균적으로)
        - **공간 복잡도**: O(n)
        - **특징**: 해시 충돌이 발생할 수 있으며, 빠른 탐색 속도를 제공한다.
        - **사용 예시**: 해시 테이블을 활용해 빠른 조회를 필요로 하는 시스템에서 사용된다. 예를 들어, 사용자 정보, 세션 관리, 단어 검색 등에서 효과적이다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define TABLE_SIZE 10
        
        struct HashNode {
            int key;
            int value;
            struct HashNode* next;
        };
        
        struct HashTable {
            struct HashNode* table[TABLE_SIZE];
        };
        
        int hash(int key) {
            return key % TABLE_SIZE;
        }
        
        void insert(struct HashTable* ht, int key, int value) {
            int index = hash(key);
            struct HashNode* newNode = (struct HashNode*)malloc(sizeof(struct HashNode));
            newNode->key = key;
            newNode->value = value;
            newNode->next = ht->table[index];
            ht->table[index] = newNode;
        }
        
        struct HashNode* search(struct HashTable* ht, int key) {
            int index = hash(key);
            struct HashNode* node = ht->table[index];
            while (node != NULL) {
                if (node->key == key) return node;
                node = node->next;
            }
            return NULL;
        }
        ```
        
    - **트라이 (Trie) 기반 검색**
        - **원리**: 문자열을 트리 구조로 저장하고, 접두사 검색이 효율적이다. 주로 문자열 검색에 사용된다.
        - **시간 복잡도**: O(m) (m은 검색할 문자열의 길이)
        - **공간 복잡도**: O(n * m) (n은 문자열 개수, m은 문자열 길이)
        - **특징**: 빠른 접두사 검색이 가능하며, 자동완성 및 사전 검색에 유용하다.
        - **사용 예시**: 문자열을 빠르게 검색하고자 할 때 사용된다. 예를 들어, 자동 완성 시스템, 사전 검색, 접두사 검색 등이 있다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        #define ALPHABET_SIZE 26
        
        struct TrieNode {
            struct TrieNode* children[ALPHABET_SIZE];
            int isEndOfWord;
        };
        
        struct TrieNode* getNode(void) {
            struct TrieNode* node = (struct TrieNode*)malloc(sizeof(struct TrieNode));
            node->isEndOfWord = 0;
            for (int i = 0; i < ALPHABET_SIZE; i++) {
                node->children[i] = NULL;
            }
            return node;
        }
        
        void insert(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    node->children[index] = getNode();
                }
                node = node->children[index];
            }
            node->isEndOfWord = 1;
        }
        
        int search(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    return 0;
                }
                node = node->children[index];
            }
            return (node != NULL && node->isEndOfWord);
        }
        ```

## 재귀 및 분할 정복

- **재귀 (Recursion):** 함수가 자기 자신을 호출하는 방식이다. 문제를 동일한 형태로 분할하여 반복적으로 해결하는 방식이다.
    - **기본 재귀 및 기저 조건**
        - **원리**: 함수가 자기 자신을 호출하는 방식이다. 재귀는 항상 **기저 조건(base case)**이 있어야 하며, 이 조건을 만족하면 재귀 호출을 종료한다.
        - **시간 복잡도**: 문제에 따라 다르며, 재귀 깊이에 비례하는 경우가 많다.
        - **공간 복잡도**: 재귀 호출 시 스택에 쌓이는 호출 기록에 따라 공간 복잡도가 늘어난다.
        - **특징**: 문제를 분할하여 해결하는 방식이며, 재귀 깊이가 지나치게 깊어지면 스택 오버플로우가 발생할 수 있다.
        - **사용 예시)** 팩토리얼 계산, 피보나치 수열, 트리 탐색, 분할 정복 알고리즘 등에서 사용된다.
            - 예를 들어, 트리 순회에서 트리 구조를 탐색할 때 (예: 이진 트리의 전위/중위/후위 순회) 재귀를 자주 사용하거나 분할 정복 알고리즘에서 문제를 작은 하위 문제로 나누어 해결할 때, 재귀를 많이 사용한다.
        - **예시)** 팩토리얼 계산
        
        ```c
        int factorial(int n) {
            if (n <= 1)  // 기저 조건
                return 1;
            else
                return n * factorial(n - 1);  // 재귀 호출
        }
        ```
        
    - **꼬리 재귀 (Tail Recursion)**
        - **원리**: 재귀 함수 호출이 함수의 마지막 작업일 때, 꼬리 재귀라고 한다. 꼬리 재귀는 컴파일러 최적화가 가능하며, 스택 사용을 최소화할 수 있다.
        - **특징**: 꼬리 재귀는 재귀 호출이 끝난 후 추가적인 계산이 없기 때문에 스택 공간을 절약할 수 있다.
        - **예시)** 꼬리 재귀로 구현한 팩토리얼
        
        ```c
        int tailFactorial(int n, int accumulator) {
            if (n <= 1)  // 기저 조건
                return accumulator;
            else
                return tailFactorial(n - 1, n * accumulator);  // 재귀 호출
        }
        ```
        
    - **재귀와 반복 비교**
        - **재귀:** 문제를 더 자연스럽게 해결할 수 있지만, **반복**에 비해 성능이 떨어질 수 있다. 재귀는 함수 호출에 따른 오버헤드가 있으며, 깊이가 깊어지면 스택 공간을 많이 사용한다.
        - **반복:** 성능 면에서 효율적일 수 있지만, 때로는 복잡한 문제를 해결하기 위해 여러 가지 상태 변수를 추적해야 하므로 코드가 복잡해질 수 있다.
- **분할 정복 (Divide and Conquer):** 분할 정복은 큰 문제를 작은 문제로 나눈 후, 각각을 해결한 뒤 그 결과를 합치는 방식이다. 이 알고리즘은 재귀적 성격을 가질 때가 많다.
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누어 각각을 정렬한 후, 두 개의 정렬된 배열을 합치는 방식이다. 재귀적으로 배열을 나누며, 나누어진 배열을 병합한다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n) (배열을 임시로 저장하는 공간 필요)
        - **특징**: 안정적인 정렬 알고리즘이며, 최악의 경우에도 O(n log n)으로 성능이 일정하다.
        - **사용 예시)** 데이터 정렬이 필요한 경우 (예: 대규모 데이터의 정렬, 텍스트 파일 정렬 등)
        
        ```c
        void merge(int arr[], int left, int mid, int right) {
            int n1 = mid - left + 1;
            int n2 = right - mid;
            
            int leftArr[n1], rightArr[n2];
            
            for (int i = 0; i < n1; i++)
                leftArr[i] = arr[left + i];
            for (int i = 0; i < n2; i++)
                rightArr[i] = arr[mid + 1 + i];
            
            int i = 0, j = 0, k = left;
            while (i < n1 && j < n2) {
                if (leftArr[i] <= rightArr[j]) {
                    arr[k] = leftArr[i];
                    i++;
                } else {
                    arr[k] = rightArr[j];
                    j++;
                }
                k++;
            }
            
            while (i < n1) {
                arr[k] = leftArr[i];
                i++;
                k++;
            }
            
            while (j < n2) {
                arr[k] = rightArr[j];
                j++;
                k++;
            }
        }
        
        void mergeSort(int arr[], int left, int right) {
            if (left < right) {
                int mid = left + (right - left) / 2;
                mergeSort(arr, left, mid);
                mergeSort(arr, mid + 1, right);
                merge(arr, left, mid, right);
            }
        }
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 배열을 기준 값(pivot)을 중심으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치하며, 각 부분 배열을 재귀적으로 정렬한다.
        - **시간 복잡도**: O(n log n) (평균), O(n²) (최악)
        - **공간 복잡도**: O(log n) (최대 깊이)
        - **특징**: 평균적으로 매우 빠른 정렬 알고리즘이며, 대부분의 경우 O(n log n)으로 동작한다. 그러나 최악의 경우 O(n²)이 될 수 있다.
        - **사용 예시)** 대체로 평균적인 경우 매우 빠른 성능을 보이며, 예를 들어, 데이터베이스에서 인덱스 생성을 위한 정렬에 사용된다.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            
            for (int j = low; j <= high - 1; j++) {
                if (arr[j] <= pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                
                quickSort(arr, low, pi - 1);  // 왼쪽 부분 정렬
                quickSort(arr, pi + 1, high);  // 오른쪽 부분 정렬
            }
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누어 값을 찾는 방법이다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀), O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 매우 빠른 탐색을 제공한다.
        - **사용 예시)** 정렬된 배열에서 특정 값을 찾는 경우 (예: 정렬된 숫자 배열에서 값이 있는지 확인하거나 데이터베이스에서 특정 레코드를 빠르게 찾는 경우)
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) return mid;
            else if (arr[mid] > target) return binarySearch(arr, left, mid - 1, target);
            else return binarySearch(arr, mid + 1, right, target);
        }
        ```
        
- **백트래킹 (Backtracking):** 가능한 모든 해를 탐색하며, 유망하지 않은 경로는 더 이상 탐색하지 않고 되돌아가는 방식이다. 이는 문제를 풀어가면서 중간에 잘못된 방향으로 간다면 그 부분을 되돌려 다른 경로를 시도한다.
    - **N-Queens**
        - **원리**: N개의 퀸을 N×N 체스판에 배치하는 문제로, 퀸이 서로 공격하지 않도록 배치해야 한다.
        - **시간 복잡도**: O(N!)
        - **공간 복잡도**: O(N)
        - **특징**: 백트래킹을 사용하여 가능한 모든 배치 방법을 탐색하며 해결한다.
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 4
        
        bool isSafe(int board[N][N], int row, int col) {
            // 동일한 열에 퀸이 있는지 확인
            for (int i = 0; i < row; i++) {
                if (board[i][col] == 1) return false;
            }
            
            // 왼쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
                if (board[i][j] == 1) return false;
            }
            
            // 오른쪽 대각선 확인
            for (int i = row, j = col; i >= 0 && j < N; i--, j++) {
                if (board[i][j] == 1) return false;
            }
            
            return true;
        }
        
        bool solveNQueens(int board[N][N], int row) {
            if (row >= N) return true;
            
            for (int i = 0; i < N; i++) {
                if (isSafe(board, row, i)) {
                    board[row][i] = 1;
                    if (solveNQueens(board, row + 1)) return true;
                    board[row][i] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printSolution(int board[N][N]) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%d ", board[i][j]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int board[N][N] = {0};
            
            if (solveNQueens(board, 0)) {
                printSolution(board);
            } else {
                printf("Solution does not exist\n");
            }
            
            return 0;
        }
        ```
        
    - **Sudoku Solver**
        - **원리**: 스도쿠 퍼즐을 해결하는 문제로, 각 칸에 1부터 9까지 숫자를 채우되, 가로, 세로, 3x3 박스에 동일한 숫자가 두 번 이상 나타나지 않도록 한다.
        - **시간 복잡도**: O(9^(n*n)) (전체 가능한 숫자 배치의 수)
        - **공간 복잡도**: O(n*n) (퍼즐의 크기)
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define N 9
        
        // 9x9 스도쿠 판에서 (row, col)에 숫자 num을 넣을 수 있는지 확인
        bool isSafe(int grid[N][N], int row, int col, int num) {
            // 같은 행, 열에 num이 있는지 확인
            for (int x = 0; x < 9; x++) {
                if (grid[row][x] == num || grid[x][col] == num) {
                    return false;
                }
            }
            
            // 3x3 박스에 num이 있는지 확인
            int startRow = row - row % 3, startCol = col - col % 3;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] == num) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 스도쿠 해결 함수
        bool solveSudoku(int grid[N][N]) {
            int row, col;
            bool isEmpty = true;
            
            for (row = 0; row < N; row++) {
                for (col = 0; col < N; col++) {
                    if (grid[row][col] == 0) {
                        isEmpty = false;
                        break;
                    }
                }
                if (!isEmpty) break;
            }
            
            if (isEmpty) return true;  // 모든 칸이 채워지면 해결됨
            
            for (int num = 1; num <= 9; num++) {
                if (isSafe(grid, row, col, num)) {
                    grid[row][col] = num;
                    
                    if (solveSudoku(grid)) return true;
                    
                    grid[row][col] = 0;  // 백트래킹
                }
            }
            
            return false;
        }
        
        void printGrid(int grid[N][N]) {
            for (int r = 0; r < N; r++) {
                for (int d = 0; d < N; d++) {
                    printf("%d ", grid[r][d]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int grid[N][N] = {
                {5, 3, 0, 0, 7, 0, 0, 0, 0},
                {6, 0, 0, 1, 9, 5, 0, 0, 0},
                {0, 9, 8, 0, 0, 0, 0, 6, 0},
                {8, 0, 0, 0, 6, 0, 0, 0, 3},
                {4, 0, 0, 8, 0, 3, 0, 0, 1},
                {7, 0, 0, 0, 2, 0, 0, 0, 6},
                {0, 6, 0, 0, 0, 0, 2, 8, 0},
                {0, 0, 0, 4, 1, 9, 0, 0, 5},
                {0, 0, 0, 0, 8, 0, 0, 7, 9}
            };
            
            if (solveSudoku(grid)) {
                printGrid(grid);
            } else {
                printf("No solution exists\n");
            }
            
            return 0;
        }
        ```

## 그리디 알고리즘 (Greedy Algorithm)

- **개념 및 특징**
    - **개념:**
        - 그리디 알고리즘은 **매 단계에서 최적이라고 생각되는 선택을 하는 알고리즘**이다. 이를 통해 전체 문제의 최적해를 구하는 방법이지만, 모든 경우에 최적해를 보장하지는 않는다. 그리디 알고리즘은 **문제의 구조**와 **문제의 특성**에 따라 최적해를 도출할 수 있는 경우에만 사용한다.
    - **특징:**
        - **단계적 최적 선택**: 매 단계에서 최적의 선택을 하며, 이를 통해 전체 최적해를 구하는 방식이다.
        - **지역 최적화**: 각 단계에서 가장 좋은 선택을 하되, 전체적인 최적 해를 보장하지 않음.
        - **구현이 간단**: 복잡한 DP(동적 계획법) 방식에 비해 구현이 간단하고 직관적이다.
        - **결과가 항상 최적이 아닐 수 있다**: 모든 문제에 대해 항상 최적해를 보장하지 않는다.
- **대표 문제**
    - **동전 거슬러 주기 (Coin Change Problem)**
        - **문제**: 특정 금액을 최소 개수의 동전으로 거슬러 주는 문제이다. 주어진 동전의 종류를 사용하여 금액을 만들 때, 최소 동전 개수를 구하는 것이 목표이다.
        - **그리디 접근**: 가장 큰 동전부터 차례대로 거슬러 주면, 최소 개수의 동전을 사용할 수 있다.
        - **시간 복잡도**: O(n) (각 동전 종류에 대해 한번씩 탐색)
        - **공간 복잡도**: O(1)
        
        ```c
        #include <stdio.h>
        
        int coinChange(int coins[], int n, int amount) {
            int count = 0;
            for (int i = 0; i < n; i++) {
                while (amount >= coins[i]) {
                    amount -= coins[i];
                    count++;
                }
            }
            return count;
        }
        
        int main() {
            int coins[] = {25, 10, 5, 1};
            int n = sizeof(coins) / sizeof(coins[0]);
            int amount = 63;
            printf("Minimum coins required: %d\n", coinChange(coins, n, amount));
            return 0;
        }
        
        // 출력 예시:
        Minimum coins required: 6
        ```
        
    - **활동 선택 문제 (Activity Selection Problem)**
        - **문제**: 여러 활동이 주어지고, 각 활동은 시작 시간과 종료 시간을 가진다. 활동들이 겹치지 않게 최대한 많이 선택할 때, 선택할 수 있는 활동의 최대 개수를 구하는 문제이다.
        - **그리디 접근**: 종료 시간이 가장 빠른 활동을 선택하고, 그 후에 겹치지 않는 활동들을 선택하는 방식이다.
        - **시간 복잡도**: O(n log n) (정렬에 걸리는 시간)
        - **공간 복잡도**: O(1)
        
        ```c
        #include <stdio.h>
        #include <algorithm>
        
        struct Activity {
            int start, end;
        };
        
        bool compare(Activity a, Activity b) {
            return a.end < b.end;
        }
        
        int maxActivities(Activity arr[], int n) {
            std::sort(arr, arr + n, compare);
            int count = 1, lastEnd = arr[0].end;
            for (int i = 1; i < n; i++) {
                if (arr[i].start >= lastEnd) {
                    count++;
                    lastEnd = arr[i].end;
                }
            }
            return count;
        }
        
        int main() {
            Activity arr[] = {{1, 3}, {2, 5}, {4, 7}, {6, 8}};
            int n = sizeof(arr) / sizeof(arr[0]);
            printf("Maximum number of activities: %d\n", maxActivities(arr, n));
            return 0;
        }
        
        // 출력 예시:
        Maximum number of activities: 3
        ```
        
    - **최소 신장 트리 (MST)**
        - **문제**: 가중치가 부여된 연결 그래프에서 모든 정점을 포함하면서 가중치의 합이 최소가 되는 트리를 찾는 문제이다.
        - **그리디 알고리즘**을 통해 해결할 수 있으며, 대표적으로 **크루스칼 알고리즘**과 **프림 알고리즘**이 있다.
            - **크루스칼 알고리즘**
                - **원리**: 간선들을 가중치가 작은 순서대로 정렬한 후, 사이클을 만들지 않도록 간선을 추가한다.
                - **시간 복잡도**: O(E log E) (간선의 수 E에 대해 정렬이 필요함)
                - **공간 복잡도**: O(E + V)
                - **사용 예시)** 통신 네트워크 구축, 도로 네트워크 설계
                
                ```c
                #include <stdio.h>
                #include <algorithm>
                
                struct Edge {
                    int u, v, weight;
                };
                
                bool compare(Edge e1, Edge e2) {
                    return e1.weight < e2.weight;
                }
                
                int find(int parent[], int i) {
                    if (parent[i] == i)
                        return i;
                    return find(parent, parent[i]);
                }
                
                void unionSets(int parent[], int rank[], int x, int y) {
                    int rootX = find(parent, x);
                    int rootY = find(parent, y);
                
                    if (rootX != rootY) {
                        if (rank[rootX] > rank[rootY])
                            parent[rootY] = rootX;
                        else if (rank[rootX] < rank[rootY])
                            parent[rootX] = rootY;
                        else {
                            parent[rootY] = rootX;
                            rank[rootX]++;
                        }
                    }
                }
                
                int kruskal(Edge edges[], int V, int E) {
                    int parent[V], rank[V], mstWeight = 0;
                    for (int i = 0; i < V; i++) {
                        parent[i] = i;
                        rank[i] = 0;
                    }
                
                    std::sort(edges, edges + E, compare); // 간선 정렬
                
                    for (int i = 0; i < E; i++) {
                        int u = edges[i].u;
                        int v = edges[i].v;
                
                        if (find(parent, u) != find(parent, v)) {
                            unionSets(parent, rank, u, v);
                            mstWeight += edges[i].weight;
                        }
                    }
                    return mstWeight;
                }
                
                int main() {
                    Edge edges[] = {
                        {0, 1, 10}, {0, 2, 6}, {0, 3, 5}, {1, 3, 15}, {2, 3, 4}
                    };
                    int V = 4; // 정점 개수
                    int E = 5; // 간선 개수
                    printf("Minimum spanning tree weight: %d\n", kruskal(edges, V, E));
                    return 0;
                }
                
                // 출력 예시:
                Minimum spanning tree weight: 19
                ```
                
            - **프림 알고리즘**
                - **원리**: 임의의 정점에서 시작해, 그 정점과 연결된 간선들 중 가장 작은 가중치의 간선을 선택해 트리를 확장해 나간다.
                - **시간 복잡도**: O(E log V) (우선순위 큐를 사용하는 경우)
                - **공간 복잡도**: O(V)
                - **사용 예시)** 전력망 설계, 통신망 연결
                
                ```c
                #include <stdio.h>
                #include <limits.h>
                
                #define V 5 // 정점의 개수
                
                int minKey(int key[], bool mstSet[]) {
                    int min = INT_MAX, min_index;
                    for (int v = 0; v < V; v++) {
                        if (!mstSet[v] && key[v] < min) {
                            min = key[v];
                            min_index = v;
                        }
                    }
                    return min_index;
                }
                
                void prim(int graph[V][V]) {
                    int parent[V], key[V];
                    bool mstSet[V];
                
                    for (int i = 0; i < V; i++) {
                        key[i] = INT_MAX;
                        mstSet[i] = false;
                    }
                    key[0] = 0;
                    parent[0] = -1;
                
                    for (int count = 0; count < V - 1; count++) {
                        int u = minKey(key, mstSet);
                        mstSet[u] = true;
                
                        for (int v = 0; v < V; v++) {
                            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                                parent[v] = u;
                                key[v] = graph[u][v];
                            }
                        }
                    }
                
                    printf("Edge \tWeight\n");
                    for (int i = 1; i < V; i++) {
                        printf("%d - %d \t%d\n", parent[i], i, graph[i][parent[i]]);
                    }
                }
                
                int main() {
                    int graph[V][V] = {
                        {0, 2, 0, 6, 0},
                        {2, 0, 3, 8, 5},
                        {0, 3, 0, 0, 7},
                        {6, 8, 0, 0, 9},
                        {0, 5, 7, 9, 0}
                    };
                    prim(graph);
                    return 0;
                }
                
                // 출력 예시:
                Edge    Weight
                0 - 1    2
                0 - 3    6
                1 - 2    3
                1 - 4    5
                ```
                
    - **허프만 코딩 (Huffman Coding)**
        - **문제**: 주어진 문자들의 빈도수를 기반으로 각 문자를 효율적인 이진 코드로 압축하는 문제이다. 빈도가 높은 문자는 짧은 코드, 빈도가 낮은 문자는 긴 코드를 할당하여 데이터의 압축을 최적화한다.
        - **그리디 접근**: 빈도수가 낮은 두 문자를 결합하여 새로운 노드를 만들고, 이를 반복적으로 진행한다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 파일 압축, 문자열 압축
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        struct Node {
            char data;
            int freq;
            struct Node *left, *right;
        };
        
        struct MinHeap {
            int size;
            int capacity;
            struct Node** array;
        };
        
        struct Node* newNode(char data, int freq) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->freq = freq;
            node->left = node->right = NULL;
            return node;
        }
        
        struct MinHeap* createMinHeap(int capacity) {
            struct MinHeap* minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));
            minHeap->size = 0;
            minHeap->capacity = capacity;
            minHeap->array = (struct Node**)malloc(minHeap->capacity * sizeof(struct Node*));
            return minHeap;
        }
        
        void swapNode(struct Node** a, struct Node** b) {
            struct Node* temp = *a;
            *a = *b;
            *b = temp;
        }
        
        void minHeapify(struct MinHeap* minHeap, int idx) {
            int smallest = idx;
            int left = 2 * idx + 1;
            int right = 2 * idx + 2;
        
            if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)
                smallest = left;
        
            if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)
                smallest = right;
        
            if (smallest != idx) {
                swapNode(&minHeap->array[smallest], &minHeap->array[idx]);
                minHeapify(minHeap, smallest);
            }
        }
        
        void buildMinHeap(struct MinHeap* minHeap) {
            int n = minHeap->size - 1;
            for (int i = (n - 1) / 2; i >= 0; i--)
                minHeapify(minHeap, i);
        }
        
        struct Node* extractMin(struct MinHeap* minHeap) {
            struct Node* temp = minHeap->array[0];
            minHeap->array[0] = minHeap->array[minHeap->size - 1];
            --minHeap->size;
            minHeapify(minHeap, 0);
            return temp;
        }
        
        void insertMinHeap(struct MinHeap* minHeap, struct Node* node) {
            ++minHeap->size;
            int i = minHeap->size - 1;
            while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {
                minHeap->array[i] = minHeap->array[(i - 1) / 2];
                i = (i - 1) / 2;
            }
            minHeap->array[i] = node;
        }
        
        void printHuffmanCodes(struct Node* root, int arr[], int top) {
            if (root->left) {
                arr[top] = 0;
                printHuffmanCodes(root->left, arr, top + 1);
            }
        
            if (root->right) {
                arr[top] = 1;
                printHuffmanCodes(root->right, arr, top + 1);
            }
        
            if (!root->left && !root->right) {
                printf("%c: ", root->data);
                for (int i = 0; i < top; i++)
                    printf("%d", arr[i]);
                printf("\n");
            }
        }
        
        void HuffmanCodes(char data[], int freq[], int size) {
            struct Node *left, *right, *top;
        
            struct MinHeap* minHeap = createMinHeap(size);
        
            for (int i = 0; i < size; ++i)
                insertMinHeap(minHeap, newNode(data[i], freq[i]));
        
            while (minHeap->size != 1) {
                left = extractMin(minHeap);
                right = extractMin(minHeap);
        
                top = newNode('$', left->freq + right->freq);
                top->left = left;
                top->right = right;
        
                insertMinHeap(minHeap, top);
            }
        
            int arr[100], topIndex = 0;
            printHuffmanCodes(minHeap->array[0], arr, topIndex);
        }
        
        int main() {
            char data[] = {'A', 'B', 'C', 'D', 'E', 'F'};
            int freq[] = {5, 9, 12, 13, 16, 45};
            int size = sizeof(data) / sizeof(data[0]);
        
            HuffmanCodes(data, freq, size);
            return 0;
        }
        
        // 출력 예시:
        F: 0
        E: 10
        D: 110
        C: 1110
        B: 11110
        A: 11111
        ```

## 동적 계획법 (Dynamic Programming)

동적 계획법(DP)은 **문제를 더 작은 하위 문제들로 분할하고, 각 하위 문제의 해답을 저장하여 재사용하는 알고리즘 설계 기법**이다. 이는 **중복되는 하위 문제**가 있는 문제에 매우 유용하다.

- **기본 개념**
    - **메모이제이션 (Memoization)**
        - **탑다운 접근법**이라고도 하며, **재귀적**으로 문제를 해결한다.
        - 계산된 하위 문제의 결과를 **배열이나 해시맵에 저장**하여, 동일한 하위 문제를 다시 계산하지 않도록 한다.
        - 기본적으로 **재귀 함수**로 문제를 풀되, 이미 계산된 값은 다시 계산하지 않고 메모리에서 꺼내어 사용한다.
    - **타뷸레이션 (Tabulation)**
        - **바텀업 접근법**이라고도 하며, 작은 문제부터 차근차근 해결해 나가는 방식이다.
        - 모든 하위 문제를 **미리 계산하여 테이블에 저장**하고, 최종적으로 문제의 해답을 구한다.
        - 반복문을 사용하여 문제를 해결하며, 메모이제이션과 달리 재귀적인 호출 없이 테이블을 완성해 나간다.
- **대표 문제**
    - **피보나치 수열**
        - 피보나치 수열을 구하는 문제로, 0과 1을 시작으로 그 뒤의 값은 앞의 두 수를 더한 값으로 정의된다. **재귀적 정의**에 따라 계산을 하되, 계산된 값을 저장하여 중복 계산을 피하는 방식으로 해결한다.
        - **사용 예시)** 컴퓨터 과학의 이론적 연구, 게임 개발
        - **예시)** **메모이제이션**을 사용한 풀이:
            
            ```c
            #include <stdio.h>
            
            int fibonacci(int n, int memo[]) {
                if (n <= 1) {
                    return n;
                }
                if (memo[n] != -1) {
                    return memo[n];
                }
                memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
                return memo[n];
            }
            
            int main() {
                int n = 10;
                int memo[n + 1];
                for (int i = 0; i <= n; i++) {
                    memo[i] = -1;  // 초기값 설정 (계산되지 않은 값은 -1)
                }
                printf("Fibonacci(%d) = %d\n", n, fibonacci(n, memo));
                return 0;
            }
            ```
            
            - **시간 복잡도**: O(n)
            - **공간 복잡도**: O(n)
        - **예시)** **타뷸레이션**을 사용한 풀이:
            
            ```c
            #include <stdio.h>
            
            int fibonacci(int n) {
                if (n <= 1) {
                    return n;
                }
                int table[n + 1];
                table[0] = 0;
                table[1] = 1;
                for (int i = 2; i <= n; i++) {
                    table[i] = table[i - 1] + table[i - 2];
                }
                return table[n];
            }
            
            int main() {
                int n = 10;
                printf("Fibonacci(%d) = %d\n", n, fibonacci(n));
                return 0;
            }
            ```
            
            - **시간 복잡도**: O(n)
            - **공간 복잡도**: O(n)
    - **배낭 문제 (Knapsack Problem)**
        - 주어진 물건들 중 일부를 선택하여 배낭에 담을 때, 담을 수 있는 무게의 제한을 넘지 않으면서 물건들의 가치를 최대화하는 문제이다.
        - **시간 복잡도**: O(nW)
        - **공간 복잡도**: O(nW)
        - **사용 예시)** 물류 및 운송 분야, 포트폴리오 최적화
        
        ```c
        #include <stdio.h>
        
        int knapsack(int weights[], int values[], int n, int W) {
            int dp[n + 1][W + 1];
            
            for (int i = 0; i <= n; i++) {
                for (int w = 0; w <= W; w++) {
                    if (i == 0 || w == 0) {
                        dp[i][w] = 0;
                    } else if (weights[i - 1] <= w) {
                        dp[i][w] = (dp[i - 1][w] > dp[i - 1][w - weights[i - 1]] + values[i - 1]) ? dp[i - 1][w] : dp[i - 1][w - weights[i - 1]] + values[i - 1];
                    } else {
                        dp[i][w] = dp[i - 1][w];
                    }
                }
            }
            return dp[n][W];
        }
        
        int main() {
            int weights[] = {1, 2, 3};
            int values[] = {60, 100, 120};
            int W = 5;
            int n = sizeof(weights) / sizeof(weights[0]);
            printf("Maximum value in knapsack = %d\n", knapsack(weights, values, n, W));
            return 0;
        }
        ```
        
    - **최장 공통 부분 수열 (LCS)**
        - 두 문자열 X와 Y의 최장 공통 부분 수열을 구하는 문제이다.
        - **시간 복잡도**: O(mn)
        - **공간 복잡도**: O(mn)
        - **사용 예시)** DNA 서열 분석, 텍스트 비교 도구
        
        ```c
        #include <stdio.h>
        #include <string.h>
        
        int lcs(char *X, char *Y, int m, int n) {
            int dp[m + 1][n + 1];
        
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= n; j++) {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 0;
                    } else if (X[i - 1] == Y[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ? dp[i - 1][j] : dp[i][j - 1];
                    }
                }
            }
            return dp[m][n];
        }
        
        int main() {
            char X[] = "AGGTAB";
            char Y[] = "GXTXAYB";
            int m = strlen(X);
            int n = strlen(Y);
            printf("Length of LCS = %d\n", lcs(X, Y, m, n));
            return 0;
        }
        ```
        
    - **최장 증가 부분 수열 (LIS)**
        - 주어진 수열에서, 숫자가 증가하는 부분 수열 중 가장 긴 길이를 찾는 문제이다.
        - **시간 복잡도**: O(n^2)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 주식 가격 분석, 컴퓨터 비전
        
        ```c
        #include <stdio.h>
        
        int lis(int arr[], int n) {
            int dp[n];
            for (int i = 0; i < n; i++) {
                dp[i] = 1;
            }
            
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (arr[i] > arr[j]) {
                        dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;
                    }
                }
            }
        
            int max = dp[0];
            for (int i = 1; i < n; i++) {
                if (dp[i] > max) {
                    max = dp[i];
                }
            }
            return max;
        }
        
        int main() {
            int arr[] = {10, 22, 9, 33, 21, 50, 41, 60, 80};
            int n = sizeof(arr) / sizeof(arr[0]);
            printf("Length of LIS = %d\n", lis(arr, n));
            return 0;
        }
        ```
        
    - **최단 경로 알고리즘 (예: Floyd-Warshall)**
        - 모든 쌍의 최단 경로를 구하는 알고리즘
        - **시간 복잡도**: O(n^3)
        - **공간 복잡도**: O(n^2)
        - **사용 예시)** 도로망 설계, 네트워크 최적화
        
        ```c
        #include <stdio.h>
        #define INF 99999
        
        void floydWarshall(int graph[][4], int V) {
            int dist[V][V];
        
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    dist[i][j] = graph[i][j];
                }
            }
        
            for (int k = 0; k < V; k++) {
                for (int i = 0; i < V; i++) {
                    for (int j = 0; j < V; j++) {
                        if (dist[i][j] > dist[i][k] + dist[k][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
        
            printf("Shortest distance matrix:\n");
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    if (dist[i][j] == INF) {
                        printf("INF ");
                    } else {
                        printf("%d ", dist[i][j]);
                    }
                }
                printf("\n");
            }
        }
        
        int main() {
            int graph[4][4] = {{0, 3, INF, INF},
                               {2, 0, INF, INF},
                               {INF, 7, 0, 1},
                               {6, INF, INF, 0}};
            int V = 4;
            floydWarshall(graph, V);
            return 0;
        }
        ```

## **그래프 알고리즘**

그래프는 **정점(Vertex)**과 **간선(Edge)**으로 이루어진 자료구조로, 다양한 문제를 해결할 수 있는 핵심적인 알고리즘들이 존재한다. 

- **탐색**
    - **깊이 우선 탐색 (DFS)**
        - **시작 정점에서부터 깊이 탐색**을 진행하는 알고리즘이다. 재귀적으로 혹은 스택을 이용해 구현할 수 있다.
        - **시간 복잡도**: O(V + E) (V는 정점의 수, E는 간선의 수)
        - **공간 복잡도**: O(V) (방문 체크 배열, 스택을 이용한 재귀 호출)
        - **사용 예시)** 웹 크롤러, 미로 탐색, 트리 탐색
        - **예시 (스택 이용)**:
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        
        #define MAX 100
        int graph[MAX][MAX]; // 인접 행렬
        bool visited[MAX];
        
        void dfs(int v, int n) {
            visited[v] = true;
            printf("%d ", v);
            
            for (int i = 0; i < n; i++) {
                if (graph[v][i] && !visited[i]) {
                    dfs(i, n);
                }
            }
        }
        
        int main() {
            int n = 5;
            for (int i = 0; i < n; i++) visited[i] = false;
            graph[0][1] = graph[1][2] = graph[2][3] = graph[3][4] = 1;
            
            printf("DFS Traversal: ");
            dfs(0, n);  // 0번 정점에서 시작
            return 0;
        }
        ```
        
    - **너비 우선 탐색 (BFS)**
        - **시작 정점에서부터 인접한 정점들을 차례로 탐색**하며, 큐를 사용해 구현한다.
        - **시간 복잡도**: O(V + E)
        - **공간 복잡도**: O(V)
        - **사용 예시)** 최단 경로를 찾거나, 소셜 네트워크에서 사람 간의 관계를 탐색
        
        ```c
        #include <stdio.h>
        #include <stdbool.h>
        #include <queue>
        
        #define MAX 100
        int graph[MAX][MAX];
        bool visited[MAX];
        
        void bfs(int start, int n) {
            std::queue<int> q;
            visited[start] = true;
            q.push(start);
            
            while (!q.empty()) {
                int v = q.front();
                q.pop();
                printf("%d ", v);
                
                for (int i = 0; i < n; i++) {
                    if (graph[v][i] && !visited[i]) {
                        visited[i] = true;
                        q.push(i);
                    }
                }
            }
        }
        
        int main() {
            int n = 5;
            for (int i = 0; i < n; i++) visited[i] = false;
            graph[0][1] = graph[1][2] = graph[2][3] = graph[3][4] = 1;
            
            printf("BFS Traversal: ");
            bfs(0, n);  // 0번 정점에서 시작
            return 0;
        }
        ```
        
- **최단 경로**
    - **다익스트라 알고리즘 (Dijkstra's Algorithm)**
        - **음의 간선이 없는 그래프**에서 최단 경로를 구하는 알고리즘이다. 그리디 알고리즘을 사용하여 가장 짧은 경로를 우선적으로 탐색한다.
        - **시간 복잡도**: O(V^2) (배열을 사용할 경우) / O(E + V log V) (힙을 사용할 경우)
        - **공간 복잡도**: O(V)
        - **사용 예시)** GPS 네비게이션 시스템에서 현재 위치에서 목적지까지의 최단 경로
        
        ```c
        #include <stdio.h>
        #include <limits.h>
        
        #define MAX 100
        #define INF INT_MAX
        
        int graph[MAX][MAX];
        
        void dijkstra(int start, int n) {
            int dist[MAX];
            bool visited[MAX];
            
            for (int i = 0; i < n; i++) {
                dist[i] = INF;
                visited[i] = false;
            }
            dist[start] = 0;
            
            for (int i = 0; i < n - 1; i++) {
                int u = -1;
                for (int j = 0; j < n; j++) {
                    if (!visited[j] && (u == -1 || dist[j] < dist[u])) {
                        u = j;
                    }
                }
                visited[u] = true;
                for (int v = 0; v < n; v++) {
                    if (graph[u][v] && dist[u] + graph[u][v] < dist[v]) {
                        dist[v] = dist[u] + graph[u][v];
                    }
                }
            }
            
            for (int i = 0; i < n; i++) {
                printf("Distance from %d to %d is %d\n", start, i, dist[i]);
            }
        }
        
        int main() {
            int n = 5;
            graph[0][1] = graph[0][2] = 10;
            graph[1][2] = graph[1][3] = 5;
            graph[2][3] = 1;
            graph[3][4] = 2;
            
            dijkstra(0, n);  // 0번 정점에서 시작
            return 0;
        }
        
        ```
        
    - **벨만-포드 알고리즘 (Bellman-Ford Algorithm)**
        - **음의 간선**을 처리할 수 있는 알고리즘이다. 모든 간선에 대해 반복적으로 완화(Relaxation)를 진행하여 최단 경로를 구한다.
        - **시간 복잡도**: O(VE)
        - **공간 복잡도**: O(V)
        - **사용 예시)** 금융 거래 시스템에서 음의 간선을 포함하는 그래프를 처리
        
        ```c
        #include <stdio.h>
        #include <limits.h>
        
        #define MAX 100
        #define INF INT_MAX
        
        int graph[MAX][MAX];
        
        void bellmanFord(int start, int n) {
            int dist[MAX];
            for (int i = 0; i < n; i++) dist[i] = INF;
            dist[start] = 0;
            
            for (int i = 1; i < n - 1; i++) {
                for (int u = 0; u < n; u++) {
                    for (int v = 0; v < n; v++) {
                        if (graph[u][v] && dist[u] + graph[u][v] < dist[v]) {
                            dist[v] = dist[u] + graph[u][v];
                        }
                    }
                }
            }
            
            for (int i = 0; i < n; i++) {
                printf("Distance from %d to %d is %d\n", start, i, dist[i]);
            }
        }
        
        int main() {
            int n = 5;
            graph[0][1] = 10;
            graph[1][2] = 5;
            graph[2][3] = 1;
            graph[3][4] = 2;
            
            bellmanFord(0, n);  // 0번 정점에서 시작
            return 0;
        }
        
        ```
        
    - **플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)**
        - 모든 정점 간의 **최단 경로**를 구하는 알고리즘으로, 동적 계획법을 사용하여 문제를 해결한다.
        - **시간 복잡도**: O(V^3)
        - **공간 복잡도**: O(V^2)
        - **사용 예시)** 통신망에서 모든 노드 간의 최단 경로
        
        ```c
        #include <stdio.h>
        #include <limits.h>
        
        #define MAX 100
        #define INF INT_MAX
        
        int graph[MAX][MAX];
        
        void floydWarshall(int n) {
            int dist[MAX][MAX];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dist[i][j] = graph[i][j];
                }
            }
            
            for (int k = 0; k < n; k++) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    printf("%d ", dist[i][j]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int n = 4;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    graph[i][j] = INF;
                }
            }
            graph[0][1] = 5;
            graph[0][2] = 10;
            graph[1][2] = 3;
            graph[2][3] = 1;
            
            floydWarshall(n);
            return 0;
        }
        ```
        
- **최소 신장 트리 (Minimum Spanning Tree): 가중치가 있는 그래프**에서 모든 정점을 연결하는 간선의 집합 중에서 **가중치의 합이 최소**인 트리이다.
    - **크루스칼 알고리즘**
        - **간선들을 가중치가 작은 순서대로 선택**하면서 트리를 구성해가는 알고리즘이다. 이 과정에서 **사이클**을 방지하기 위해 **Union-Find** 자료구조를 사용한다.
        - **시간 복잡도**: O(E log E) (E는 간선의 수)
        - **공간 복잡도**: O(V + E) (V는 정점, E는 간선의 수)
        - **사용 예시)** 네트워크 설계에서 최소 비용의 연결
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define MAX 100
        #define INF 1000000
        
        typedef struct {
            int u, v, weight;
        } Edge;
        
        Edge edges[MAX];
        int parent[MAX], rank[MAX];
        
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        void union_sets(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
        
        int compare(const void *a, const void *b) {
            return ((Edge*)a)->weight - ((Edge*)b)->weight;
        }
        
        void kruskal(int n, int m) {
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
            
            qsort(edges, m, sizeof(Edge), compare);
            
            int mst_weight = 0;
            for (int i = 0; i < m; i++) {
                int u = edges[i].u;
                int v = edges[i].v;
                
                if (find(u) != find(v)) {
                    union_sets(u, v);
                    mst_weight += edges[i].weight;
                    printf("%d - %d\n", u, v);
                }
            }
            printf("MST Weight: %d\n", mst_weight);
        }
        
        int main() {
            int n = 4, m = 5;
            edges[0] = (Edge){0, 1, 10};
            edges[1] = (Edge){0, 2, 6};
            edges[2] = (Edge){0, 3, 5};
            edges[3] = (Edge){1, 3, 15};
            edges[4] = (Edge){2, 3, 4};
            
            kruskal(n, m);
            return 0;
        }
        ```
        
    - **프림 알고리즘**
        - **시작 정점에서부터 하나씩 인접한 간선들을 선택**해가며 최소 신장 트리를 구성한다. **우선순위 큐**(최소 힙)를 사용해 가장 작은 가중치를 가진 간선을 빠르게 선택할 수 있다.
        - **시간 복잡도**: O(V^2) (배열 사용 시) / O(E log V) (우선순위 큐 사용 시)
        - **공간 복잡도**: O(V^2) (인접 행렬 기준)
        - **사용 예시)** 전력망 설계에서 최소 비용으로 전력을 연결하는 트리 구성
        
        ```c
        #include <stdio.h>
        #include <limits.h>
        
        #define MAX 100
        #define INF INT_MAX
        
        int graph[MAX][MAX];
        int key[MAX], parent[MAX];
        bool mstSet[MAX];
        
        void prim(int n) {
            for (int i = 0; i < n; i++) {
                key[i] = INF;
                mstSet[i] = false;
            }
            key[0] = 0;
            parent[0] = -1;
        
            for (int count = 0; count < n - 1; count++) {
                int u = -1;
                for (int v = 0; v < n; v++) {
                    if (!mstSet[v] && (u == -1 || key[v] < key[u])) {
                        u = v;
                    }
                }
                mstSet[u] = true;
                
                for (int v = 0; v < n; v++) {
                    if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                        parent[v] = u;
                        key[v] = graph[u][v];
                    }
                }
            }
            
            for (int i = 1; i < n; i++) {
                printf("%d - %d\n", parent[i], i);
            }
        }
        
        int main() {
            int n = 5;
            graph[0][1] = 2; graph[0][3] = 6;
            graph[1][2] = 3; graph[2][3] = 8;
            graph[3][4] = 5; graph[1][4] = 7;
            
            prim(n);
            return 0;
        }
        
        ```
        
- **네트워크 플로우 (Network Flow): 그래프에서 유량을 최대로 흐르게 하는 문제이다.**
    - **에드몬드-카프 알고리즘 (Edmonds-Karp Algorithm)**
        - **BFS**를 사용하여 **잔여 용량이 있는 경로**를 찾아 유량을 증가시킨다.
        - **시간 복잡도**: O(V * E^2)
        - **공간 복잡도**: O(V * E)
        - **사용 예시)** 유량 네트워크에서 한 출발지에서 목적지로 가능한 최대로 흐를 수 있는 유량
    - **푸시-재명칭 알고리즘 (Push-relabel Algorithm)**
        - **각 정점에 대해 유량을 재조정하고, 레이블을 갱신**하며 최적화된 유량을 찾아낸다. 이 알고리즘은 Edmons-Karp보다 더 빠른 시간에 유량을 최적화할 수 있다.
        - **시간 복잡도**: O(V^2 * E)
        - **공간 복잡도**: O(V^2)
        - **사용 예시)** 대규모 네트워크에서 유량 최적화
- **위상 정렬 (Topological Sorting)**
    - **방향 그래프**에서 **모든 간선이 방향에 맞게 정점들이 정렬**되는 순서를 구하는 알고리즘이다.
    - **시간 복잡도**: O(V + E)
    - **공간 복잡도**: O(V + E)
    - **사용 예시)** 작업 스케줄링, 컴파일러 최적화, 의존성 해결
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX 100
    
    int graph[MAX][MAX], in_degree[MAX];
    int queue[MAX], front = 0, rear = 0;
    
    void topologicalSort(int n) {
        for (int i = 0; i < n; i++) {
            in_degree[i] = 0;
        }
        
        for (int u = 0; u < n; u++) {
            for (int v = 0; v < n; v++) {
                if (graph[u][v]) {
                    in_degree[v]++;
                }
            }
        }
        
        for (int i = 0; i < n; i++) {
            if (in_degree[i] == 0) {
                queue[rear++] = i;
            }
        }
        
        while (front < rear) {
            int u = queue[front++];
            printf("%d ", u);
            
            for (int v = 0; v < n; v++) {
                if (graph[u][v]) {
                    in_degree[v]--;
                    if (in_degree[v] == 0) {
                        queue[rear++] = v;
                    }
                }
            }
        }
    }
    
    int main() {
        int n = 6;
        graph[0][1] = graph[0][2] = 1;
        graph[1][3] = graph[1][4] = 1;
        graph[2][4] = 1;
        graph[3][5] = 1;
        graph[4][5] = 1;
        
        printf("Topological Sort: ");
        topologicalSort(n);
        return 0;
    }
    
    ```

## 문자열 알고리즘

주로 텍스트에서 특정 패턴을 찾거나 문자열을 효율적으로 처리하는데 사용된다.

- **문자열 검색**
    - **KMP 알고리즘 (Knuth-Morris-Pratt Algorithm)**
        - **목표**: 문자열 내에서 특정 패턴을 효율적으로 찾기 위한 알고리즘이다. KMP 알고리즘은 불필요한 비교를 줄이는 방식으로 **O(n + m)** 시간 복잡도를 달성한다.
        - **원리**: 패턴을 비교하면서 매칭되지 않은 경우, 이전에 비교한 정보를 활용하여 일치하는 부분을 건너뛰며 비교를 계속한다.
        - **시간 복잡도**: O(n + m), 여기서 n은 텍스트의 길이, m은 패턴의 길이.
        - **공간 복잡도**: O(m) (패턴에 대한 정보 저장)
        - **사용 예시)** 텍스트에서 특정 단어가 존재하는지 찾는 작업
        
        ```c
        #include <stdio.h>
        #include <string.h>
        
        void computeLPSArray(char *pattern, int m, int *lps) {
            int length = 0;  // 길이를 추적
            int i = 1;
            lps[0] = 0;  // 첫 번째 문자는 항상 0
        
            while (i < m) {
                if (pattern[i] == pattern[length]) {
                    length++;
                    lps[i] = length;
                    i++;
                } else {
                    if (length != 0) {
                        length = lps[length - 1];
                    } else {
                        lps[i] = 0;
                        i++;
                    }
                }
            }
        }
        
        void KMPSearch(char *text, char *pattern) {
            int n = strlen(text);
            int m = strlen(pattern);
            int lps[m];
        
            // 접미사 일치 배열 계산
            computeLPSArray(pattern, m, lps);
        
            int i = 0;  // 텍스트 인덱스
            int j = 0;  // 패턴 인덱스
        
            while (i < n) {
                if (pattern[j] == text[i]) {
                    i++;
                    j++;
                }
                if (j == m) {
                    printf("Pattern found at index %d\n", i - j);
                    j = lps[j - 1];
                } else if (i < n && pattern[j] != text[i]) {
                    if (j != 0) {
                        j = lps[j - 1];
                    } else {
                        i++;
                    }
                }
            }
        }
        
        int main() {
            char text[] = "ABABDABACDABABCABAB";
            char pattern[] = "ABABCABAB";
        
            KMPSearch(text, pattern);
        
            return 0;
        }
        
        // 출력 예시)
        Pattern found at index 10
        ```
        
    - **라빈-카프 알고리즘 (Rabin-Karp Algorithm)**
        - **목표**: 패턴을 찾기 위해 **해시 함수**를 사용하여 빠르게 문자열을 비교한다. 해시값을 이용한 비교로 불필요한 문자열 비교를 최소화한다.
        - **원리**: 패턴과 텍스트의 부분 문자열에 대해 해시값을 계산하여 비교한다. 해시값이 같을 경우에만 실제 문자열을 비교한다.
        - **시간 복잡도**: 평균 O(n + m), 최악의 경우 O(n * m) (해시 충돌이 발생할 경우).
        - **공간 복잡도**: O(1)
        - **사용 예시)** 문자열 내에서 여러 패턴을 한 번에 찾거나 대규모 데이터에서 빠른 검색이 필요할 때 사용된다.
        
        ```c
        #include <stdio.h>
        #include <string.h>
        
        #define d 256  // 아스키 문자 수
        #define q 101  // 소수
        
        // 해시 값을 계산하는 함수
        long long computeHash(char *str, int length) {
            long long hash = 0;
            for (int i = 0; i < length; i++) {
                hash = (hash * d + str[i]) % q;
            }
            return hash;
        }
        
        // 라빈-카프 알고리즘
        void rabinKarpSearch(char *text, char *pattern) {
            int n = strlen(text);
            int m = strlen(pattern);
            long long patternHash = computeHash(pattern, m);
            long long textHash = computeHash(text, m);
        
            long long h = 1;
            for (int i = 0; i < m - 1; i++) {
                h = (h * d) % q;
            }
        
            for (int i = 0; i <= n - m; i++) {
                if (patternHash == textHash) {
                    int j;
                    for (j = 0; j < m; j++) {
                        if (text[i + j] != pattern[j]) {
                            break;
                        }
                    }
                    if (j == m) {
                        printf("Pattern found at index %d\n", i);
                    }
                }
        
                if (i < n - m) {
                    textHash = (d * (textHash - text[i] * h) + text[i + m]) % q;
                    if (textHash < 0) {
                        textHash = (textHash + q);
                    }
                }
            }
        }
        
        int main() {
            char text[] = "ABABDABACDABABCABAB";
            char pattern[] = "ABABCABAB";
        
            rabinKarpSearch(text, pattern);
        
            return 0;
        }
        
        // 출력 예시)
        Pattern found at index 10
        ```
        
- **접미사 배열 및 트라이**
    - **접미사 배열 (Suffix Array)**
        - **목표**: 문자열의 모든 접미사를 정렬하여 배열로 나타내는 알고리즘이다. 접미사 배열을 이용하면 효율적인 문자열 검색, 접미사 트리 구성 등을 할 수 있다.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 문자열의 접미사 배열을 이용하여 패턴 검색, 문서에서 특정 키워드를 빠르게 검색
        
        ```c
        #include <stdio.h>
        #include <string.h>
        #include <stdlib.h>
        
        // 접미사 배열 생성 함수
        int compareSuffixes(const void *a, const void *b, void *str) {
            char *s = (char *)str;
            int i = *(int *)a;
            int j = *(int *)b;
        
            return strcmp(s + i, s + j);
        }
        
        void suffixArray(char *str) {
            int n = strlen(str);
            int suffixes[n];
        
            for (int i = 0; i < n; i++) {
                suffixes[i] = i;
            }
        
            qsort_r(suffixes, n, sizeof(int), compareSuffixes, str);
        
            printf("Suffix Array: ");
            for (int i = 0; i < n; i++) {
                printf("%d ", suffixes[i]);
            }
            printf("\n");
        }
        
        int main() {
            char str[] = "banana";
            suffixArray(str);
        
            return 0;
        }
        
        // 출력 예시:
        Suffix Array: 5 3 1 0 4 2
        ```
        
    - **접미사 트리 (Suffix Tree)**
        - **목표**: 문자열의 모든 접미사를 트리 형태로 표현한 자료구조이다. 접미사 트리는 문자열 검색, 회문 검사, 부분 문자열 검색 등에 유용하다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 접미사 트리는 문자열에서 부분 문자열을 빠르게 찾거나, 가장 긴 반복 부분 문자열을 찾을 때 유용하다.
        
        ```c
        #include <stdio.h>
        #include <string.h>
        #include <stdlib.h>
        
        #define ALPHABET_SIZE 256  // 아스키 문자 집합 크기
        
        // Trie 노드 구조체
        struct TrieNode {
            struct TrieNode *children[ALPHABET_SIZE];
            int suffixIndex;
        };
        
        // 새로운 Trie 노드 생성
        struct TrieNode* createNode() {
            struct TrieNode *newNode = (struct TrieNode*)malloc(sizeof(struct TrieNode));
            newNode->suffixIndex = -1;
            for (int i = 0; i < ALPHABET_SIZE; i++) {
                newNode->children[i] = NULL;
            }
            return newNode;
        }
        
        // 접미사 트리 생성 함수
        void insertSuffix(struct TrieNode *root, char *suffix, int index) {
            struct TrieNode *currentNode = root;
            for (int i = 0; suffix[i] != '\0'; i++) {
                int charIndex = suffix[i];
                if (currentNode->children[charIndex] == NULL) {
                    currentNode->children[charIndex] = createNode();
                }
                currentNode = currentNode->children[charIndex];
            }
            currentNode->suffixIndex = index;
        }
        
        // 접미사 트리 생성
        void buildSuffixTree(char *str) {
            struct TrieNode *root = createNode();
            int n = strlen(str);
        
            for (int i = 0; i < n; i++) {
                insertSuffix(root, str + i, i);
            }
        
            // 트리 구조 출력 (접미사의 시작 인덱스)
            printf("Suffix Tree built for string: \"%s\"\n", str);
            printf("Suffixes with indices:\n");
            for (int i = 0; i < n; i++) {
                printf("Suffix starting at index %d: %s\n", i, str + i);
            }
        }
        
        int main() {
            char str[] = "banana";
            buildSuffixTree(str);
            return 0;
        }
        
        // 출력 예시:
        Suffix Tree built for string: "banana"
        Suffixes with indices:
        Suffix starting at index 0: banana
        Suffix starting at index 1: anana
        Suffix starting at index 2: nana
        Suffix starting at index 3: ana
        Suffix starting at index 4: na
        Suffix starting at index 5: a
        ```
        
- **롤링 해시 및 Z-알고리즘**
    - **롤링 해시 (Rolling Hash)**
        - **목표**: 문자열을 처리할 때, 이전 해시 값을 재사용하여 빠르게 해시 값을 계산하는 방법이다. 이를 통해 서브 문자열의 해시 값을 효율적으로 계산한다.
        - **사용 예시)** 긴 텍스트에서 여러 패턴을 빠르게 찾아야 할 때, 예를 들어 텍스트 분석 프로그램에서 패턴을 찾는 데 유용하다.
        
        ```c
        #include <stdio.h>
        #include <string.h>
        
        #define d 256  // 아스키 문자 집합 크기
        #define q 101  // 큰 소수
        
        // 롤링 해시 함수
        long long rollingHash(char *str, int m) {
            long long hash = 0;
            for (int i = 0; i < m; i++) {
                hash = (hash * d + str[i]) % q;
            }
            return hash;
        }
        
        // 롤링 해시를 사용한 문자열 검색
        void rollingHashSearch(char *text, char *pattern) {
            int n = strlen(text);
            int m = strlen(pattern);
            long long patternHash = rollingHash(pattern, m);
            long long textHash = rollingHash(text, m);
        
            long long h = 1;
            for (int i = 0; i < m - 1; i++) {
                h = (h * d) % q;
            }
        
            for (int i = 0; i <= n - m; i++) {
                if (patternHash == textHash) {
                    int j;
                    for (j = 0; j < m; j++) {
                        if (text[i + j] != pattern[j]) {
                            break;
                        }
                    }
                    if (j == m) {
                        printf("Pattern found at index %d\n", i);
                    }
                }
        
                if (i < n - m) {
                    textHash = (d * (textHash - text[i] * h) + text[i + m]) % q;
                    if (textHash < 0) {
                        textHash = (textHash + q);
                    }
                }
            }
        }
        
        int main() {
            char text[] = "ABABDABACDABABCABAB";
            char pattern[] = "ABABCABAB";
        
            rollingHashSearch(text, pattern);
        
            return 0;
        }
        
        // 출력 예시)
        Pattern found at index 10
        ```
        
    - **Z-알고리즘 (Z Algorithm)**
        - **목표**: 주어진 문자열에서 접두사로 나타나는 부분 문자열들을 빠르게 구하는 알고리즘이다. Z-알고리즘을 사용하면 패턴 매칭에서 효율적으로 서브 문자열을 찾아낼 수 있다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(n)
        - **사용 예시)** 텍스트에서 패턴을 찾는 데 사용된다. 예를 들어, DNA 서열 검색, 대규모 텍스트 검색 등에 유용하다.
        
        ```c
        #include <stdio.h>
        #include <string.h>
        
        // Z-알고리즘 구현
        void ZAlgorithm(char *str) {
            int n = strlen(str);
            int Z[n];
            Z[0] = n;
        
            int l = 0, r = 0;
            for (int i = 1; i < n; i++) {
                if (i <= r) {
                    Z[i] = (r - i + 1 < Z[i - l]) ? r - i + 1 : Z[i - l];
                }
        
                while (i + Z[i] < n && str[Z[i]] == str[i + Z[i]]) {
                    Z[i]++;
                }
        
                if (i + Z[i] - 1 > r) {
                    l = i;
                    r = i + Z[i] - 1;
                }
            }
        
            printf("Z-array: ");
            for (int i = 0; i < n; i++) {
                printf("%d ", Z[i]);
            }
            printf("\n");
        }
        
        int main() {
            char str[] = "abacaba";
            ZAlgorithm(str);
        
            return 0;
        }
        
        // 출력 예시:
        Z-array: 7 0 1 0 3 0 1
        ```
