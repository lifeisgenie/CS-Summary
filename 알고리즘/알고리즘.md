# 알고리즘

## 정렬 (Sorting)

데이터를 특정 기준에 따라 순서대로 배치하는 과정이다. 정렬은 알고리즘의 성능과 특성에 따라 다양하게 분류되며, 기술 면접에서도 자주 다루어지는 주제이다.

- **기본 정렬 알고리즘**
    - **버블 정렬 (Bubble Sort)**
        - **원리**: 인접한 두 요소를 비교하여 필요에 따라 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (이미 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 간단하지만 효율성이 낮아 실제 사용은 드물다.
        
        ```c
        void bubbleSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        // Swap arr[j] and arr[j+1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
        ```
        
    - **선택 정렬 (Selection Sort)**
        - **원리**: 배열에서 가장 작은(또는 큰) 요소를 선택해 정렬되지 않은 부분의 맨 앞 요소와 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선/평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 비교 횟수가 많지만 교환 횟수는 적다.
        
        ```c
        void selectionSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                int minIdx = i;
                // arr[i+1..n-1]에서 최소값의 인덱스를 찾음
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                // arr[i]와 arr[minIdx]를 교환
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        ```
        
    - **삽입 정렬 (Insertion Sort)**
        - **원리**: 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (거의 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 작은 데이터셋에 효과적이며 안정 정렬이다.
        
        ```c
        void insertionSort(int arr[], int n) {
            for (int i = 1; i < n; i++) {
                int key = arr[i];
                int j = i - 1;
        
                // arr[0..i-1]의 요소 중 key보다 큰 요소들을 현재 위치보다 한 칸 뒤로 이동
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key; // key를 올바른 위치에 삽입
            }
        }
        ```
        
- **고급 정렬 알고리즘**
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누고 정렬한 후 병합.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **특징**: 안정 정렬, 재귀적 구현.
        
        ```c
        void merge(int arr[], int l, int m, int r) {
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (int i = 0; i < n1; i++) L[i] = arr[l + i];
            for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
        
            int i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) arr[k++] = L[i++];
                else arr[k++] = R[j++];
            }
            while (i < n1) arr[k++] = L[i++];
            while (j < n2) arr[k++] = R[j++];
        }
        
        void mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }
        
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
        - **시간 복잡도**:
            - 최선/평균: O(n log n)
            - 최악: O(n²)
        - **공간 복잡도**: O(log n) (재귀 호출 스택)
        - **특징**: 빠르지만 불안정 정렬.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        
        ```
        
    - **힙 정렬 (Heap Sort)**
        - **원리**: 힙 자료구조를 사용해 최대값 또는 최소값을 반복적으로 추출.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(1)
        - **특징**: 불안정 정렬.
        
        ```c
        void heapify(int arr[], int n, int i) {
            int largest = i;  // 루트
            int left = 2 * i + 1;  // 왼쪽 자식
            int right = 2 * i + 2; // 오른쪽 자식
        
            // 왼쪽 자식이 루트보다 크다면
            if (left < n && arr[left] > arr[largest])
                largest = left;
        
            // 오른쪽 자식이 현재 가장 큰 노드보다 크다면
            if (right < n && arr[right] > arr[largest])
                largest = right;
        
            // 가장 큰 노드가 루트가 아니라면 교환
            if (largest != i) {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
        
                // 재귀적으로 힙을 정렬
                heapify(arr, n, largest);
            }
        }
        
        void heapSort(int arr[], int n) {
            // 힙 생성
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
        
            // 하나씩 요소를 힙에서 제거
            for (int i = n - 1; i > 0; i--) {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
        
                // 힙 정렬
                heapify(arr, i, 0);
            }
        }
        
        ```
        
    - **기수 정렬 (Radix Sort)**
        - **원리**: 자릿수를 기준으로 데이터를 분류하고 병합하여 정렬한다.
        - **시간 복잡도**: O(nk) (n은 데이터 개수, k는 자릿수 길이)
        - **공간 복잡도**: O(n + k)
        - **특징**: 데이터의 크기나 자릿수가 제한적일 때 유용하며 안정 정렬이다.
        
        ```c
        int getMax(int arr[], int n) {
            int max = arr[0];
            for (int i = 1; i < n; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }
        
        void countingSort(int arr[], int n, int exp) {
            int output[n];
            int count[10] = {0};
        
            // 카운트 배열 생성
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;
        
            // 누적 합
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 작성
            for (int i = n - 1; i >= 0; i--) {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }
        
            // 원래 배열 업데이트
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        
        void radixSort(int arr[], int n) {
            int max = getMax(arr, n);
        
            // 각 자릿수에 대해 정렬
            for (int exp = 1; max / exp > 0; exp *= 10)
                countingSort(arr, n, exp);
        }
        ```
        
    - **계수 정렬 (Counting Sort)**
        - **원리**: 데이터의 범위를 기준으로 개수를 세고 누적하여 정렬한다.
        - **시간 복잡도**: O(n + k) (n은 데이터 개수, k는 최대값)
        - **공간 복잡도**: O(n + k)
        - **특징**: 정수 데이터에 적합하며 매우 효율적이지만 범위가 클 경우 메모리 사용량이 증가한다.
        
        ```c
        void countingSort(int arr[], int n) {
            int output[n];
            int max = arr[0];
        
            for (int i = 1; i < n; i++)
                if (arr[i] > max) max = arr[i];
        
            int count[max + 1];
            memset(count, 0, sizeof(count));
        
            // 카운트 배열 작성
            for (int i = 0; i < n; i++)
                count[arr[i]]++;
        
            // 누적 합
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 생성
            for (int i = n - 1; i >= 0; i--) {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }
        
            // 원래 배열에 결과 복사
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        ```
        
    - **셸 정렬 (Shell Sort)**
        - **원리**: 삽입 정렬을 일반화하여 일정 간격의 요소들만 비교하고 정렬하며, 점차 간격을 좁히는 방식이다.
        - **시간 복잡도**: 평균적으로 O(n log n) ~ O(n²) (간격 선택에 따라 다름)
        - **공간 복잡도**: O(1)
        - **특징**: 비교적 간단한 구현으로 중간 규모의 데이터셋에서 유용하지만 불안정 정렬이다.
        
        ```c
        void shellSort(int arr[], int n) {
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i];
                    int j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```
        
- **비교 기반 정렬과 비비교 기반 정렬의 차이**
    - **비교 기반 정렬**:
        - 데이터 간의 크기를 비교하며 정렬한다.
        - 병합 정렬, 퀵 정렬, 힙 정렬 등이 포함된다.
        - 일반적으로 범용적으로 사용 가능하며 시간 복잡도는 O(n log n) 이상이다.
    - **비비교 기반 정렬**:
        - 데이터 간의 크기를 비교하지 않고, 키나 자릿수 등 특성을 활용해 정렬한다.
        - 기수 정렬, 계수 정렬 등이 포함된다.
        - 데이터 특성에 따라 효율적이며 O(n)까지의 시간 복잡도를 가지지만 제한적이다.
     
## 탐색 (Search)

- **기본 탐색 알고리즘**
    - **선형 탐색 (Linear Search)**
        - **원리**: 배열의 첫 번째 요소부터 끝까지 하나씩 확인하여 원하는 값을 찾는다.
        - **시간 복잡도**: O(n)
        - **공간 복잡도**: O(1)
        - **특징**: 데이터가 정렬되지 않았을 때 사용할 수 있으며, 최악의 경우 모든 요소를 확인해야 한다.
        
        ```c
        int linearSearch(int arr[], int n, int target) {
            for (int i = 0; i < n; i++) {
                if (arr[i] == target) {
                    return i;  // 타겟 값을 찾았으면 인덱스 반환
                }
            }
            return -1;  // 찾지 못한 경우
        }
        ```
        
    - **이진 탐색 (Binary Search)**
        - **원리**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누며 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1) (비재귀) / O(log n) (재귀)
        - **특징**: 배열이 정렬되어 있어야 하며, 데이터가 크면 매우 효율적이다.
        
        ```c
        int binarySearch(int arr[], int left, int right, int target) {
            if (left > right) return -1;  // 찾지 못한 경우
            
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;  // 타겟 값을 찾았으면 인덱스 반환
            } else if (arr[mid] > target) {
                return binarySearch(arr, left, mid - 1, target);  // 왼쪽 부분 탐색
            } else {
                return binarySearch(arr, mid + 1, right, target);  // 오른쪽 부분 탐색
            }
        }
        ```
        
    - **이진 탐색 변형 (lower/upper bound 등)**
        - **원리**: 이진 탐색을 변형하여 특정 값이 들어갈 수 있는 최솟값 (lower bound) 또는 최댓값 (upper bound)을 찾는다.
        - **시간 복잡도**: O(log n)
        - **공간 복잡도**: O(1)
        
        ```c
        int lowerBound(int arr[], int n, int target) {
            int left = 0, right = n;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] < target) {
                    left = mid + 1;  // target보다 작은 값은 left로
                } else {
                    right = mid;  // target보다 크거나 같은 값은 right로
                }
            }
            return left;  // 타겟 값을 넣을 수 있는 위치
        }
        ```
        
- **고급 탐색 알고리즘**
    - **이진 검색 트리 (Binary Search Tree) 기반 탐색**
        - **원리**: 이진 트리 구조에서 각 노드는 왼쪽 자식은 자신보다 작은 값, 오른쪽 자식은 자신보다 큰 값을 가진다. 이를 이용해 효율적으로 탐색한다.
        - **시간 복잡도**: O(log n) (평균적으로), O(n) (최악, 트리가 한 줄로 될 경우)
        - **공간 복잡도**: O(n)
        - **특징**: 트리 구조로 동적 데이터를 관리하며 삽입, 삭제가 효율적이다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->left = node->right = NULL;
            return node;
        }
        
        struct Node* insert(struct Node* root, int data) {
            if (root == NULL) return newNode(data);
            
            if (data < root->data) {
                root->left = insert(root->left, data);  // 왼쪽 서브트리에 삽입
            } else {
                root->right = insert(root->right, data);  // 오른쪽 서브트리에 삽입
            }
            return root;
        }
        
        struct Node* search(struct Node* root, int target) {
            if (root == NULL || root->data == target) return root;
            if (target < root->data) return search(root->left, target);  // 왼쪽 서브트리 탐색
            return search(root->right, target);  // 오른쪽 서브트리 탐색
        }
        ```
        
    - **해시 기반 탐색 (Hash-based Search)**
        - **원리**: 해시 테이블을 사용하여 데이터를 키 값으로 매핑하고, 해당 키에 대해 빠르게 데이터를 찾는다.
        - **시간 복잡도**: O(1) (평균적으로)
        - **공간 복잡도**: O(n)
        - **특징**: 해시 충돌이 발생할 수 있으며, 빠른 탐색 속도를 제공한다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define TABLE_SIZE 10
        
        struct HashNode {
            int key;
            int value;
            struct HashNode* next;
        };
        
        struct HashTable {
            struct HashNode* table[TABLE_SIZE];
        };
        
        int hash(int key) {
            return key % TABLE_SIZE;
        }
        
        void insert(struct HashTable* ht, int key, int value) {
            int index = hash(key);
            struct HashNode* newNode = (struct HashNode*)malloc(sizeof(struct HashNode));
            newNode->key = key;
            newNode->value = value;
            newNode->next = ht->table[index];
            ht->table[index] = newNode;
        }
        
        struct HashNode* search(struct HashTable* ht, int key) {
            int index = hash(key);
            struct HashNode* node = ht->table[index];
            while (node != NULL) {
                if (node->key == key) return node;
                node = node->next;
            }
            return NULL;
        }
        ```
        
    - **트라이 (Trie) 기반 검색**
        - **원리**: 문자열을 트리 구조로 저장하고, 접두사 검색이 효율적이다. 주로 문자열 검색에 사용된다.
        - **시간 복잡도**: O(m) (m은 검색할 문자열의 길이)
        - **공간 복잡도**: O(n * m) (n은 문자열 개수, m은 문자열 길이)
        - **특징**: 빠른 접두사 검색이 가능하며, 자동완성 및 사전 검색에 유용하다.
    
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        
        #define ALPHABET_SIZE 26
        
        struct TrieNode {
            struct TrieNode* children[ALPHABET_SIZE];
            int isEndOfWord;
        };
        
        struct TrieNode* getNode(void) {
            struct TrieNode* node = (struct TrieNode*)malloc(sizeof(struct TrieNode));
            node->isEndOfWord = 0;
            for (int i = 0; i < ALPHABET_SIZE; i++) {
                node->children[i] = NULL;
            }
            return node;
        }
        
        void insert(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    node->children[index] = getNode();
                }
                node = node->children[index];
            }
            node->isEndOfWord = 1;
        }
        
        int search(struct TrieNode* root, const char* key) {
            struct TrieNode* node = root;
            for (int i = 0; i < strlen(key); i++) {
                int index = key[i] - 'a';
                if (node->children[index] == NULL) {
                    return 0;
                }
                node = node->children[index];
            }
            return (node != NULL && node->isEndOfWord);
        }
        ```
