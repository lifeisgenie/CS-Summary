# 알고리즘

## 정렬 (Sorting)

데이터를 특정 기준에 따라 순서대로 배치하는 과정이다. 정렬은 알고리즘의 성능과 특성에 따라 다양하게 분류되며, 기술 면접에서도 자주 다루어지는 주제이다.

- **기본 정렬 알고리즘**
    - **버블 정렬 (Bubble Sort)**
        - **원리**: 인접한 두 요소를 비교하여 필요에 따라 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (이미 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 간단하지만 효율성이 낮아 실제 사용은 드물다.
        
        ```c
        void bubbleSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        // Swap arr[j] and arr[j+1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
        ```
        
    - **선택 정렬 (Selection Sort)**
        - **원리**: 배열에서 가장 작은(또는 큰) 요소를 선택해 정렬되지 않은 부분의 맨 앞 요소와 교환하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선/평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 비교 횟수가 많지만 교환 횟수는 적다.
        
        ```c
        void selectionSort(int arr[], int n) {
            for (int i = 0; i < n - 1; i++) {
                int minIdx = i;
                // arr[i+1..n-1]에서 최소값의 인덱스를 찾음
                for (int j = i + 1; j < n; j++) {
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                // arr[i]와 arr[minIdx]를 교환
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
        ```
        
    - **삽입 정렬 (Insertion Sort)**
        - **원리**: 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하며 정렬하는 방식.
        - **시간 복잡도**:
            - 최선: O(n) (거의 정렬된 경우)
            - 평균/최악: O(n²)
        - **공간 복잡도**: O(1) (In-place 정렬)
        - **특징**: 작은 데이터셋에 효과적이며 안정 정렬이다.
        
        ```c
        void insertionSort(int arr[], int n) {
            for (int i = 1; i < n; i++) {
                int key = arr[i];
                int j = i - 1;
        
                // arr[0..i-1]의 요소 중 key보다 큰 요소들을 현재 위치보다 한 칸 뒤로 이동
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key; // key를 올바른 위치에 삽입
            }
        }
        ```
        
- 고급 정렬 알고리즘
    - **병합 정렬 (Merge Sort)**
        - **원리**: 배열을 반으로 나누고 정렬한 후 병합.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(n)
        - **특징**: 안정 정렬, 재귀적 구현.
        
        ```c
        void merge(int arr[], int l, int m, int r) {
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (int i = 0; i < n1; i++) L[i] = arr[l + i];
            for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
        
            int i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) arr[k++] = L[i++];
                else arr[k++] = R[j++];
            }
            while (i < n1) arr[k++] = L[i++];
            while (j < n2) arr[k++] = R[j++];
        }
        
        void mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }
        
        ```
        
    - **퀵 정렬 (Quick Sort)**
        - **원리**: 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
        - **시간 복잡도**:
            - 최선/평균: O(n log n)
            - 최악: O(n²)
        - **공간 복잡도**: O(log n) (재귀 호출 스택)
        - **특징**: 빠르지만 불안정 정렬.
        
        ```c
        int partition(int arr[], int low, int high) {
            int pivot = arr[high];
            int i = (low - 1);
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
            int temp = arr[i + 1];
            arr[i + 1] = arr[high];
            arr[high] = temp;
            return (i + 1);
        }
        
        void quickSort(int arr[], int low, int high) {
            if (low < high) {
                int pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }
        
        ```
        
    - **힙 정렬 (Heap Sort)**
        - **원리**: 힙 자료구조를 사용해 최대값 또는 최소값을 반복적으로 추출.
        - **시간 복잡도**: O(n log n)
        - **공간 복잡도**: O(1)
        - **특징**: 불안정 정렬.
        
        ```c
        void heapify(int arr[], int n, int i) {
            int largest = i;  // 루트
            int left = 2 * i + 1;  // 왼쪽 자식
            int right = 2 * i + 2; // 오른쪽 자식
        
            // 왼쪽 자식이 루트보다 크다면
            if (left < n && arr[left] > arr[largest])
                largest = left;
        
            // 오른쪽 자식이 현재 가장 큰 노드보다 크다면
            if (right < n && arr[right] > arr[largest])
                largest = right;
        
            // 가장 큰 노드가 루트가 아니라면 교환
            if (largest != i) {
                int temp = arr[i];
                arr[i] = arr[largest];
                arr[largest] = temp;
        
                // 재귀적으로 힙을 정렬
                heapify(arr, n, largest);
            }
        }
        
        void heapSort(int arr[], int n) {
            // 힙 생성
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
        
            // 하나씩 요소를 힙에서 제거
            for (int i = n - 1; i > 0; i--) {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
        
                // 힙 정렬
                heapify(arr, i, 0);
            }
        }
        
        ```
        
    - **기수 정렬 (Radix Sort)**
        - **원리**: 자릿수를 기준으로 데이터를 분류하고 병합하여 정렬한다.
        - **시간 복잡도**: O(nk) (n은 데이터 개수, k는 자릿수 길이)
        - **공간 복잡도**: O(n + k)
        - **특징**: 데이터의 크기나 자릿수가 제한적일 때 유용하며 안정 정렬이다.
        
        ```c
        int getMax(int arr[], int n) {
            int max = arr[0];
            for (int i = 1; i < n; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }
        
        void countingSort(int arr[], int n, int exp) {
            int output[n];
            int count[10] = {0};
        
            // 카운트 배열 생성
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;
        
            // 누적 합
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 작성
            for (int i = n - 1; i >= 0; i--) {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }
        
            // 원래 배열 업데이트
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        
        void radixSort(int arr[], int n) {
            int max = getMax(arr, n);
        
            // 각 자릿수에 대해 정렬
            for (int exp = 1; max / exp > 0; exp *= 10)
                countingSort(arr, n, exp);
        }
        ```
        
    - **계수 정렬 (Counting Sort)**
        - **원리**: 데이터의 범위를 기준으로 개수를 세고 누적하여 정렬한다.
        - **시간 복잡도**: O(n + k) (n은 데이터 개수, k는 최대값)
        - **공간 복잡도**: O(n + k)
        - **특징**: 정수 데이터에 적합하며 매우 효율적이지만 범위가 클 경우 메모리 사용량이 증가한다.
        
        ```c
        void countingSort(int arr[], int n) {
            int output[n];
            int max = arr[0];
        
            for (int i = 1; i < n; i++)
                if (arr[i] > max) max = arr[i];
        
            int count[max + 1];
            memset(count, 0, sizeof(count));
        
            // 카운트 배열 작성
            for (int i = 0; i < n; i++)
                count[arr[i]]++;
        
            // 누적 합
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];
        
            // 결과 배열 생성
            for (int i = n - 1; i >= 0; i--) {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }
        
            // 원래 배열에 결과 복사
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
        ```
        
    - **셸 정렬 (Shell Sort)**
        - **원리**: 삽입 정렬을 일반화하여 일정 간격의 요소들만 비교하고 정렬하며, 점차 간격을 좁히는 방식이다.
        - **시간 복잡도**: 평균적으로 O(n log n) ~ O(n²) (간격 선택에 따라 다름)
        - **공간 복잡도**: O(1)
        - **특징**: 비교적 간단한 구현으로 중간 규모의 데이터셋에서 유용하지만 불안정 정렬이다.
        
        ```c
        void shellSort(int arr[], int n) {
            for (int gap = n / 2; gap > 0; gap /= 2) {
                for (int i = gap; i < n; i++) {
                    int temp = arr[i];
                    int j;
                    for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                        arr[j] = arr[j - gap];
                    }
                    arr[j] = temp;
                }
            }
        }
        ```
        
- **비교 기반 정렬과 비비교 기반 정렬의 차이**
    - **비교 기반 정렬**:
        - 데이터 간의 크기를 비교하며 정렬한다.
        - 병합 정렬, 퀵 정렬, 힙 정렬 등이 포함된다.
        - 일반적으로 범용적으로 사용 가능하며 시간 복잡도는 O(n log n) 이상이다.
    - **비비교 기반 정렬**:
        - 데이터 간의 크기를 비교하지 않고, 키나 자릿수 등 특성을 활용해 정렬한다.
        - 기수 정렬, 계수 정렬 등이 포함된다.
        - 데이터 특성에 따라 효율적이며 O(n)까지의 시간 복잡도를 가지지만 제한적이다.
