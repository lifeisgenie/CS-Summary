# 자료구조

## 리스트

- **설명**: 데이터를 순서대로 저장하며, 크기를 동적으로 조정할 수 있는 선형 자료구조. 배열과 연결 리스트를 포함하는 상위 개념이다.
- **특징**:
    - 데이터가 순서대로 저장된다.
    - 중복 데이터를 허용한다.
    - 배열 기반 리스트는 랜덤 접근이 가능 (`O(1)`), 연결 리스트는 순차 접근이 필요 (`O(n)`).
- **사용 예시)**
    - 데이터를 순차적으로 저장하고 처리하는 일반적인 작업에 사용
    - 배열이나 연결 리스트를 기반으로 구현

### 배열 (Array)

고정 크기의 연속된 메모리 공간에 데이터를 저장하며, 빠른 랜덤 접근을 지원하는 자료구조다. 크기가 고정된 고정 배열과 크기를 동적으로 조정할 수 있는 동적 배열로 나뉜다.

- **고정 크기 배열 (Fixed-size Array)**
    - **특징:**
        - 크기가 고정되어 있다.
        - 데이터를 빠르게 읽고 쓸 수 있다. (`O(1)`)
        - 데이터 삽입/삭제가 비효율적이다. (`O(n)`)
    - **사용 예시)** 정적 데이터 구조 구현 (예: 행렬 계산, 월별 데이터 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        // 고정 크기 배열
        int array[SIZE] = {1, 2, 3, 4, 5};
        printf("고정 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", array[i]);
        }
        printf("\n");
        return 0;
    }
    ```
    
- **동적 배열 (Dynamic Array)**
    - **특징:**
        - 크기가 동적으로 조정된다.
        - 데이터 접근 속도가 빠르다.
        - 크기 초과 시 메모리 재할당 비용이 발생한다.
    - **사용 예시)** 동적으로 생성되는 데이터 처리 (예: 웹 로그 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        int *dynamic_array = (int *)malloc(SIZE * sizeof(int));
        for (int i = 0; i < SIZE; i++) {
            dynamic_array[i] = i + 1;
        }
        printf("동적 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", dynamic_array[i]);
        }
        printf("\n");
    
        free(dynamic_array); // 동적 메모리 해제
        return 0;
    }
    
    ```
    

### 연결 리스트 (Linked List)

데이터를 노드(Node)에 저장하고, 각 노드가 다음 노드를 가리키는 포인터를 통해 연결되는 동적 자료구조다.

- **특징**
    - 크기가 동적으로 조정된다.
    - 배열보다 삽입/삭제가 효율적이다. (`O(1)` - 리스트 앞에서 삽입/삭제 시)
    - 임의의 요소 접근은 비효율적이다. (`O(n)`)
- **단일 연결 리스트 (Singly-Linked List)**
    - **설명**: 각 노드가 데이터와 다음 노드의 포인터를 포함하며 한 방향으로만 연결된다.
    - **사용 예시)**
        - 메모리 제약이 있는 환경에서 데이터 저장
        - 스택과 같은 간단한 자료구조 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }
    
    // 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d -> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("단일 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **이중 연결 리스트 (Doubly-Linked List)**
    - **설명**: 각 노드가 이전 노드와 다음 노드의 포인터를 포함하며 양방향으로 연결된다.
    - **사용 예시)**
        - Undo/Redo 기능 구현
        - LRU 캐시 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *prev;
        struct Node *next;
    } Node;
    
    // 이중 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->prev = NULL;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
        new_node->prev = current;
    }
    
    // 이중 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d <-> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("이중 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **원형 연결 리스트 (Circular-Linked List)**
    - **설명**: 마지막 노드가 첫 번째 노드를 가리키며 순환 구조를 형성하는 리스트.
    - **사용 예시)**
        - 프로세스 스케줄링 (라운드로빈 방식)
        - 게임의 턴 제어 시스템
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 원형 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            new_node->next = *head;
            return;
        }
    
        Node *current = *head;
        while (current->next != *head) {
            current = current->next;
        }
        current->next = new_node;
        new_node->next = *head;
    }
    
    // 원형 연결 리스트 출력
    void display(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        do {
            printf("%d -> ", current->data);
            current = current->next;
        } while (current != head);
        printf("(head)\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        Node *next_node;
        do {
            next_node = current->next;
            free(current);
            current = next_node;
        } while (current != head);
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("원형 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **다중 연결 리스트 (Multi-Linked List)**
    - **설명:** 하나의 노드가 여러 개의 연결을 가질 수 있는 구조로, 각 노드가 여러 방향으로 연결될 수 있다. 각 노드에 다수의 포인터를 가지며, 특정 데이터를 여러 개의 연결 구조로 표현할 수 있도록 한다.
    - **사용 예시)**
        - **그래프 표현**: 방향 그래프와 비방향 그래프의 인접 리스트 표현
        - **2차원 배열 동적 구현**: 동적 메모리를 사용하여 2D 배열을 구현
        - **데이터 관계 관리**: 데이터베이스와 같이 한 데이터가 여러 데이터와 관계를 가질 때
    
   ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *right; // 오른쪽 노드
        struct Node *down;  // 아래쪽 노드
    } Node;
    
    // 새 노드 생성
    Node* create_node(int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->right = NULL;
        new_node->down = NULL;
        return new_node;
    }
    
    // 다중 연결 리스트 생성 (2차원 배열과 유사)
    Node* create_multi_linked_list(int rows, int cols) {
        Node *head = NULL;
        Node *row_head = NULL;
        Node *prev_row = NULL;
    
        for (int i = 0; i < rows; i++) {
            Node *prev_col = NULL;
    
            for (int j = 0; j < cols; j++) {
                Node *new_node = create_node(i * cols + j + 1); // 노드에 값 삽입
    
                if (j == 0) {
                    if (head == NULL) {
                        head = new_node;
                    } else {
                        row_head->down = new_node;
                    }
                    row_head = new_node;
                }
    
                if (prev_col != NULL) {
                    prev_col->right = new_node;
                }
    
                if (prev_row != NULL && prev_row->right != NULL) {
                    prev_row->right->down = new_node;
                    prev_row = prev_row->right;
                }
    
                prev_col = new_node;
            }
    
            prev_row = row_head;
        }
    
        return head;
    }
    
    // 다중 연결 리스트 출력
    void display_multi_linked_list(Node *head) {
        Node *row = head;
    
        while (row != NULL) {
            Node *col = row;
            while (col != NULL) {
                printf("%d ", col->data);
                col = col->right;
            }
            printf("\n");
            row = row->down;
        }
    }
    
    // 메모리 해제
    void free_multi_linked_list(Node *head) {
        Node *row = head;
        while (row != NULL) {
            Node *col = row;
            Node *next_row = row->down;
    
            while (col != NULL) {
                Node *next_col = col->right;
                free(col);
                col = next_col;
            }
    
            row = next_row;
        }
    }
    
    int main() {
        int rows = 3, cols = 4;
    
        Node *head = create_multi_linked_list(rows, cols);
    
        printf("다중 연결 리스트 출력:\n");
        display_multi_linked_list(head);
    
        free_multi_linked_list(head);
    
        return 0;
    }
    
    // 출력 결과:
    다중 연결 리스트 출력:
    1 2 3 4
    5 6 7 8
    9 10 11 12
    ```

## 스택(Stack)

**LIFO (Last In, First Out)** 구조를 가진 자료구조로, 가장 마지막에 삽입된 데이터가 가장 먼저 제거되는 후입선출이다. 스택은 한쪽 끝에서만 데이터의 삽입과 삭제가 이루어진다.

- **동작 원리**
    - **Push (삽입)**: 데이터를 스택의 최상단(top)에 추가한다.
    - **Pop (삭제)**: 스택의 최상단(top) 데이터를 제거하고 반환한다.
    - **Peek/Top (조회)**: 데이터를 제거하지 않고 스택의 최상단 데이터를 반환한다.
    - **Empty (비었는지 확인)**: 스택에 데이터가 없는지 확인한다.
- **장단점**
    - **장점**
        - 삽입과 삭제 연산이 O(1)로 매우 빠르다.
        - 데이터 순서를 추적하는 데 효과적이다.
    - **단점**
        - 배열 기반 스택은 크기가 고정되어 있어 크기를 초과하면 재할당이 필요하다.
        - 연결 리스트 기반 스택은 포인터를 위한 추가 메모리가 필요하다.
- **사용 예시)**
    - **재귀 함수 처리**: 함수 호출 스택 관리.
    - **괄호 검사**: 수식의 괄호 균형 체크.
    - **역순 작업**: 문자열 뒤집기, 역순 데이터 처리.
    - **웹 브라우저 뒤로 가기/앞으로 가기**: 이전 페이지로 돌아가기.
    - **운영 체제**: 실행 중인 프로세스 관리 (스택 메모리).

### 배열 기반 스택 (Array-based Stack)

배열을 사용하여 스택을 구현하며, 고정된 크기를 사용하거나 동적 크기로 구현 가능하다. 배열의 마지막 요소가 스택의 최상단(top)을 나타낸다.

- **동작 방식**
    - 배열을 이용해 데이터를 선형적으로 저장한다.
    - 배열의 마지막 요소가 스택의 최상단을 나타낸다.
    - 크기를 초과할 경우, 새 배열을 할당해 복사해야 한다.
- **원리**
    - 데이터 삽입 시 `top`을 증가시키고, 해당 위치에 데이터를 저장한다.
    - 데이터 삭제 시 `top`의 데이터를 반환하고 감소시킨다.
- **사용 예시)**
    - 데이터 크기가 고정되어 있을 때 (e.g., 정해진 크기의 명령 처리).
    - 작은 규모의 데이터를 관리할 때 메모리와 성능 효율적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100 // 스택의 최대 크기

typedef struct {
    int data[MAX_SIZE];
    int top; // 스택의 최상단을 나타냄
} Stack;

// 스택 초기화
void init_stack(Stack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(Stack *stack) {
    return stack->top == -1;
}

// 스택이 가득 찼는지 확인
int is_full(Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

// 스택에 데이터 삽입
void push(Stack *stack, int value) {
    if (is_full(stack)) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;
}

// 스택에서 데이터 삭제 및 반환
int pop(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택 최상단 데이터 반환
int peek(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->data[stack->top];
}

int main() {
    Stack stack;
    init_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 연결 리스트 기반 스택 (Linked List-based Stack)

동적 메모리를 사용해 연결 리스트로 스택을 구현하며, 스택의 최상단(top)은 리스트의 헤드 노드로 표현된다.

- **동작 방식**
    - 각 노드가 데이터를 저장하며, 스택의 최상단은 연결 리스트의 첫 번째 노드를 나타낸다.
    - 동적 메모리를 사용하여 삽입과 삭제를 수행한다.
- **원리**
    - 데이터 삽입 시 새 노드를 생성하고, 기존 최상단을 새 노드의 `next`로 연결한다.
    - 데이터 삭제 시 최상단 노드를 제거하고 `next` 노드를 새로운 최상단으로 설정한다.
- **사용 예시)**
    - 데이터 크기가 가변적이고 동적 메모리 사용이 필요할 때.
    - 메모리 제약 없이 데이터 삽입/삭제가 필요한 경우.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 스택 초기화
Node* create_stack() {
    return NULL; // 초기 스택은 NULL
}

// 스택에 데이터 삽입
void push(Node **top, int value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = value;
    new_node->next = *top;
    *top = new_node;
}

// 스택에서 데이터 삭제 및 반환
int pop(Node **top) {
    if (*top == NULL) {
        printf("스택 언더플로우\n");
        return -1;
    }
    Node *temp = *top;
    int value = temp->data;
    *top = (*top)->next;
    free(temp);
    return value;
}

// 스택 최상단 데이터 반환
int peek(Node *top) {
    if (top == NULL) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return top->data;
}

int main() {
    Node *stack = create_stack();

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 최소값/최대값 추적 스택 (Min/Max Stack)

스택에서 데이터를 삽입/삭제하는 동안 최소값 또는 최대값을 추적한다. 보조 스택을 사용하여 이를 구현하며, 각 연산이 O(1)로 작동한다.

- **동작 방식**
    - 기본 스택과 보조 스택을 사용한다.
    - 데이터를 삽입할 때, 보조 스택에 최소값 또는 최대값을 업데이트하며 저장한다.
    - 데이터를 삭제할 때, 보조 스택에서도 값을 제거한다.
- **원리**
    - 데이터 삽입 시 기존의 최소값/최대값과 비교하여 보조 스택을 갱신한다.
    - 최솟값/최댓값 확인 시 보조 스택의 최상단을 반환한다.
- **사용 예시)**
    - 실시간으로 데이터의 최솟값/최댓값을 확인해야 하는 경우.
    - 예: 주식 가격의 실시간 추적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int min[MAX_SIZE];
    int top;
} MinStack;

// 스택 초기화
void init_min_stack(MinStack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(MinStack *stack) {
    return stack->top == -1;
}

// 스택에 데이터 삽입
void push(MinStack *stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;

    // 최소값 추적
    if (stack->top == 0) {
        stack->min[stack->top] = value;
    } else {
        stack->min[stack->top] = (value < stack->min[stack->top - 1]) ? value : stack->min[stack->top - 1];
    }
}

// 스택에서 데이터 삭제 및 반환
int pop(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택에서 최솟값 반환
int get_min(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->min[stack->top];
}

int main() {
    MinStack stack;
    init_min_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 5);
    push(&stack, 30);

    printf("Min: %d\n", get_min(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Min: %d\n", get_min(&stack));

    return 0;
}
```

## 큐(Queue)

**FIFO (First In, First Out)**구조를 가진 자료구조로, 주로 한쪽 끝에서 삽입하고 다른 한쪽 끝에서 삭제한다.

- **연산**
    - **Enqueue(삽입):** 데이터를 큐의 끝에 추가.
    - **Dequeue(삭제):** 데이터를 큐의 앞에서 제거하고 반환.
    - **Peek(참조):** 큐의 맨 앞 데이터를 제거하지 않고 반환.
- **원리**
    
    큐는 두 개의 포인터를 사용해 구현된다:
    
    - **Front:** 큐의 첫 번째 요소를 가리킴 (삭제 작업에서 사용).
    - **Rear:** 큐의 마지막 요소를 가리킴 (삽입 작업에서 사용).데이터는 **Front → Rear** 방향으로 이동한다.큐가 가득 차거나 비었는지 확인하기 위해 크기와 포인터 위치를 비교한다.
- **사용 예시)**
    - **프로세스 스케줄링**: CPU 스케줄링, 작업 대기열 관리.
    - **데이터 버퍼**: 프린터 스풀러, 네트워크 패킷 관리.
    - **실시간 요청 처리**: 작업 큐, 프로세스 관리.
    - **그래프 탐색**: BFS(너비 우선 탐색) 구현.

### 배열 기반 큐 (Array-based Queue)

배열을 사용해 큐를 구현하며, 크기가 고정되어 메모리를 효율적으로 사용하지만 큐가 가득 찼을 때 더 이상 삽입할 수 없다.

- **장단점**
    - **장점:** 구현이 간단하고, 특정 크기의 데이터 처리에 적합
    - **단점:** 삽입과 삭제 작업이 비효율적(연산에 O(n) 필요). 삭제 연산 시 모든 요소를 한 칸씩 이동해야 한다.
- **사용 예시)**
    - 고정된 크기의 데이터 처리 (e.g., 제한된 요청 큐).
    - 간단한 큐 연산이 필요한 작업.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

// 큐 초기화
void init_queue(Queue *queue) {
    queue->front = 0;
    queue->rear = -1;
}

// 큐가 비었는지 확인
int is_empty(Queue *queue) {
    return queue->rear < queue->front;
}

// 큐가 가득 찼는지 확인
int is_full(Queue *queue) {
    return queue->rear == MAX_SIZE - 1;
}

// 큐에 데이터 삽입
void enqueue(Queue *queue, int value) {
    if (is_full(queue)) {
        printf("큐 오버플로우\n");
        return;
    }
    queue->data[++queue->rear] = value;
}

// 큐에서 데이터 삭제 및 반환
int dequeue(Queue *queue) {
    if (is_empty(queue)) {
        printf("큐 언더플로우\n");
        return -1;
    }
    return queue->data[queue->front++];
}

// 큐의 첫 번째 데이터 반환
int peek(Queue *queue) {
    if (is_empty(queue)) {
        printf("큐가 비어 있습니다.\n");
        return -1;
    }
    return queue->data[queue->front];
}

int main() {
    Queue queue;
    init_queue(&queue);

    enqueue(&queue, 10);
    enqueue(&queue, 20);
    enqueue(&queue, 30);

    printf("Peek: %d\n", peek(&queue));
    printf("Dequeue: %d\n", dequeue(&queue));
    printf("Dequeue: %d\n", dequeue(&queue));

    return 0;
}

```

### 순환 큐 (Circular Queue)

배열의 끝이 처음과 연결되어 원형 형태를 만든다.

- **Mod 연산**을 사용해 삽입과 삭제 위치를 계산:
    - `(Rear + 1) % 큐 크기`: 다음 삽입 위치
    - `(Front + 1) % 큐 크기`: 다음 삭제 위치
- **장단점**
    - **장점:** 메모리 낭비가 적고 삭제 시 데이터 이동할 필요 없다
    - **단점:** 구현이 복잡하며 동적 크기 지원이 어렵다
- **사용 예시)**
    - 라운드 로빈 방식의 CPU 스케줄링
    - 제한된 메모리에서 데이터 순환 처리

### 연결 리스트 기반 큐 (Linked List-based Queue)

동적 메모리를 사용해 연결 리스트로 큐를 구현하며, 각 노드는 데이터를 저장하고 다음 노드를 가리키는 포인터를 포함한다.

- **동작 원리**
    - 삽입은 Rear 노드 뒤에서 수행
    - 삭제는 Front 노드에서 수행
- **장단점**
    - **장점:** 크기 제한이 없으며 동적 메모리 할당이 가능
    - **단점:** 추가적인 포인터 저장 공간 필요, 메모리 관리 복잡
- **사용 예시**
    - 크기 제한이 없는 데이터 스트림 처리
    - 동적 데이터 구조가 필요한 네트워크 패킷 처리

### 우선순위 큐 (Priority Queue)

각 데이터에 우선순위를 부여하여 높은 우선순위를 가진 데이터가 먼저 처리된다.

- **장단점**
    - **장점:** 우선순위가 있는 작업 처리에 적합
    - **단점:** 배열 기반은 삽입/삭제 시 O(n), 힙 기반은 O(log n) 필요
- **사용 예시)**
    - 작업 스케줄링 (가장 중요한 작업을 먼저 실행)
    - Dijkstra 알고리즘과 같은 그래프 최단 경로 계산
- **배열 기반 우선순위 큐:** 정렬된 배열을 사용
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 100
    
    typedef struct {
        int data[MAX_SIZE];
        int front;
        int rear;
    } Queue;
    
    void init_queue(Queue *queue) {
        queue->front = 0;
        queue->rear = -1;
    }
    
    int is_empty(Queue *queue) {
        return queue->rear < queue->front;
    }
    
    int is_full(Queue *queue) {
        return queue->rear == MAX_SIZE - 1;
    }
    
    void enqueue(Queue *queue, int value) {
        if (is_full(queue)) {
            printf("큐 오버플로우\n");
            return;
        }
        queue->data[++queue->rear] = value;
    }
    
    int dequeue(Queue *queue) {
        if (is_empty(queue)) {
            printf("큐 언더플로우\n");
            return -1;
        }
        return queue->data[queue->front++];
    }
    
    int peek(Queue *queue) {
        if (is_empty(queue)) {
            printf("큐가 비어 있습니다.\n");
            return -1;
        }
        return queue->data[queue->front];
    }
    
    int main() {
        Queue queue;
        init_queue(&queue);
    
        enqueue(&queue, 10);
        enqueue(&queue, 20);
        enqueue(&queue, 30);
    
        printf("Peek: %d\n", peek(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
    
        return 0;
    }
    ```
    
- **힙 기반 우선순위 큐:** 최소 힙 또는 최대 힙을 사용해 우선순위를 효율적으로 관리
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 5
    
    typedef struct {
        int data[MAX_SIZE];
        int front;
        int rear;
    } CircularQueue;
    
    void init_queue(CircularQueue *queue) {
        queue->front = 0;
        queue->rear = 0;
    }
    
    int is_empty(CircularQueue *queue) {
        return queue->front == queue->rear;
    }
    
    int is_full(CircularQueue *queue) {
        return (queue->rear + 1) % MAX_SIZE == queue->front;
    }
    
    void enqueue(CircularQueue *queue, int value) {
        if (is_full(queue)) {
            printf("큐 오버플로우\n");
            return;
        }
        queue->data[queue->rear] = value;
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    
    int dequeue(CircularQueue *queue) {
        if (is_empty(queue)) {
            printf("큐 언더플로우\n");
            return -1;
        }
        int value = queue->data[queue->front];
        queue->front = (queue->front + 1) % MAX_SIZE;
        return value;
    }
    
    int peek(CircularQueue *queue) {
        if (is_empty(queue)) {
            printf("큐가 비어 있습니다.\n");
            return -1;
        }
        return queue->data[queue->front];
    }
    
    int main() {
        CircularQueue queue;
        init_queue(&queue);
    
        enqueue(&queue, 10);
        enqueue(&queue, 20);
        enqueue(&queue, 30);
    
        printf("Peek: %d\n", peek(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
    
        return 0;
    }
    ```

## 데크(Deque, Double-Ended Queue)

양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조다. FIFO와 LIFO 방식 모두를 지원하며 큐와 스택의 기능을 모두 포함한다.

- **특징**
    - **양쪽 끝**에서 삽입/삭제가 가능하다.
    - **크기 조정**이 가능한 동적 구조로 구현된다.
    - 주로 **캐시**, **이중 우선순위 큐**, **슬라이딩 윈도우**와 같은 문제에서 사용된다.

### 배열 기반 데크 (Array-based Deque)

- **특징**
    - 데크를 **연속된 메모리 공간**에서 관리한다.
    - 양쪽 끝에서 삽입/삭제 작업 시 **시간 복잡도**는 `O(1)` (단, 크기 초과 시 재할당 발생 가능).
    - 배열을 순환(Circular Buffer) 형태로 구현하여 효율적인 메모리 사용 가능.
- **장단점**
    - **장점**
        - 데이터 접근이 빠르다 (`O(1)`).
        - 메모리 사용량이 상대적으로 적다.
    - **단점**
        - 크기 초과 시 **메모리 재할당 비용**이 발생.
        - 양쪽 끝 외의 삽입/삭제 작업은 비효율적(`O(n)`).

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;       // 데이터 저장 배열
    int front;       // 데크의 앞부분 인덱스
    int rear;        // 데크의 뒷부분 인덱스
    int size;        // 현재 저장된 데이터의 개수
    int capacity;    // 배열의 총 용량
} Deque;

// 데크 생성
Deque* createDeque(int capacity) {
    Deque* deque = (Deque*)malloc(sizeof(Deque));
    deque->data = (int*)malloc(capacity * sizeof(int));
    deque->front = 0;
    deque->rear = 0;
    deque->size = 0;
    deque->capacity = capacity;
    return deque;
}

// 데크가 비었는지 확인
int isEmpty(Deque* deque) {
    return deque->size == 0;
}

// 데크가 가득 찼는지 확인
int isFull(Deque* deque) {
    return deque->size == deque->capacity;
}

// 앞쪽에 삽입
void pushFront(Deque* deque, int value) {
    if (isFull(deque)) {
        printf("Deque is full!\n");
        return;
    }
    deque->front = (deque->front - 1 + deque->capacity) % deque->capacity;
    deque->data[deque->front] = value;
    deque->size++;
}

// 뒤쪽에 삽입
void pushBack(Deque* deque, int value) {
    if (isFull(deque)) {
        printf("Deque is full!\n");
        return;
    }
    deque->data[deque->rear] = value;
    deque->rear = (deque->rear + 1) % deque->capacity;
    deque->size++;
}

// 앞쪽에서 삭제
int popFront(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty!\n");
        return -1;
    }
    int value = deque->data[deque->front];
    deque->front = (deque->front + 1) % deque->capacity;
    deque->size--;
    return value;
}

// 뒤쪽에서 삭제
int popBack(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty!\n");
        return -1;
    }
    deque->rear = (deque->rear - 1 + deque->capacity) % deque->capacity;
    int value = deque->data[deque->rear];
    deque->size--;
    return value;
}

// 데크의 앞쪽 요소 확인
int front(Deque* deque) {
    if (isEmpty(deque
```

### 연결 리스트 기반 데크 (Linked List-based Deque)

이중 연결 리스트(Doubly Linked List)를 사용하여 양쪽 끝에서 삽입과 삭제를 효율적으로 구현

- **특징**
    - 데크를 **노드(Node) 기반**으로 구현하며, 각 노드가 데이터와 포인터를 포함.
    - **노드 삽입/삭제**는 양쪽 끝에서 효율적으로 수행(`O(1)`).
    - 동적으로 크기가 조정되므로 메모리 재할당이 필요하지 않다.
- **장단점**
    - **장점**
        - 크기에 제한이 없다.
        - 양쪽 끝에서 삽입/삭제가 항상 효율적이다 (`O(1)`).
    - **단점**
    - 추가적인 **포인터 메모리**가 필요.
    - 데이터 접근 속도가 느리다(`O(n)`).

```c
#include <stdio.h>
#include <stdlib.h>

// 노드 구조체 정의
typedef struct Node {
    int data;             // 데이터 값
    struct Node *prev;    // 이전 노드 포인터
    struct Node *next;    // 다음 노드 포인터
} Node;

// 데크 구조체 정의
typedef struct {
    Node *front;          // 데크의 앞부분
    Node *rear;           // 데크의 뒷부분
} Deque;

// 데크 생성
Deque* createDeque() {
    Deque* deque = (Deque*)malloc(sizeof(Deque));
    deque->front = NULL;
    deque->rear = NULL;
    return deque;
}

// 데크가 비었는지 확인
int isEmpty(Deque* deque) {
    return deque->front == NULL;
}

// 앞쪽에 삽입
void pushFront(Deque* deque, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->prev = NULL;
    newNode->next = deque->front;

    if (isEmpty(deque)) {
        deque->rear = newNode;
    } else {
        deque->front->prev = newNode;
    }
    deque->front = newNode;
}

// 뒤쪽에 삽입
void pushBack(Deque* deque, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->prev = deque->rear;
    newNode->next = NULL;

    if (isEmpty(deque)) {
        deque->front = newNode;
    } else {
        deque->rear->next = newNode;
    }
    deque->rear = newNode;
}

// 앞쪽에서 삭제
int popFront(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty!\n");
        return -1;
    }
    Node* temp = deque->front;
    int value = temp->data;
    deque->front = temp->next;

    if (deque->front == NULL) {
        deque->rear = NULL;
    } else {
        deque->front->prev = NULL;
    }
    free(temp);
    return value;
}

// 뒤쪽에서 삭제
int popBack(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty!\n");
        return -1;
    }
    Node* temp = deque->rear;
    int value = temp->data;
    deque->rear = temp->prev;

    if (deque->rear == NULL) {
        deque->front = NULL;
    } else {
        deque->rear->next = NULL;
    }
    free(temp);
    return value;
}

// 메모리 해제
void freeDeque(Deque* deque) {
    while (!isEmpty(deque)) {
        popFront(deque);
    }
    free(deque);
}
```

## 트리

계층 구조를 표현하기 위해 사용되는 자료구조다. 트리는 부모와 자식 노드 간의 관계로 구성되며, 계층적 데이터의 표현에 적합하다. 

### 트리 (Tree)

- **일반 트리**
    - 임의의 개수를 가진 자식 노드가 있는 트리.
    - **특징**:
        - 계층적 데이터 모델에 적합.
        - 노드 간 연결은 간선(edge)으로 표현.
    - **사용 예시**:
        - 디렉토리 구조, 조직도, XML/HTML DOM 트리.
    
    ```c
    // 일반 트리 노드 정의 및 삽입
    typedef struct TreeNode {
        int data;
        struct TreeNode* firstChild;
        struct TreeNode* nextSibling;
    } TreeNode;
    
    // 새 노드 생성
    TreeNode* createNode(int data) {
        TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
        newNode->data = data;
        newNode->firstChild = NULL;
        newNode->nextSibling = NULL;
        return newNode;
    }
    
    // 자식 노드 추가
    void addChild(TreeNode* parent, TreeNode* child) {
        if (parent->firstChild == NULL) {
            parent->firstChild = child;
        } else {
            TreeNode* sibling = parent->firstChild;
            while (sibling->nextSibling != NULL) {
                sibling = sibling->nextSibling;
            }
            sibling->nextSibling = child;
        }
    }
    ```
    
- **Left-child-right-sibling 트리**
    - 일반 트리를 이진 트리 형태로 변환한 구조.
    - **특징**:
        - 첫 번째 자식은 왼쪽 자식에 연결, 나머지 형제는 오른쪽 자식에 연결.
    - **사용 예시**:
        - 일반 트리의 저장 공간 최적화.
    
    ```c
    // Left-child-right-sibling 변환 예시
    TreeNode* convertToLCRS(TreeNode* root) {
        if (!root) return NULL;
        TreeNode* leftChild = root->firstChild;
        TreeNode* sibling = leftChild ? leftChild->nextSibling : NULL;
    
        root->firstChild = leftChild ? convertToLCRS(leftChild) : NULL;
        if (root->firstChild) root->firstChild->nextSibling = sibling ? convertToLCRS(sibling) : NULL;
    
        return root;
    }
    ```
    

### 트리 순회

트리의 노드를 특정 순서로 방문하는 방법

- **전위 순회 (Pre-order Traversal)**
    - **순서**: 현재 노드 → 왼쪽 서브트리 → 오른쪽 서브트리.
    - **사용 예시)** 복사본 생성, 수식 트리의 전위 표기법.
    
    ```c
    void preOrderTraversal(Node* root) {
        if (root == NULL) return;
        printf("%d ", root->data); // 현재 노드 방문
        preOrderTraversal(root->left);
        preOrderTraversal(root->right);
    }
    ```
    
- **중위 순회 (In-order Traversal)**
    - **순서**: 왼쪽 서브트리 → 현재 노드 → 오른쪽 서브트리.
    - **사용 예시)** 정렬된 순서로 데이터 출력.
    
    ```c
    void inOrderTraversal(Node* root) {
        if (root == NULL) return;
        inOrderTraversal(root->left);
        printf("%d ", root->data); // 현재 노드 방문
        inOrderTraversal(root->right);
    }
    ```
    
- **후위 순회 (Post-order Traversal)**
    - **순서**: 왼쪽 서브트리 → 오른쪽 서브트리 → 현재 노드.
    - **사용 예시)** 디렉토리 삭제, 수식 트리의 후위 표기법.
    
    ```c
    void postOrderTraversal(Node* root) {
        if (root == NULL) return;
        postOrderTraversal(root->left);
        postOrderTraversal(root->right);
        printf("%d ", root->data); // 현재 노드 방문
    }
    ```
    
- **레벨 순회 (Level-order Traversal)**
    - **순서**: 트리의 각 레벨을 차례대로 방문.
    - **사용 예시)** 최단 경로 탐색, 넓이 우선 탐색(BFS).
    
    ```c
    void levelOrderTraversal(Node* root) {
        if (root == NULL) return;
        Queue* queue = createQueue(); // 큐 생성
        enqueue(queue, root);
        while (!isEmpty(queue)) {
            Node* current = dequeue(queue);
            printf("%d ", current->data);
            if (current->left != NULL) enqueue(queue, current->left);
            if (current->right != NULL) enqueue(queue, current->right);
        }
    }
    ```
    

### 이진 트리 (Binary Tree)

- **포화 이진 트리 (Full Binary Tree)**
    - 모든 노드가 0개 또는 2개의 자식을 가진 트리.
    - **사용 예시)** 완전한 계층 구조 모델링.
    
    ```c
    // 포화 이진 트리 예시 코드
    #include <stdio.h>
    #include <stdlib.h>
    
    struct Node {
        int data;
        struct Node* left;
        struct Node* right;
    };
    
    struct Node* newNode(int data) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = data;
        node->left = node->right = NULL;
        return node;
    }
    
    int isFullBinaryTree(struct Node* root) {
        if (root == NULL) return 1;  // 공백 노드는 트리로 간주
        
        // 리프 노드이면 1
        if (root->left == NULL && root->right == NULL) return 1;
    
        // 자식이 둘 다 있으면 재귀적으로 체크
        if (root->left != NULL && root->right != NULL)
            return isFullBinaryTree(root->left) && isFullBinaryTree(root->right);
    
        // 자식이 하나만 있으면 트리가 아님
        return 0;
    }
    
    int main() {
        struct Node* root = newNode(1);
        root->left = newNode(2);
        root->right = newNode(3);
        root->left->left = newNode(4);
        root->left->right = newNode(5);
        
        if (isFullBinaryTree(root))
            printf("포화 이진 트리입니다.\n");
        else
            printf("포화 이진 트리가 아닙니다.\n");
    
        return 0;
    }
    ```
    
- **완전 이진 트리 (Complete Binary Tree)**
    - 마지막 레벨을 제외하고 모든 레벨이 가득 차 있으며, 마지막 레벨은 왼쪽부터 채워진 트리.
    - **사용 예시)** 힙(Heap) 자료구조.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    struct Node {
        int data;
        struct Node* left;
        struct Node* right;
    };
    
    // 새 노드를 생성하는 함수
    struct Node* newNode(int data) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = data;
        node->left = node->right = NULL;
        return node;
    }
    
    // 완전 이진 트리에서 삽입 함수
    struct Node* insertCompleteBinaryTree(struct Node* root, int data) {
        if (root == NULL) return newNode(data);
        
        // 큐를 사용하여 완전 이진 트리의 삽입 구현
        struct Node* queue[100];
        int front = -1, rear = -1;
    
        queue[++rear] = root;
        while (front < rear) {
            struct Node* current = queue[++front];
            
            // 왼쪽 자식이 없으면 삽입
            if (current->left == NULL) {
                current->left = newNode(data);
                return root;
            } else {
                queue[++rear] = current->left;
            }
    
            // 오른쪽 자식이 없으면 삽입
            if (current->right == NULL) {
                current->right = newNode(data);
                return root;
            } else {
                queue[++rear] = current->right;
            }
        }
        return root;
    }
    
    // 트리 출력 (레벨 순회)
    void levelOrderTraversal(struct Node* root) {
        if (root == NULL) return;
        struct Node* queue[100];
        int front = -1, rear = -1;
    
        queue[++rear] = root;
        while (front < rear) {
            struct Node* current = queue[++front];
            printf("%d ", current->data);
            
            if (current->left != NULL) queue[++rear] = current->left;
            if (current->right != NULL) queue[++rear] = current->right;
        }
        printf("\n");
    }
    
    int main() {
        struct Node* root = newNode(1);
        root = insertCompleteBinaryTree(root, 2);
        root = insertCompleteBinaryTree(root, 3);
        root = insertCompleteBinaryTree(root, 4);
        root = insertCompleteBinaryTree(root, 5);
        
        levelOrderTraversal(root);  // 출력: 1 2 3 4 5
        return 0;
    }
    ```
    
- **경사 트리 (Skewed Tree)**
    - 모든 노드가 하나의 자식만을 가지는 트리(왼쪽 또는 오른쪽으로 치우침).
    - **사용 예시)** 비균형 검색 트리의 극단적인 경우
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    struct Node {
        int data;
        struct Node* left;
        struct Node* right;
    };
    
    // 새 노드를 생성하는 함수
    struct Node* newNode(int data) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = data;
        node->left = node->right = NULL;
        return node;
    }
    
    // 경사 트리 생성 (왼쪽 경사 트리)
    struct Node* createSkewedTreeLeft(int n) {
        struct Node* root = newNode(1);
        struct Node* current = root;
    
        for (int i = 2; i <= n; i++) {
            current->left = newNode(i);
            current = current->left;
        }
    
        return root;
    }
    
    // 경사 트리 출력 (전위 순회)
    void preOrderTraversal(struct Node* root) {
        if (root == NULL) return;
        printf("%d ", root->data);
        preOrderTraversal(root->left);
    }
    
    int main() {
        struct Node* root = createSkewedTreeLeft(5);  // 왼쪽으로 경사 진 트리 생성
        preOrderTraversal(root);  // 출력: 1 2 3 4 5
        return 0;
    }
    ```
    
- **수식 트리 (Expression Tree)**
    - 연산자와 피연산자로 구성된 트리. 리프 노드는 피연산자, 내부 노드는 연산자.
    - **사용 예시)** 수식 계산기
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <ctype.h>
    
    // 노드 구조체 정의
    struct Node {
        char data;
        struct Node* left;
        struct Node* right;
    };
    
    // 새 노드를 생성하는 함수
    struct Node* newNode(char data) {
        struct Node* node = (struct Node*)malloc(sizeof(struct Node));
        node->data = data;
        node->left = node->right = NULL;
        return node;
    }
    
    // 수식 트리 출력 (후위 순회)
    void postOrderTraversal(struct Node* root) {
        if (root == NULL) return;
        postOrderTraversal(root->left);
        postOrderTraversal(root->right);
        printf("%c ", root->data);
    }
    
    // 수식 계산
    int evaluate(struct Node* root) {
        if (root == NULL) return 0;
        
        // 리프 노드(숫자)라면 그 값을 반환
        if (!root->left && !root->right)
            return root->data - '0';
        
        // 연산자라면 왼쪽과 오른쪽 자식에 대해 연산 수행
        int leftVal = evaluate(root->left);
        int rightVal = evaluate(root->right);
        
        switch (root->data) {
            case '+': return leftVal + rightVal;
            case '-': return leftVal - rightVal;
            case '*': return leftVal * rightVal;
            case '/': return leftVal / rightVal;
            default: return 0;
        }
    }
    
    int main() {
        // 수식 (3 + (2 * 5)) 의 트리 구성
        struct Node* root = newNode('+');
        root->left = newNode('3');
        
        root->right = newNode('*');
        root->right->left = newNode('2');
        root->right->right = newNode('5');
        
        printf("후위 순회 출력: ");
        postOrderTraversal(root);  // 출력: 3 2 5 * +
        printf("\n");
    
        printf("수식 결과: %d\n", evaluate(root));  // 출력: 13
        return 0;
    }
    ```
    

### 이진 탐색 트리 (Binary Search Tree)

각 노드가 좌측 서브트리에는 작은 값, 우측 서브트리에는 큰 값을 가지는 트리이다. 효율적인 탐색, 삽입, 삭제 연산을 지원한다.

- **사용 예시)** 정렬 데이터의 효율적인 탐색.
    - 이진 탐색 트리에서는 평균적으로 O(log n)의 시간 복잡도로 탐색을 수행할 수 있다.

```c
#include <stdio.h>
#include <stdlib.h>

// 노드 구조체 정의
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// 노드 생성 함수
struct Node* newNode(int data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->left = node->right = NULL;
    return node;
}

// 이진 탐색 트리에서 값을 찾는 함수
struct Node* insert(struct Node* node, int data) {
    if (node == NULL) return newNode(data);

    if (data < node->data)
        node->left = insert(node->left, data);
    else if (data > node->data)
        node->right = insert(node->right, data);

    return node;
}

// 트리에서 값을 검색하는 함수
struct Node* search(struct Node* root, int key) {
    if (root == NULL || root->data == key) return root;

    if (key < root->data)
        return search(root->left, key);
    else
        return search(root->right, key);
}

int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);

    struct Node* found = search(root, 40);
    if (found != NULL)
        printf("노드 %d를 찾았습니다.\n", found->data);
    else
        printf("노드를 찾을 수 없습니다.\n");

    return 0;
}
```

- **균형 이진 탐색 트리 (Balanced BST)**
    
    트리의 높이를 최소화하여 연산이 효율적으로 이루어지도록 유지한다. 높이가 균형을 이루는 경우, 탐색, 삽입, 삭제 연산 모두 O(log N) 시간 복잡도를 가진다.
    
    - **AVL 트리 (AVL Tree)**
        - 각 노드의 왼쪽과 오른쪽 서브트리 높이 차이를 **1 이하**로 유지하여 트리의 균형을 맞춘다. 이를 통해 트리의 깊이를 최소화하고, 삽입, 삭제, 탐색 연산을 O(log N)의 시간 복잡도로 처리할 수 있다.
        - **동작 원리**
            - 각 노드는 `height` 속성을 가지며, 트리 삽입 후 해당 노드의 균형을 맞추기 위해 회전이 필요할 수 있다.
            - 회전은 **좌측 회전**(Left Rotation)과 **우측 회전**(Right Rotation)으로 나뉜다.
                - **좌측 회전:** 우측 서브트리가 깊어지면, 우측 서브트리를 위로 올리고, 왼쪽 자식과의 연결을 갱신한다.
                - **우측 회전:** 좌측 서브트리가 깊어지면, 좌측 서브트리를 위로 올리고, 오른쪽 자식과의 연결을 갱신한다.
            - 이 회전 방식은 트리가 균형을 잃을 때 자동으로 발생하며, 균형 인수(Balance Factor)를 사용하여 트리의 균형을 맞춘다.
        - **사용 예시)** 균형이 중요한 애플리케이션에서 사용, 검색 성능 보장
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <algorithm>
        
        // 노드 구조체 정의
        struct Node {
            int data;
            Node* left;
            Node* right;
            int height;
        };
        
        // 새 노드를 생성하는 함수
        Node* newNode(int data) {
            Node* node = (Node*)malloc(sizeof(Node));
            node->data = data;
            node->left = node->right = NULL;
            node->height = 1;  // 새로운 노드는 높이가 1
            return node;
        }
        
        // 높이 계산 함수
        int height(Node* node) {
            if (node == NULL) return 0;
            return node->height;
        }
        
        // 균형 인수 계산 함수
        int getBalance(Node* node) {
            if (node == NULL) return 0;
            return height(node->left) - height(node->right);
        }
        
        // 우측 회전 함수
        Node* rightRotate(Node* y) {
            Node* x = y->left;
            Node* T2 = x->right;
            
            // 회전
            x->right = y;
            y->left = T2;
        
            // 높이 갱신
            y->height = std::max(height(y->left), height(y->right)) + 1;
            x->height = std::max(height(x->left), height(x->right)) + 1;
        
            return x;
        }
        
        // 좌측 회전 함수
        Node* leftRotate(Node* x) {
            Node* y = x->right;
            Node* T2 = y->left;
            
            // 회전
            y->left = x;
            x->right = T2;
        
            // 높이 갱신
            x->height = std::max(height(x->left), height(x->right)) + 1;
            y->height = std::max(height(y->left), height(y->right)) + 1;
        
            return y;
        }
        
        // 삽입 함수
        Node* insert(Node* node, int data) {
            // 1. 일반적인 BST 삽입
            if (node == NULL) return newNode(data);
        
            if (data < node->data)
                node->left = insert(node->left, data);
            else if (data > node->data)
                node->right = insert(node->right, data);
            else
                return node;  // 중복 값은 삽입하지 않음
        
            // 2. 높이 갱신
            node->height = 1 + std::max(height(node->left), height(node->right));
        
            // 3. 균형 검사
            int balance = getBalance(node);
        
            // 좌측-좌측 (LL)
            if (balance > 1 && data < node->left->data)
                return rightRotate(node);
        
            // 우측-우측 (RR)
            if (balance < -1 && data > node->right->data)
                return leftRotate(node);
        
            // 좌측-우측 (LR)
            if (balance > 1 && data > node->left->data) {
                node->left = leftRotate(node->left);
                return rightRotate(node);
            }
        
            // 우측-좌측 (RL)
            if (balance < -1 && data < node->right->data) {
                node->right = rightRotate(node->right);
                return leftRotate(node);
            }
        
            return node;
        }
        
        // 트리 출력 (중위 순회)
        void inorder(Node* root) {
            if (root == NULL) return;
            inorder(root->left);
            printf("%d ", root->data);
            inorder(root->right);
        }
        
        int main() {
            Node* root = NULL;
            root = insert(root, 10);
            root = insert(root, 20);
            root = insert(root, 30);  // 이때 회전이 발생하여 AVL 트리가 균형을 맞춘다
            root = insert(root, 5);
            
            inorder(root);  // 출력: 5 10 20 30
            return 0;
        }
        ```
        
    - **레드-블랙 트리 (Red-Black Tree)**
        - 색깔 속성(붉은색 또는 검은색)을 부여한 이진 탐색 트리. 트리의 균형을 색깔로 유지하면서 성능을 보장한다.
        - **동작 원리:**
            - **삽입 시 색상 변경과 회전:** 삽입된 노드가 빨간색으로 시작하며, 이로 인해 트리가 불균형을 초래할 수 있다. 이때, 색상을 변경하거나 회전을 수행하여 트리의 균형을 맞춘다.
                - **회전:** 삽입된 노드가 트리의 균형을 깨뜨릴 경우, `왼쪽 회전(leftRotate)` 또는 `오른쪽 회전(rightRotate)`을 통해 균형을 맞춘다.
                - **색상 변경:** 부모와 삼촌의 색상에 따라 트리를 다시 균형 있게 만들기 위해 색상을 변경하는 방법도 있다.
        - **사용 예시)** 메모리 할당기, STL map과 set.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        // 레드-블랙 트리의 색깔 정의
        #define RED 0
        #define BLACK 1
        
        // 레드-블랙 트리 노드 구조체 정의
        struct Node {
            int data;
            int color;
            struct Node* left;
            struct Node* right;
            struct Node* parent;
        };
        
        // 새로운 노드를 생성하는 함수
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->color = RED;  // 새로운 노드는 항상 RED
            node->left = node->right = node->parent = NULL;
            return node;
        }
        
        // 트리의 회전 (왼쪽 회전)
        void leftRotate(struct Node** root, struct Node* x) {
            struct Node* y = x->right;
            x->right = y->left;
            if (y->left != NULL) y->left->parent = x;
            y->parent = x->parent;
            if (x->parent == NULL) *root = y;
            else if (x == x->parent->left) x->parent->left = y;
            else x->parent->right = y;
            y->left = x;
            x->parent = y;
        }
        
        // 트리의 회전 (오른쪽 회전)
        void rightRotate(struct Node** root, struct Node* x) {
            struct Node* y = x->left;
            x->left = y->right;
            if (y->right != NULL) y->right->parent = x;
            y->parent = x->parent;
            if (x->parent == NULL) *root = y;
            else if (x == x->parent->right) x->parent->right = y;
            else x->parent->left = y;
            y->right = x;
            x->parent = y;
        }
        
        // 삽입 후 트리 재정렬 함수 (레드-블랙 트리 특성에 맞게)
        void fixViolation(struct Node** root, struct Node* node) {
            struct Node* parent = NULL;
            struct Node* grandParent = NULL;
            
            while (node != *root && node->color == RED && node->parent->color == RED) {
                parent = node->parent;
                grandParent = parent->parent;
                
                // 부모가 왼쪽 자식인 경우
                if (parent == grandParent->left) {
                    struct Node* uncle = grandParent->right;
                    if (uncle != NULL && uncle->color == RED) {
                        // Case 1: 부모와 삼촌이 빨간색인 경우
                        grandParent->color = RED;
                        parent->color = BLACK;
                        uncle->color = BLACK;
                        node = grandParent;
                    } else {
                        // Case 2: 부모가 빨간색이고 삼촌이 검은색인 경우
                        if (node == parent->right) {
                            leftRotate(root, parent);
                            node = parent;
                            parent = node->parent;
                        }
                        // Case 3: 부모가 빨간색이고 삼촌이 검은색인 경우
                        rightRotate(root, grandParent);
                        parent->color = BLACK;
                        grandParent->color = RED;
                        node = parent;
                    }
                }
                // 부모가 오른쪽 자식인 경우는 위와 반대로 처리
                else {
                    struct Node* uncle = grandParent->left;
                    if (uncle != NULL && uncle->color == RED) {
                        grandParent->color = RED;
                        parent->color = BLACK;
                        uncle->color = BLACK;
                        node = grandParent;
                    } else {
                        if (node == parent->left) {
                            rightRotate(root, parent);
                            node = parent;
                            parent = node->parent;
                        }
                        leftRotate(root, grandParent);
                        parent->color = BLACK;
                        grandParent->color = RED;
                        node = parent;
                    }
                }
            }
            (*root)->color = BLACK;
        }
        
        // 삽입 함수
        void insert(struct Node** root, int data) {
            struct Node* node = newNode(data);
            
            if (*root == NULL) {
                *root = node;
                node->color = BLACK;
                return;
            }
            
            struct Node* parent = NULL;
            struct Node* temp = *root;
            
            // 이진 탐색을 통해 삽입할 위치를 찾음
            while (temp != NULL) {
                parent = temp;
                if (data < temp->data) temp = temp->left;
                else temp = temp->right;
            }
            
            node->parent = parent;
            
            if (data < parent->data) parent->left = node;
            else parent->right = node;
            
            // 트리 균형을 맞추기 위해 수정
            fixViolation(root, node);
        }
        
        void inorder(struct Node* root) {
            if (root == NULL) return;
            inorder(root->left);
            printf("%d ", root->data);
            inorder(root->right);
        }
        
        int main() {
            struct Node* root = NULL;
            
            insert(&root, 10);
            insert(&root, 20);
            insert(&root, 30);
            insert(&root, 15);
            
            inorder(root);  // 출력: 10 15 20 30
            return 0;
        }
        ```
        
    - **Splay Tree**
        - 최근에 접근한 노드를 루트로 이동시키는 이진 탐색 트리. 특정 노드를 자주 접근할 때 효율적이다.
        - **동작 원리:**
            - **Splay 연산:** 삽입 또는 검색 시에 해당 노드를 루트로 이동시키는 연산을 한다. 이를 위해 트리에서 해당 노드를 찾고, 그 노드를 루트로 만드는 여러 가지 회전을 수행한다.
                - **회전:** 트리에서 원하는 노드를 찾은 후, 그 노드를 루트로 올리기 위해 **좌측 회전(leftRotate)** 또는 **우측 회전(rightRotate)**을 사용한다. 이 방식은 부모와 자식 노드를 번갈아 회전시키면서 해당 노드를 루트로 올린다.
        - **사용 예시)** 캐시, 문자열 탐색.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        // 노드 구조체 정의
        struct Node {
            int data;
            struct Node* left;
            struct Node* right;
        };
        
        // 새 노드를 생성하는 함수
        struct Node* newNode(int data) {
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node->data = data;
            node->left = node->right = NULL;
            return node;
        }
        
        // 왼쪽 회전 함수
        struct Node* leftRotate(struct Node* root) {
            struct Node* newRoot = root->right;
            root->right = newRoot->left;
            newRoot->left = root;
            return newRoot;
        }
        
        // 오른쪽 회전 함수
        struct Node* rightRotate(struct Node* root) {
            struct Node* newRoot = root->left;
            root->left = newRoot->right;
            newRoot->right = root;
            return newRoot;
        }
        
        // Splay 함수 (특정 노드를 루트로 이동)
        struct Node* splay(struct Node* root, int key) {
            // 만약 루트가 NULL이거나 루트의 값이 key라면, 아무 것도 하지 않음
            if (root == NULL || root->data == key) return root;
        
            // 키가 루트보다 작은 경우
            if (key < root->data) {
                if (root->left == NULL) return root;
                
                // Zig-Zig (좌측-좌측 회전)
                if (key < root->left->data) {
                    root = rightRotate(root);
                    root = rightRotate(root);
                }
                // Zig-Zag (좌측-우측 회전)
                else if (key > root->left->data) {
                    root->left = leftRotate(root->left);
                    root = rightRotate(root);
                }
            }
            // 키가 루트보다 큰 경우
            else {
                if (root->right == NULL) return root;
                
                // Zig-Zig (우측-우측 회전)
                if (key > root->right->data) {
                    root = leftRotate(root);
                    root = leftRotate(root);
                }
                // Zig-Zag (우측-좌측 회전)
                else if (key < root->right->data) {
                    root->right = rightRotate(root->right);
                    root = leftRotate(root);
                }
            }
            
            return root;
        }
        
        // 삽입 함수
        struct Node* insert(struct Node* root, int key) {
            if (root == NULL) return newNode(key);
        
            root = splay(root, key);
        
            if (root->data == key) return root;
        
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = key;
        
            if (root->data > key) {
                newNode->right = root;
                newNode->left = root->left;
                root->left = NULL;
            } else {
                newNode->left = root;
                newNode->right = root->right;
                root->right = NULL;
            }
        
            return newNode;
        }
        
        void inorder(struct Node* root) {
            if (root == NULL) return;
            inorder(root->left);
            printf("%d ", root->data);
            inorder(root->right);
        }
        
        int main() {
            struct Node* root = NULL;
            
            root = insert(root, 10);
            root = insert(root, 20);
            root = insert(root, 30);
            root = insert(root, 15);
            
            inorder(root);  // 출력: 10 15 20 30
            return 0;
        }
        ```
        
- **B 트리 계열**
    - **B 트리 (B-Tree)**
        - **설명:**
            - B 트리는 **균형 다진 트리**로, 데이터가 트리의 노드에 균등하게 분포하도록 하여 효율적인 검색, 삽입, 삭제를 지원한다.
            - **디스크 I/O를 최소화**하는 데 최적화되어 있어 대용량 데이터를 처리하는 데 적합하다.
            - 트리의 모든 리프 노드가 동일한 깊이를 가지며, 내부 노드에는 여러 개의 자식 노드가 있을 수 있다.
        - **동작 원리:**
            - B 트리는 각 노드가 여러 자식 노드를 가지며, 노드의 수를 일정 범위로 제한한다. 이 범위를 벗어나면 노드를 분할하거나 병합하여 균형을 유지한다.
            - 삽입 시 노드가 가득 차면 분할되고, 삭제 시에는 병합이 일어난다.
            - 각 노드는 다수의 키와 포인터를 가지며, 이를 통해 자식 노드를 효율적으로 탐색할 수 있다.
        - **사용 예시)**
            - **데이터베이스:** 디스크 기반 데이터베이스에서 인덱스를 구현하기 위해 B 트리를 사용한다.
            - **파일 시스템:** 대용량 파일 시스템에서 데이터를 효율적으로 관리하기 위해 사용된다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define MAX 3  // 최대 자식 노드 수
        
        // B트리 노드 정의
        typedef struct Node {
            int keys[MAX];  // 키 배열
            struct Node* children[MAX + 1];  // 자식 노드 포인터 배열
            int n;  // 현재 키 수
            int leaf;  // 리프 노드 여부
        } Node;
        
        // 노드 생성 함수
        Node* createNode(int leaf) {
            Node* newNode = (Node*)malloc(sizeof(Node));
            newNode->leaf = leaf;
            newNode->n = 0;
            for (int i = 0; i < MAX + 1; i++) {
                newNode->children[i] = NULL;
            }
            return newNode;
        }
        
        // B-Tree 삽입 함수
        void insert(Node** root, int key) {
            Node* r = *root;
            if (r->n == MAX) {  // 루트가 가득 차면 분할
                Node* newNode = createNode(0);
                newNode->children[0] = r;
                split(newNode, 0, r);
                *root = newNode;
            }
            insertNonFull(*root, key);
        }
        
        // B-Tree 노드 분할 함수
        void split(Node* x, int i, Node* y) {
            Node* z = createNode(y->leaf);
            z->n = MAX / 2;
            for (int j = 0; j < MAX / 2; j++) {
                z->keys[j] = y->keys[j + MAX / 2 + 1];
            }
            if (!y->leaf) {
                for (int j = 0; j <= MAX / 2; j++) {
                    z->children[j] = y->children[j + MAX / 2 + 1];
                }
            }
            y->n = MAX / 2;
        
            for (int j = x->n; j > i; j--) {
                x->children[j + 1] = x->children[j];
            }
            x->children[i + 1] = z;
        
            for (int j = x->n - 1; j >= i; j--) {
                x->keys[j + 1] = x->keys[j];
            }
            x->keys[i] = y->keys[MAX / 2];
            x->n++;
        }
        
        // B-Tree 노드에 키 삽입 (가득 차지 않았을 경우)
        void insertNonFull(Node* x, int key) {
            int i = x->n - 1;
            if (x->leaf) {
                while (i >= 0 && key < x->keys[i]) {
                    x->keys[i + 1] = x->keys[i];
                    i--;
                }
                x->keys[i + 1] = key;
                x->n++;
            } else {
                while (i >= 0 && key < x->keys[i]) {
                    i--;
                }
                i++;
                if (x->children[i]->n == MAX) {
                    split(x, i, x->children[i]);
                    if (key > x->keys[i]) {
                        i++;
                    }
                }
                insertNonFull(x->children[i], key);
            }
        }
        
        // B-Tree 출력 함수
        void printTree(Node* root, int level) {
            if (root) {
                for (int i = 0; i < root->n; i++) {
                    printf("%d ", root->keys[i]);
                }
                printf("\n");
        
                if (!root->leaf) {
                    for (int i = 0; i <= root->n; i++) {
                        printTree(root->children[i], level + 1);
                    }
                }
            }
        }
        
        int main() {
            Node* root = createNode(1);
            insert(&root, 10);
            insert(&root, 20);
            insert(&root, 5);
            insert(&root, 6);
            insert(&root, 15);
            insert(&root, 30);
        
            printTree(root, 0);
            return 0;
        }
        ```
        
    - **B+ 트리 (B+ Tree)**
        - **설명:**
            - B+ 트리는 B 트리의 변형으로, **리프 노드**에만 실제 데이터가 저장되고, **내부 노드는 키 값만 저장**한다.
            - 리프 노드는 **링크드 리스트**로 연결되어 있어 범위 검색 및 순차 접근이 효율적이다.
        - **동작 원리:**
            - B+ 트리는 B 트리의 기본 구조에 추가로 리프 노드들을 연결하여 범위 검색이 빠르게 이루어지도록 한다.
            - 모든 데이터는 리프 노드에만 저장되므로, 내부 노드는 단지 탐색을 위한 키를 포함한다.
            - 리프 노드들이 **단방향 연결 리스트**로 연결되어 있어, 순차 접근이 가능하다.
        - **사용 예시)**
            - **데이터베이스 인덱스:** B+ 트리는 데이터베이스에서 **범위 쿼리**나 **순차 검색**을 최적화하는 데 사용된다.
            - **파일 시스템 인덱싱:** B+ 트리를 사용하여 파일 시스템에서 빠른 데이터 검색을 가능하게 한다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define MAX 3  // 최대 자식 노드 수
        
        // B+ 트리 노드 정의
        typedef struct Node {
            int keys[MAX];  // 키 배열
            struct Node* children[MAX + 1];  // 자식 노드 포인터 배열
            struct Node* next;  // 링크드 리스트로 연결된 다음 노드
            int n;  // 현재 키 수
            int leaf;  // 리프 노드 여부
        } Node;
        
        // 노드 생성 함수
        Node* createNode(int leaf) {
            Node* newNode = (Node*)malloc(sizeof(Node));
            newNode->leaf = leaf;
            newNode->n = 0;
            newNode->next = NULL;
            for (int i = 0; i < MAX + 1; i++) {
                newNode->children[i] = NULL;
            }
            return newNode;
        }
        
        // B+ 트리 삽입 함수
        void insert(Node** root, int key) {
            Node* r = *root;
            if (r->n == MAX) {  // 루트가 가득 차면 분할
                Node* newNode = createNode(0);
                newNode->children[0] = r;
                split(newNode, 0, r);
                *root = newNode;
            }
            insertNonFull(*root, key);
        }
        
        // B+ 트리 노드 분할 함수
        void split(Node* x, int i, Node* y) {
            Node* z = createNode(y->leaf);
            z->n = MAX / 2;
            for (int j = 0; j < MAX / 2; j++) {
                z->keys[j] = y->keys[j + MAX / 2 + 1];
            }
            if (!y->leaf) {
                for (int j = 0; j <= MAX / 2; j++) {
                    z->children[j] = y->children[j + MAX / 2 + 1];
                }
            }
            y->n = MAX / 2;
        
            for (int j = x->n; j > i; j--) {
                x->children[j + 1] = x->children[j];
            }
            x->children[i + 1] = z;
        
            for (int j = x->n - 1; j >= i; j--) {
                x->keys[j + 1] = x->keys[j];
            }
            x->keys[i] = y->keys[MAX / 2];
            x->n++;
        }
        
        // B+ 트리 노드에 키 삽입 (가득 차지 않았을 경우)
        void insertNonFull(Node* x, int key) {
            int i = x->n - 1;
            if (x->leaf) {
                while (i >= 0 && key < x->keys[i]) {
                    x->keys[i + 1] = x->keys[i];
                    i--;
                }
                x->keys[i + 1] = key;
                x->n++;
            } else {
                while (i >= 0 && key < x->keys[i]) {
                    i--;
                }
                i++;
                if (x->children[i]->n == MAX) {
                    split(x, i, x->children[i]);
                    if (key > x->keys[i]) {
                        i++;
                    }
                }
                insertNonFull(x->children[i], key);
            }
        }
        
        // B+ 트리 출력 함수
        void printTree(Node* root) {
            Node* current = root;
            while (current != NULL) {
                for (int i = 0; i < current->n; i++) {
                    printf("%d ", current->keys[i]);
                }
                printf("\n");
                current = current->next;
            }
        }
        
        int main() {
            Node* root = createNode(1);
            insert(&root, 10);
            insert(&root, 20);
            insert(&root, 5);
            insert(&root, 6);
            insert(&root, 15);
            insert(&root, 30);
        
            printTree(root);
            return 0;
        }
        ```
        
    - **B* 트리 (B* Tree)**
        - **설명:**
            - B* 트리는 B+ 트리에서 자식 노드의 분기를 **더 많이** 가지는 트리로, **트리의 높이를 더욱 낮추고, 트리의 분기를 효율적으로 조정**한다.
            - 이 방식은 성능 최적화를 위해 자식 노드의 수가 많아지도록 설계된다.
        - **동작 원리:**
            - B* 트리는 노드가 가득 차면 **분할**하지 않고 **형제 노드와 병합**하여 더 많은 자식을 가진 노드를 만든다.
            - 분할이 아닌 병합을 통해 트리의 균형을 유지하면서, 보다 효율적인 공간 활용과 I/O 성능을 보장한다.
            - 이 방식은 **더 많은 자식 노드**를 가지게 하여 트리의 깊이를 줄이고, 디스크 I/O 횟수를 최소화한다.
        - **사용 예시)**
            - **고성능 데이터베이스:** B* 트리는 높은 성능을 요구하는 데이터베이스에서 자주 사용된다. 대규모 데이터를 효율적으로 관리하는 데 유리하다.
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        #define MAX 3  // 최대 자식 노드 수
        #define MIN 2  // 최소 자식 노드 수
        
        // B* 트리 노드 정의
        typedef struct Node {
            int keys[MAX];  // 키 배열
            struct Node* children[MAX + 1];  // 자식 노드 포인터 배열
            int n;  // 현재 키 수
            int leaf;  // 리프 노드 여부
        } Node;
        
        // 노드 생성 함수
        Node* createNode(int leaf) {
            Node* newNode = (Node*)malloc(sizeof(Node));
            newNode->leaf = leaf;
            newNode->n = 0;
            for (int i = 0; i < MAX + 1; i++) {
                newNode->children[i] = NULL;
            }
            return newNode;
        }
        
        // B* 트리 삽입 함수
        void insert(Node** root, int key) {
            Node* r = *root;
            if (r->n == MAX) {  // 루트가 가득 차면 분할
                Node* newNode = creat
        ```
        

### 힙 (Heap)

완전 이진 트리 구조로, 우선순위 큐 등의 알고리즘에서 중요한 역할을 한다.

- **최대 힙 (Max-Heap):**
    - 부모 노드의 값이 자식 노드의 값보다 크며, 트리의 루트 노드는 가장 큰 값을 가진다.
    - **동작 원리**: 부모 노드는 자식 노드보다 항상 크며, 트리의 루트 노드는 가장 큰 값을 가진다. 삽입 시, 부모 노드와 자식 노드를 비교하여 힙 속성을 유지한다.
    - **사용 예시)** 우선순위 큐에서 큰 값부터 처리해야 할 때 사용된다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 100
    
    typedef struct {
        int data[MAX_SIZE];
        int size;
    } MaxHeap;
    
    // 부모, 왼쪽 자식, 오른쪽 자식 인덱스 계산
    int parent(int index) {
        return (index - 1) / 2;
    }
    
    int left_child(int index) {
        return 2 * index + 1;
    }
    
    int right_child(int index) {
        return 2 * index + 2;
    }
    
    // 힙 구조 초기화
    void init_heap(MaxHeap* heap) {
        heap->size = 0;
    }
    
    // 힙 삽입 연산 (Heapify-up)
    void insert(MaxHeap* heap, int value) {
        if (heap->size >= MAX_SIZE) {
            printf("Heap is full\n");
            return;
        }
    
        heap->data[heap->size] = value;
        int index = heap->size;
        heap->size++;
    
        // 부모 노드와 비교하여 올바른 위치로 삽입
        while (index > 0 && heap->data[parent(index)] < heap->data[index]) {
            // 부모와 자식 노드 교환
            int temp = heap->data[parent(index)];
            heap->data[parent(index)] = heap->data[index];
            heap->data[index] = temp;
    
            index = parent(index);
        }
    }
    
    // 힙 삭제 연산 (최대값 추출 및 Heapify-down)
    int extract_max(MaxHeap* heap) {
        if (heap->size == 0) {
            printf("Heap is empty\n");
            return -1;
        }
    
        int max = heap->data[0];
        heap->data[0] = heap->data[heap->size - 1];
        heap->size--;
    
        // Heapify-down
        int index = 0;
        while (left_child(index) < heap->size) {
            int left = left_child(index);
            int right = right_child(index);
            int largest = index;
    
            if (heap->data[left] > heap->data[largest]) {
                largest = left;
            }
    
            if (right < heap->size && heap->data[right] > heap->data[largest]) {
                largest = right;
            }
    
            if (largest != index) {
                // 부모와 자식 노드 교환
                int temp = heap->data[index];
                heap->data[index] = heap->data[largest];
                heap->data[largest] = temp;
                index = largest;
            } else {
                break;
            }
        }
    
        return max;
    }
    
    int main() {
        MaxHeap heap;
        init_heap(&heap);
    
        insert(&heap, 10);
        insert(&heap, 20);
        insert(&heap, 5);
    
        printf("Extracted Max: %d\n", extract_max(&heap));  // 출력: 20
        printf("Extracted Max: %d\n", extract_max(&heap));  // 출력: 10
    
        return 0;
    }
    ```
    
- **최소 힙 (Min-Heap):**
    - 부모 노드의 값이 자식 노드의 값보다 작으며, 트리의 루트 노드는 가장 작은 값을 가진다.
    - **동작 원리**: 부모 노드는 자식 노드보다 항상 작으며, 트리의 루트 노드는 가장 작은 값을 가진다. 삽입 시, 부모 노드와 자식 노드를 비교하여 힙 속성을 유지한다.
    - **사용 예시)** 우선순위 큐에서 작은 값부터 처리해야 할 때 사용된다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 100
    
    typedef struct {
        int data[MAX_SIZE];
        int size;
    } MinHeap;
    
    // 부모, 왼쪽 자식, 오른쪽 자식 인덱스 계산
    int parent(int index) {
        return (index - 1) / 2;
    }
    
    int left_child(int index) {
        return 2 * index + 1;
    }
    
    int right_child(int index) {
        return 2 * index + 2;
    }
    
    // 힙 구조 초기화
    void init_heap(MinHeap* heap) {
        heap->size = 0;
    }
    
    // 힙 삽입 연산 (Heapify-up)
    void insert(MinHeap* heap, int value) {
        if (heap->size >= MAX_SIZE) {
            printf("Heap is full\n");
            return;
        }
    
        heap->data[heap->size] = value;
        int index = heap->size;
        heap->size++;
    
        // 부모 노드와 비교하여 올바른 위치로 삽입
        while (index > 0 && heap->data[parent(index)] > heap->data[index]) {
            // 부모와 자식 노드 교환
            int temp = heap->data[parent(index)];
            heap->data[parent(index)] = heap->data[index];
            heap->data[index] = temp;
    
            index = parent(index);
        }
    }
    
    // 힙 삭제 연산 (최소값 추출 및 Heapify-down)
    int extract_min(MinHeap* heap) {
        if (heap->size == 0) {
            printf("Heap is empty\n");
            return -1;
        }
    
        int min = heap->data[0];
        heap->data[0] = heap->data[heap->size - 1];
        heap->size--;
    
        // Heapify-down
        int index = 0;
        while (left_child(index) < heap->size) {
            int left = left_child(index);
            int right = right_child(index);
            int smallest = index;
    
            if (heap->data[left] < heap->data[smallest]) {
                smallest = left;
            }
    
            if (right < heap->size && heap->data[right] < heap->data[smallest]) {
                smallest = right;
            }
    
            if (smallest != index) {
                // 부모와 자식 노드 교환
                int temp = heap->data[index];
                heap->data[index] = heap->data[smallest];
                heap->data[smallest] = temp;
                index = smallest;
            } else {
                break;
            }
        }
    
        return min;
    }
    
    int main() {
        MinHeap heap;
        init_heap(&heap);
    
        insert(&heap, 10);
        insert(&heap, 20);
        insert(&heap, 5);
    
        printf("Extracted Min: %d\n", extract_min(&heap));  // 출력: 5
        printf("Extracted Min: %d\n", extract_min(&heap));  // 출력: 10
    
        return 0;
    }
    ```
    
- **이진 힙 (Binary Heap)**
    - 최대 힙과 최소 힙의 일반적인 구현 방식이며, 완전 이진 트리 구조로 저장된다.
    - **사용 예시)** 우선순위 큐와 같이 높은 효율성을 요구하는 곳에서 사용된다.
- **피보나치 힙 (Fibonacci Heap)**
    - 다수의 트리를 묶어서 만든 힙으로, 연산에서 더 좋은 성능을 제공한다. 삽입, 합치기 연산은 매우 빠르다.
    - **사용 예시)** 최단 경로 알고리즘(Dijkstra, Prim)에서 사용된다.

### 분리 집합 (Disjoint Set)

트리 기반 자료구조로 합집합 연산과 원소 연결 여부를 확인하는 데 사용된다.

- **Union-Find 알고리즘**
    
    두 집합이 합쳐질 때 집합을 합치는 연산(Union)과 특정 원소가 속한 집합을 찾는 연산(Find)을 수행하는 자료구
    
    - **경로 압축**과 **크기 조정**을 통해 효율성을 높임
    - **사용 예시)** 네트워크 연결 문제, 최소 신장 트리(MST) 알고리즘(크루스칼 알고리즘 등)
- **경로 압축 및 크기 조정**
    - **경로 압축**: `Find` 연산에서 경로를 압축하여 재사용될 때 탐색 시간을 줄임.
    - **크기 조정**: 작은 트리를 큰 트리에 연결하여 트리의 높이를 최소화.
    
    ```c
    // Union-Find 알고리즘 구현 예시
    int find(int parent[], int x) {
        if (parent[x] != x)
            parent[x] = find(parent, parent[x]);  // 경로 압축
        return parent[x];
    }
    
    void unionSets(int parent[], int size[], int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        
        if (rootX != rootY) {
            // 크기 조정
            if (size[rootX] < size[rootY]) {
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }
    ```

## 그래프

노드 (Vertex)와 간선 (Edge)으로 구성된다. 간선은 두 노드를 연결하는 선으로, 노드들 간의 관계를 표현한다.

### 그래프 (Graph)

- **방향 그래프 (Directed Graph)**
    - 간선에 방향이 있는 그래프. 간선은 출발점과 도착점이 명확히 정의된다.
    - **사용 예시)** 웹 페이지 간 링크 관계, 트위터 팔로우 관계
- **무방향 그래프 (Undirected Graph)**
    - 간선에 방향이 없는 그래프. 두 노드는 상호 연결되어 있다.
    - **사용 예시)** 친구 관계, 도로 네트워크
- **가중 그래프 (Weighted Graph)**
    - 간선에 가중치(비용, 거리 등)가 부여된 그래프. 간선의 비용을 고려해야 할 때 사용된다.
    - **사용 예시)** 항공편의 비용, 도로의 거리
- **비가중 그래프 (Unweighted Graph)**
    - 간선에 가중치가 없는 그래프. 단순히 연결된 관계만을 나타낸다.
    - **사용 예시)** 통신 네트워크, 사람들 간의 친구 관계

### 그래프 표현 방식

그래프를 컴퓨터 메모리에 어떻게 표현할지에 대한 방식이다.

- **인접 행렬 (Adjacency Matrix)**
    - **동작 원리**: 2차원 배열로 그래프의 연결 관계를 나타낸다. `matrix[i][j]`가 1이면 노드 `i`와 `j`가 연결되어 있다는 뜻이다.
    - **장점**: 간선의 존재 여부를 빠르게 확인할 수 있다.
    - **단점**: 메모리 낭비가 크고, 간선 추가/삭제에 비효율적이다.
    - **사용 예시)** 노드가 적고 간선이 많을 때 유리하다.
    
    ```c
    #include <stdio.h>
    
    #define V 4 // 노드의 개수
    
    void printGraph(int graph[V][V]) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                printf("%d ", graph[i][j]);
            }
            printf("\n");
        }
    }
    
    int main() {
        int graph[V][V] = {
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 0}
        };
    
        printGraph(graph);
        return 0;
    }
    ```
    
- **인접 리스트 (Adjacency List)**
    - **동작 원리**: 각 노드는 연결된 노드를 리스트로 저장한다. 공간 효율성이 뛰어나며, 간선이 적을 때 유리하다.
    - **장점**: 메모리 효율성이 좋고 간선 추가/삭제가 빠르다.
    - **단점**: 간선 존재 여부 확인이 느리며, 인접 행렬보다 접근 시간이 더 길 수 있다.
    - **사용 예시)** 노드가 많고 간선이 적을 때 유리하다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define V 4 // 노드의 개수
    
    // 연결 리스트 노드 정의
    struct Node {
        int vertex;
        struct Node* next;
    };
    
    struct Graph {
        struct Node* adjLists[V]; // 각 노드의 인접 리스트
    };
    
    // 노드 생성
    struct Node* createNode(int v) {
        struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
        newNode->vertex = v;
        newNode->next = NULL;
        return newNode;
    }
    
    // 그래프 초기화
    void initGraph(struct Graph* graph) {
        for (int i = 0; i < V; i++) {
            graph->adjLists[i] = NULL;
        }
    }
    
    // 간선 추가
    void addEdge(struct Graph* graph, int src, int dest) {
        struct Node* newNode = createNode(dest);
        newNode->next = graph->adjLists[src];
        graph->adjLists[src] = newNode;
    
        newNode = createNode(src); // 무방향 그래프
        newNode->next = graph->adjLists[dest];
        graph->adjLists[dest] = newNode;
    }
    
    // 그래프 출력
    void printGraph(struct Graph* graph) {
        for (int i = 0; i < V; i++) {
            struct Node* temp = graph->adjLists[i];
            printf("노드 %d: ", i);
            while (temp) {
                printf("%d -> ", temp->vertex);
                temp = temp->next;
            }
            printf("NULL\n");
        }
    }
    
    int main() {
        struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
        initGraph(graph);
    
        addEdge(graph, 0, 1);
        addEdge(graph, 0, 3);
        addEdge(graph, 1, 2);
        addEdge(graph, 2, 3);
    
        printGraph(graph);
    
        return 0;
    }
    ```
    

### 그래프 순회

그래프를 탐색하는 방법

- **너비 우선 탐색 (Breadth-First Search, BFS)**
    - **특징**: 시작 노드에서 가까운 노드부터 차례로 탐색한다. 큐(Queue)를 사용하여 레벨별로 탐색한다.
    - **사용 예시)** 최단 경로 탐색, 네트워크 전파, 최단 시간 내에 목표를 찾는 문제
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define V 4
    #define MAX_QUEUE_SIZE 10
    
    int queue[MAX_QUEUE_SIZE];
    int front = -1, rear = -1;
    
    // 큐에 삽입
    void enqueue(int vertex) {
        if (rear == MAX_QUEUE_SIZE - 1) {
            printf("Queue Overflow\n");
            return;
        }
        if (front == -1) front = 0;
        queue[++rear] = vertex;
    }
    
    // 큐에서 삭제
    int dequeue() {
        if (front == -1) {
            printf("Queue Underflow\n");
            return -1;
        }
        int vertex = queue[front++];
        if (front > rear) front = rear = -1;
        return vertex;
    }
    
    // BFS 탐색
    void bfs(int graph[V][V], int start) {
        int visited[V] = {0};
        enqueue(start);
        visited[start] = 1;
    
        while (front != -1) {
            int current = dequeue();
            printf("%d ", current);
    
            for (int i = 0; i < V; i++) {
                if (graph[current][i] == 1 && !visited[i]) {
                    enqueue(i);
                    visited[i] = 1;
                }
            }
        }
    }
    
    int main() {
        int graph[V][V] = {
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 0}
        };
    
        bfs(graph, 0);  // 0번 노드부터 탐색 시작
        return 0;
    }
    ```
    
- **깊이 우선 탐색 (Depth-First Search, DFS)**
    - **특징**: 가능한 한 깊게 탐색한다. 스택(Stack)을 사용하여 경로를 따라가며 탐색한다.
    - **사용 예시)** 경로 찾기, 컴포넌트 분리, 미로 탐색
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define V 4
    
    // DFS 탐색
    void dfs(int graph[V][V], int visited[V], int vertex) {
        visited[vertex] = 1;
        printf("%d ", vertex);
    
        for (int i = 0; i < V; i++) {
            if (graph[vertex][i] == 1 && !visited[i]) {
                dfs(graph, visited, i);
            }
        }
    }
    
    int main() {
        int graph[V][V] = {
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 0}
        };
    
        int visited[V] = {0};
    
        dfs(graph, visited, 0);  // 0번 노드부터 탐색 시작
        return 0;
    }
    ```
    

### 최단 경로 알고리즘

- **다익스트라 알고리즘 (Dijkstra's Algorithm)**
    - **특징**: 가중치가 있는 그래프에서 한 노드에서 다른 노드로 가는 최단 경로를 찾는 알고리즘이다. **그리디 알고리즘**을 사용한다.
    - **사용 예시)** 네트워크 라우팅, 교통 네트워크에서 최단 경로 찾기
    - **동작 예시)** 한 노드에서 다른 노드로 가는 최단 경로 계산
        - 예를 들어, A에서 B까지 가는 최단 경로를 구할 때, 우선 A에서 가까운 노드를 탐색하고, 그 경로에서 가장 짧은 값을 계속 업데이트해 나간다.
    
    ```c
    #include <stdio.h>
    #include <limits.h>
    
    #define V 5 // 노드 개수
    
    int minDistance(int dist[], int sptSet[]) {
        int min = INT_MAX, min_index;
        for (int v = 0; v < V; v++) {
            if (sptSet[v] == 0 && dist[v] <= min) {
                min = dist[v];
                min_index = v;
            }
        }
        return min_index;
    }
    
    void dijkstra(int graph[V][V], int src) {
        int dist[V];
        int sptSet[V];
    
        for (int i = 0; i < V; i++) {
            dist[i] = INT_MAX;
            sptSet[i] = 0;
        }
    
        dist[src] = 0;
    
        for (int count = 0; count < V - 1; count++) {
            int u = minDistance(dist, sptSet);
            sptSet[u] = 1;
    
            for (int v = 0; v < V; v++) {
                if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
    
        printf("최단 거리: \n");
        for (int i = 0; i < V; i++) {
            printf("src -> %d: %d\n", i, dist[i]);
        }
    }
    
    int main() {
        int graph[V][V] = {
            {0, 10, 0, 0, 0},
            {10, 0, 20, 0, 0},
            {0, 20, 0, 10, 0},
            {0, 0, 10, 0, 10},
            {0, 0, 0, 10, 0}
        };
    
        dijkstra(graph, 0);  // 0번 노드에서 시작
        return 0;
    }
    
    ```
    
- **벨만-포드 알고리즘 (Bellman-Ford Algorithm)**
    - **특징**: 다익스트라와 비슷하지만, **음수 가중치**를 처리할 수 있다. 단, 음수 가중치가 존재하면 경로의 존재 여부를 확인할 수 있다.
    - **사용 예시)** 음수 가중치가 포함된 네트워크에서 최단 경로 찾기
    - **동작 예시)** 음수 가중치가 포함된 경로 탐색
        - 벨만-포드는 각 노드를 여러 번 반복하여 최단 경로를 구한다.
    
    ```c
    #include <stdio.h>
    #include <limits.h>
    
    #define V 5 // 노드 개수
    #define E 8 // 간선 개수
    
    typedef struct {
        int u, v, weight;
    } Edge;
    
    void bellmanFord(Edge edges[], int src) {
        int dist[V];
        for (int i = 0; i < V; i++) {
            dist[i] = INT_MAX;
        }
        dist[src] = 0;
    
        // V-1 번 반복
        for (int i = 0; i < V - 1; i++) {
            for (int j = 0; j < E; j++) {
                int u = edges[j].u;
                int v = edges[j].v;
                int weight = edges[j].weight;
                if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }
    
        // 음수 사이클 체크
        for (int i = 0; i < E; i++) {
            int u = edges[i].u;
            int v = edges[i].v;
            int weight = edges[i].weight;
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                printf("음수 가중치 사이클이 존재합니다.\n");
                return;
            }
        }
    
        // 최단 거리 출력
        printf("최단 거리: \n");
        for (int i = 0; i < V; i++) {
            printf("src -> %d: %d\n", i, dist[i]);
        }
    }
    
    int main() {
        Edge edges[] = {
            {0, 1, -1}, {0, 2, 4}, {1, 2, 3}, {1, 3, 2}, {1, 4, 2},
            {3, 1, 1}, {3, 2, 5}, {4, 3, -3}
        };
    
        bellmanFord(edges, 0);  // 0번 노드에서 시작
        return 0;
    }
    ```
    
- **플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)**
    - **특징**: 모든 노드 간의 최단 경로를 구할 수 있는 알고리즘이다. **동적 계획법**을 사용한다.
    - **사용 예시)** 모든 노드 간의 최단 경로를 구할 때 사용된다. 예를 들어, 전역 네트워크에서의 모든 경로를 분석할 때 유용하다.
    - **동작 예시)** 플로이드-워셜은 각 노드를 거쳐가는 경로를 고려하여 최단 경로를 계산한다.
    
    ```c
    #include <stdio.h>
    #include <limits.h>
    
    #define V 4 // 노드 개수
    
    void floydWarshall(int graph[V][V]) {
        int dist[V][V];
    
        // 그래프 초기화
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (i == j) dist[i][j] = 0;
                else if (graph[i][j] != 0) dist[i][j] = graph[i][j];
                else dist[i][j] = INT_MAX;
            }
        }
    
        // 동적 계획법을 사용하여 모든 최단 경로 계산
        for (int k = 0; k < V; k++) {
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
    
        // 최단 거리 출력
        printf("최단 거리 행렬: \n");
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][j] == INT_MAX) {
                    printf("INF ");
                } else {
                    printf("%d ", dist[i][j]);
                }
            }
            printf("\n");
        }
    }
    
    int main() {
        int graph[V][V] = {
            {0, 3, 0, 0},
            {3, 0, 1, 5},
            {0, 1, 0, 2},
            {0, 5, 2, 0}
        };
    
        floydWarshall(graph);  // 모든 노드 간의 최단 경로 계산
        return 0;
    }
    ```
    

### 최소 신장 트리 (Minimum Spanning Tree)

- **특징**: 모든 노드를 연결하는 간선의 가중치 합이 최소가 되도록 트리를 구성한다.
- **알고리즘**: **프림 알고리즘**, **크루스칼 알고리즘**
    - **프림 알고리즘 (Prim's Algorithm)**
        - **동작 원리**: 최소 가중치를 가진 간선을 계속 추가하여 트리를 구성합니다.
        
        ```c
        #include <stdio.h>
        #include <limits.h>
        
        #define V 5
        
        int minKey(int key[], int mstSet[]) {
            int min = INT_MAX, min_index;
            for (int v = 0; v < V; v++) {
                if (mstSet[v] == 0 && key[v] < min) {
                    min = key[v];
                    min_index = v;
                }
            }
            return min_index;
        }
        
        void prim(int graph[V][V]) {
            int parent[V];
            int key[V];
            int mstSet[V];
        
            for (int i = 0; i < V; i++) {
                key[i] = INT_MAX;
                mstSet[i] = 0;
            }
            key[0] = 0;
            parent[0] = -1;
        
            for (int count = 0; count < V - 1; count++) {
                int u = minKey(key, mstSet);
                mstSet[u] = 1;
        
                for (int v = 0; v < V; v++) {
                    if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
                        parent[v] = u;
                        key[v] = graph[u][v];
                    }
                }
            }
        
            printf("최소 신장 트리: \n");
            for (int i = 1; i < V; i++) {
                printf("%d - %d\n", parent[i], i);
            }
        }
        
        int main() {
            int graph[V][V] = {
                {0, 2, 0, 6, 0},
                {2, 0, 3, 8, 5},
                {0, 3, 0, 0, 7},
                {6, 8, 0, 0, 9},
                {0, 5, 7, 9, 0}
            };
        
            prim(graph);
            return 0;
        }
        ```
        
- **사용 예시)** 네트워크 설계, 전력망 설계

### 위상 정렬 (Topological Sorting)

- **동작 원리:**
    - 사이클이 없는 방향 그래프(DAG) 에서 각 노드를 일렬로 정렬하는 방법
    - 순서는 노드의 **종속성**에 따라 결정된다. 즉, 어떤 노드는 그 이전에 정렬된 노드들이 먼저 실행되어야 한다.
    - 위상 정렬을 수행하는 방법은 **진입 차수**(indegree)가 0인 노드를 선택하고, 그 노드에서 나가는 간선을 제거하는 방식이다.
    - 이 작업을 반복하여 모든 노드를 정렬한다.
- **사용 예시)** 작업 스케줄링, 종속성 처리

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 6

// 인접 리스트
int adj[MAX_NODES][MAX_NODES] = {
    {0, 1, 0, 0, 0, 0},
    {0, 0, 1, 0, 0, 0},
    {0, 0, 0, 1, 0, 0},
    {0, 0, 0, 0, 1, 0},
    {0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0}
};

// 진입 차수 계산
void topological_sort(int nodes) {
    int in_degree[MAX_NODES] = {0};  // 각 노드의 진입 차수
    int queue[MAX_NODES], front = 0, rear = 0;
    
    // 진입 차수 계산
    for (int i = 0; i < nodes; i++) {
        for (int j = 0; j < nodes; j++) {
            if (adj[i][j]) {
                in_degree[j]++;
            }
        }
    }

    // 진입 차수가 0인 노드를 큐에 넣기
    for (int i = 0; i < nodes; i++) {
        if (in_degree[i] == 0) {
            queue[rear++] = i;
        }
    }

    // 위상 정렬
    while (front < rear) {
        int node = queue[front++];
        printf("%d ", node);  // 현재 노드 출력

        for (int i = 0; i < nodes; i++) {
            if (adj[node][i]) {
                in_degree[i]--;
                if (in_degree[i] == 0) {
                    queue[rear++] = i;
                }
            }
        }
    }
}

int main() {
    printf("Topological Sort: ");
    topological_sort(MAX_NODES);
    return 0;
}
```

### 강결합 요소 탐색 (Strongly Connected Components)

- **동작 원리:**
    - 강결합 요소(SCC)는 그래프에서 모든 노드가 서로 도달 가능한 집합을 의미한다.
    - **Kosaraju의 알고리즘**을 사용하여 SCC를 찾을 수 있다. 이 알고리즘은 두 번의 DFS를 사용한다.
        1. 그래프를 순차적으로 탐색하여 후위 시간(DFS 완료 시간)에 따라 노드를 스택에 쌓는다.
        2. 그래프의 **역방향 그래프**를 만든 뒤, 스택에서 노드를 하나씩 꺼내며 그 노드를 시작으로 DFS를 다시 수행하여 SCC를 찾는다.
- **사용 예시)** 짝 지어진 작업을 할당하는 문제, 이분 매칭 문제

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 6

// 그래프의 인접 리스트
int adj[MAX_NODES][MAX_NODES] = {
    {0, 1, 0, 0, 0, 0},
    {0, 0, 1, 0, 0, 0},
    {0, 0, 0, 1, 0, 0},
    {0, 0, 0, 0, 1, 0},
    {0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0}
};

int visited[MAX_NODES];

// DFS 함수
void dfs(int node, int adj[MAX_NODES][MAX_NODES], int stack[MAX_NODES], int *top) {
    visited[node] = 1;
    for (int i = 0; i < MAX_NODES; i++) {
        if (adj[node][i] && !visited[i]) {
            dfs(i, adj, stack, top);
        }
    }
    stack[(*top)++] = node;  // 노드를 스택에 넣기
}

// 역방향 그래프 만들기
void reverse_graph(int adj[MAX_NODES][MAX_NODES], int rev_adj[MAX_NODES][MAX_NODES]) {
    for (int i = 0; i < MAX_NODES; i++) {
        for (int j = 0; j < MAX_NODES; j++) {
            rev_adj[j][i] = adj[i][j];  // 간선 방향을 반대로
        }
    }
}

// SCC 찾기
void find_scc(int adj[MAX_NODES][MAX_NODES]) {
    int stack[MAX_NODES], top = 0;
    int rev_adj[MAX_NODES][MAX_NODES];

    // 첫 번째 DFS로 스택 채우기
    for (int i = 0; i < MAX_NODES; i++) {
        visited[i] = 0;
    }
    for (int i = 0; i < MAX_NODES; i++) {
        if (!visited[i]) {
            dfs(i, adj, stack, &top);
        }
    }

    // 역방향 그래프 생성
    reverse_graph(adj, rev_adj);

    // 두 번째 DFS로 SCC 출력
    for (int i = 0; i < MAX_NODES; i++) {
        visited[i] = 0;
    }
    while (top > 0) {
        int node = stack[--top];
        if (!visited[node]) {
            printf("SCC: ");
            dfs(node, rev_adj, stack, &top);
            printf("\n");
        }
    }
}

int main() {
    find_scc(adj);
    return 0;
}
```

### 이분 그래프 탐색 (Bipartite Graph Check)

- **동작 원리:**
    - 이분 그래프란 그래프의 모든 노드를 두 개의 집합으로 나누고, 한 집합의 노드는 다른 집합의 노드와만 간선이 존재하는 그래프이다.
    - 이를 확인하려면 **BFS** 또는 **DFS**를 사용하여 각 노드를 두 개의 색으로 칠하는 방식으로 검사한다.
    - 인접한 노드들이 동일한 색으로 칠해지면 이분 그래프가 아니라고 판단할 수 있다.
- **사용 예시)** 소셜 네트워크에서 상호 연결된 그룹 찾기

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 6

// 인접 리스트 (그래프)
int adj[MAX_NODES][MAX_NODES] = {
    {0, 1, 0, 0, 0, 0},
    {1, 0, 1, 0, 0, 0},
    {0, 1, 0, 1, 0, 0},
    {0, 0, 1, 0, 1, 0},
    {0, 0, 0, 1, 0, 1},
    {0, 0, 0, 0, 1, 0}
};

int color[MAX_NODES];  // 각 노드의 색 (0: 방문 안함, 1: 색 1, 2: 색 2)

// BFS로 이분 그래프 체크
int is_bipartite(int nodes) {
    for (int i = 0; i < nodes; i++) {
        if (color[i] == 0) {  // 방문하지 않은 노드에 대해
            color[i] = 1;  // 색칠
            int queue[MAX_NODES], front = 0, rear = 0;
            queue[rear++] = i;

            while (front < rear) {
                int node = queue[front++];
                for (int j = 0; j < nodes; j++) {
                    if (adj[node][j]) {  // 연결된 노드가 있을 때
                        if (color[j] == 0) {  // 방문 안 한 노드
                            color[j] = (color[node] == 1) ? 2 : 1;
                            queue[rear++] = j;
                        } else if (color[j] == color[node]) {  // 색이 같으면 이분 그래프 아님
                            return 0;
                        }
                    }
                }
            }
        }
    }
    return 1;  // 이분 그래프
}

int main() {
    if (is_bipartite(MAX_NODES)) {
        printf("그래프는 이분 그래프입니다.\n");
    } else {
        printf("그래프는 이분 그래프가 아닙니다.\n");
    }
    return 0;
}
```

## 해시

### 해시 테이블 (Hash Table)

- **특징**: 키를 해시 함수에 입력하여 해시 값을 생성하고, 해당 해시 값을 기반으로 값을 저장하거나 검색하는 자료 구조이다. 평균적으로 O(1)의 시간 복잡도를 제공하지만, 충돌이 발생할 경우 성능이 저하될 수 있다.
- **사용 예시)** 데이터베이스 인덱싱, 캐시 구현, 집합 데이터 구조
- **동작 원리**: 키를 해시 함수에 전달하여 해시 값을 생성하고, 그 값을 인덱스로 사용하여 데이터를 저장한다. 검색 시, 키를 사용해 해시 값을 계산하여 해당 인덱스에서 데이터를 찾는다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 10

typedef struct {
    char key[100];
    int value;
} HashItem;

HashItem* hashTable[TABLE_SIZE];

unsigned int hashFunction(const char* key) {
    unsigned int hash = 0;
    for (int i = 0; key[i] != '\0'; i++) {
        hash = (hash * 31) + key[i];
    }
    return hash % TABLE_SIZE;
}

void insert(const char* key, int value) {
    unsigned int index = hashFunction(key);
    HashItem* newItem = (HashItem*)malloc(sizeof(HashItem));
    strcpy(newItem->key, key);
    newItem->value = value;
    hashTable[index] = newItem;
}

int search(const char* key) {
    unsigned int index = hashFunction(key);
    if (hashTable[index] != NULL) {
        return hashTable[index]->value;
    }
    return -1;  // 키를 찾을 수 없으면 -1 반환
}

int main() {
    insert("apple", 100);
    insert("banana", 200);
    printf("apple: %d\n", search("apple"));
    printf("banana: %d\n", search("banana"));
    return 0;
}
```

### 해시 함수 (Hash Function)

- **특징**: 입력 데이터를 고정된 크기의 값(해시 값)으로 변환하는 함수이다. 해시 함수의 목적은 입력값을 균등하게 분포시켜 충돌을 최소화하는 것이다.
- **특징**:
    - 입력 크기가 고정되지 않음
    - 가능한 한 서로 다른 입력에 대해 서로 다른 해시 값을 반환
- **사용 예시)** 해시 테이블에서 키의 인덱스를 계산할 때 사용된다.

```c
unsigned int hashFunction(const char* key) {
    unsigned int hash = 0;
    for (int i = 0; key[i] != '\0'; i++) {
        hash = (hash * 31) + key[i];  // 31은 소수로 자주 사용됨
    }
    return hash;
}
```

### 충돌 처리 (Collision Handling)

해시 테이블에서 두 개 이상의 키가 동일한 해시 값을 가질 경우, 충돌이 발생한다.

- **개방 주소법 (Open Addressing)**
    - **특징**: 충돌이 발생하면, 다른 인덱스를 찾아 데이터를 저장하는 방식이다. 일반적으로 **선형 탐사(linear probing)**, **제곱 탐사(quadratic probing)**, **이차 해싱(double hashing)** 등의 기법을 사용한다.
    - **사용 예시)** 해시 테이블에서 충돌을 처리하는 데 사용된다.
    
    ```c
    #define TABLE_SIZE 10
    
    typedef struct {
        char key[100];
        int value;
    } HashItem;
    
    HashItem* hashTable[TABLE_SIZE];
    
    unsigned int hashFunction(const char* key) {
        unsigned int hash = 0;
        for (int i = 0; key[i] != '\0'; i++) {
            hash = (hash * 31) + key[i];
        }
        return hash % TABLE_SIZE;
    }
    
    void insert(const char* key, int value) {
        unsigned int index = hashFunction(key);
        while (hashTable[index] != NULL) {
            index = (index + 1) % TABLE_SIZE;  // 선형 탐사
        }
        HashItem* newItem = (HashItem*)malloc(sizeof(HashItem));
        strcpy(newItem->key, key);
        newItem->value = value;
        hashTable[index] = newItem;
    }
    
    int search(const char* key) {
        unsigned int index = hashFunction(key);
        while (hashTable[index] != NULL) {
            if (strcmp(hashTable[index]->key, key) == 0) {
                return hashTable[index]->value;
            }
            index = (index + 1) % TABLE_SIZE;
        }
        return -1;  // 키를 찾을 수 없으면 -1 반환
    }
    ```
    
- **체이닝 (Chaining)**
    - **특징**: 각 해시 테이블의 버킷에 연결 리스트를 사용하여 충돌을 처리하는 방식이다. 하나의 버킷에 여러 개의 항목을 저장할 수 있다.
    - **사용 예시)** 충돌이 자주 발생하는 경우 효과적이다.
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    #define TABLE_SIZE 10
    
    typedef struct Node {
        char key[100];
        int value;
        struct Node* next;
    } Node;
    
    Node* hashTable[TABLE_SIZE];
    
    unsigned int hashFunction(const char* key) {
        unsigned int hash = 0;
        for (int i = 0; key[i] != '\0'; i++) {
            hash = (hash * 31) + key[i];
        }
        return hash % TABLE_SIZE;
    }
    
    void insert(const char* key, int value) {
        unsigned int index = hashFunction(key);
        Node* newNode = (Node*)malloc(sizeof(Node));
        strcpy(newNode->key, key);
        newNode->value = value;
        newNode->next = hashTable[index];
        hashTable[index] = newNode;
    }
    
    int search(const char* key) {
        unsigned int index = hashFunction(key);
        Node* current = hashTable[index];
        while (current != NULL) {
            if (strcmp(current->key, key) == 0) {
                return current->value;
            }
            current = current->next;
        }
        return -1;  // 키를 찾을 수 없으면 -1 반환
    }
    
    int main() {
        insert("apple", 100);
        insert("banana", 200);
        printf("apple: %d\n", search("apple"));
        printf("banana: %d\n", search("banana"));
        return 0;
    }
    ```
    

### 동적 크기 조정 (Dynamic Resizing)

- **특징**: 해시 테이블의 크기를 동적으로 조정하는 방식이다. 테이블이 꽉 차면 크기를 두 배로 늘리거나 재조정하여, 성능을 유지한다.
- **동작 원리**:
    - **테이블 크기 체크**: 원소가 테이블 크기의 일정 비율을 초과하면 크기를 두 배로 늘린다.
    - **재해싱**: 기존의 데이터를 새로운 크기의 테이블로 다시 해싱하여 저장한다.

```c
#define INITIAL_SIZE 10
#define LOAD_FACTOR 0.7

typedef struct {
    char key[100];
    int value;
} HashItem;

HashItem* hashTable[INITIAL_SIZE];
int tableSize = INITIAL_SIZE;
int itemCount = 0;

unsigned int hashFunction(const char* key) {
    unsigned int hash = 0;
    for (int i = 0; key[i] != '\0'; i++) {
        hash = (hash * 31) + key[i];
    }
    return hash % tableSize;
}

void resizeTable() {
    tableSize *= 2;
    HashItem* newTable[tableSize];
    memset(newTable, 0, sizeof(newTable));
    for (int i = 0; i < tableSize / 2; i++) {
        if (hashTable[i] != NULL) {
            int newIndex = hashFunction(hashTable[i]->key);
            newTable[newIndex] = hashTable[i];
        }
    }
    memcpy(hashTable, newTable, sizeof(newTable));
}

void insert(const char* key, int value) {
    if (itemCount >= tableSize * LOAD_FACTOR) {
        resizeTable();
    }
    unsigned int index = hashFunction(key);
    HashItem* newItem = (HashItem*)malloc(sizeof(HashItem));
    strcpy(newItem->key, key);
    newItem->value = value;
    hashTable[index] = newItem;
    itemCount++;
}

int main() {
    insert("apple", 100);
    insert("banana", 200);
    return 0;
}
```

### 블룸 필터 (Bloom Filter)

- **특징**: 효율적인 집합 구현을 위해 사용되는 확률적 자료 구조이다. 요소의 존재 여부를 빠르게 검사할 수 있지만, **false positive**가 발생할 수 있다. 즉, 존재하지 않는 요소가 존재한다고 잘못 판단할 수 있지만, 존재하는 요소는 항상 맞다.
- **동작 원리**
    - **해시 함수**: 여러 개의 해시 함수를 사용하여 데이터를 여러 인덱스로 변환한다.
    - **비트 배열**: 비트 배열을 사용하여 각 해시 함수에서 계산된 인덱스를 1로 설정한다.
    - **검색**: 검색할 원소에 대해 각 해시 함수를 적용하여 나온 모든 인덱스가 1이면 그 원소는 "존재한다고 판단"하고, 하나라도 0이면 "존재하지 않는다"고 판단한다.
- **사용 예시)** 대용량 데이터에서 존재 여부를 빠르게 확인할 때 사용된다. 예를 들어, 대규모 데이터베이스에서 검색을 최적화할 때 유용하다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define SIZE 1000  // 비트 배열 크기
#define HASH_COUNT 3  // 해시 함수 개수

unsigned char bloomFilter[SIZE] = {0};  // 비트 배열

// 해시 함수 1
unsigned int hash1(const char* str) {
    unsigned int hash = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * 31) + str[i];
    }
    return hash % SIZE;
}

// 해시 함수 2
unsigned int hash2(const char* str) {
    unsigned int hash = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * 17) + str[i];
    }
    return hash % SIZE;
}

// 해시 함수 3
unsigned int hash3(const char* str) {
    unsigned int hash = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * 7) + str[i];
    }
    return hash % SIZE;
}

// 원소 추가
void addToBloomFilter(const char* str) {
    bloomFilter[hash1(str)] = 1;
    bloomFilter[hash2(str)] = 1;
    bloomFilter[hash3(str)] = 1;
}

// 원소 존재 여부 확인
bool contains(const char* str) {
    if (bloomFilter[hash1(str)] == 0) return false;
    if (bloomFilter[hash2(str)] == 0) return false;
    if (bloomFilter[hash3(str)] == 0) return false;
    return true;  // 모두 1이라면 존재한다고 판단
}

int main() {
    addToBloomFilter("apple");
    addToBloomFilter("banana");

    if (contains("apple")) {
        printf("apple is possibly in the set.\n");
    } else {
        printf("apple is not in the set.\n");
    }

    if (contains("grape")) {
        printf("grape is possibly in the set.\n");
    } else {
        printf("grape is not in the set.\n");
    }

    return 0;
}
```
