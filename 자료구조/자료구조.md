# 자료구조

## 리스트

- **설명**: 데이터를 순서대로 저장하며, 크기를 동적으로 조정할 수 있는 선형 자료구조. 배열과 연결 리스트를 포함하는 상위 개념이다.
- **특징**:
    - 데이터가 순서대로 저장된다.
    - 중복 데이터를 허용한다.
    - 배열 기반 리스트는 랜덤 접근이 가능 (`O(1)`), 연결 리스트는 순차 접근이 필요 (`O(n)`).
- **사용 예시)**
    - 데이터를 순차적으로 저장하고 처리하는 일반적인 작업에 사용
    - 배열이나 연결 리스트를 기반으로 구현

### 배열 (Array)

고정 크기의 연속된 메모리 공간에 데이터를 저장하며, 빠른 랜덤 접근을 지원하는 자료구조다. 크기가 고정된 고정 배열과 크기를 동적으로 조정할 수 있는 동적 배열로 나뉜다.

- **고정 크기 배열 (Fixed-size Array)**
    - **특징:**
        - 크기가 고정되어 있다.
        - 데이터를 빠르게 읽고 쓸 수 있다. (`O(1)`)
        - 데이터 삽입/삭제가 비효율적이다. (`O(n)`)
    - **사용 예시)** 정적 데이터 구조 구현 (예: 행렬 계산, 월별 데이터 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        // 고정 크기 배열
        int array[SIZE] = {1, 2, 3, 4, 5};
        printf("고정 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", array[i]);
        }
        printf("\n");
        return 0;
    }
    ```
    
- **동적 배열 (Dynamic Array)**
    - **특징:**
        - 크기가 동적으로 조정된다.
        - 데이터 접근 속도가 빠르다.
        - 크기 초과 시 메모리 재할당 비용이 발생한다.
    - **사용 예시)** 동적으로 생성되는 데이터 처리 (예: 웹 로그 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        int *dynamic_array = (int *)malloc(SIZE * sizeof(int));
        for (int i = 0; i < SIZE; i++) {
            dynamic_array[i] = i + 1;
        }
        printf("동적 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", dynamic_array[i]);
        }
        printf("\n");
    
        free(dynamic_array); // 동적 메모리 해제
        return 0;
    }
    
    ```
    

### 연결 리스트 (Linked List)

데이터를 노드(Node)에 저장하고, 각 노드가 다음 노드를 가리키는 포인터를 통해 연결되는 동적 자료구조다.

- **특징**
    - 크기가 동적으로 조정된다.
    - 배열보다 삽입/삭제가 효율적이다. (`O(1)` - 리스트 앞에서 삽입/삭제 시)
    - 임의의 요소 접근은 비효율적이다. (`O(n)`)
- **단일 연결 리스트 (Singly-Linked List)**
    - **설명**: 각 노드가 데이터와 다음 노드의 포인터를 포함하며 한 방향으로만 연결된다.
    - **사용 예시)**
        - 메모리 제약이 있는 환경에서 데이터 저장
        - 스택과 같은 간단한 자료구조 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }
    
    // 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d -> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("단일 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **이중 연결 리스트 (Doubly-Linked List)**
    - **설명**: 각 노드가 이전 노드와 다음 노드의 포인터를 포함하며 양방향으로 연결된다.
    - **사용 예시)**
        - Undo/Redo 기능 구현
        - LRU 캐시 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *prev;
        struct Node *next;
    } Node;
    
    // 이중 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->prev = NULL;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
        new_node->prev = current;
    }
    
    // 이중 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d <-> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("이중 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **원형 연결 리스트 (Circular-Linked List)**
    - **설명**: 마지막 노드가 첫 번째 노드를 가리키며 순환 구조를 형성하는 리스트.
    - **사용 예시)**
        - 프로세스 스케줄링 (라운드로빈 방식)
        - 게임의 턴 제어 시스템
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 원형 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            new_node->next = *head;
            return;
        }
    
        Node *current = *head;
        while (current->next != *head) {
            current = current->next;
        }
        current->next = new_node;
        new_node->next = *head;
    }
    
    // 원형 연결 리스트 출력
    void display(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        do {
            printf("%d -> ", current->data);
            current = current->next;
        } while (current != head);
        printf("(head)\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        Node *next_node;
        do {
            next_node = current->next;
            free(current);
            current = next_node;
        } while (current != head);
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("원형 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **다중 연결 리스트 (Multi-Linked List)**
    - **설명:** 하나의 노드가 여러 개의 연결을 가질 수 있는 구조로, 각 노드가 여러 방향으로 연결될 수 있다. 각 노드에 다수의 포인터를 가지며, 특정 데이터를 여러 개의 연결 구조로 표현할 수 있도록 한다.
    - **사용 예시)**
        - **그래프 표현**: 방향 그래프와 비방향 그래프의 인접 리스트 표현
        - **2차원 배열 동적 구현**: 동적 메모리를 사용하여 2D 배열을 구현
        - **데이터 관계 관리**: 데이터베이스와 같이 한 데이터가 여러 데이터와 관계를 가질 때
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *right; // 오른쪽 노드
        struct Node *down;  // 아래쪽 노드
    } Node;
    
    // 새 노드 생성
    Node* create_node(int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->right = NULL;
        new_node->down = NULL;
        return new_node;
    }
    
    // 다중 연결 리스트 생성 (2차원 배열과 유사)
    Node* create_multi_linked_list(int rows, int cols) {
        Node *head = NULL;
        Node *row_head = NULL;
        Node *prev_row = NULL;
    
        for (int i = 0; i < rows; i++) {
            Node *prev_col = NULL;
    
            for (int j = 0; j < cols; j++) {
                Node *new_node = create_node(i * cols + j + 1); // 노드에 값 삽입
    
                if (j == 0) {
                    if (head == NULL) {
                        head = new_node;
                    } else {
                        row_head->down = new_node;
                    }
                    row_head = new_node;
                }
    
                if (prev_col != NULL) {
                    prev_col->right = new_node;
                }
    
                if (prev_row != NULL && prev_row->right != NULL) {
                    prev_row->right->down = new_node;
                    prev_row = prev_row->right;
                }
    
                prev_col = new_node;
            }
    
            prev_row = row_head;
        }
    
        return head;
    }
    
    // 다중 연결 리스트 출력
    void display_multi_linked_list(Node *head) {
        Node *row = head;
    
        while (row != NULL) {
            Node *col = row;
            while (col != NULL) {
                printf("%d ", col->data);
                col = col->right;
            }
            printf("\n");
            row = row->down;
        }
    }
    
    // 메모리 해제
    void free_multi_linked_list(Node *head) {
        Node *row = head;
        while (row != NULL) {
            Node *col = row;
            Node *next_row = row->down;
    
            while (col != NULL) {
                Node *next_col = col->right;
                free(col);
                col = next_col;
            }
    
            row = next_row;
        }
    }
    
    int main() {
        int rows = 3, cols = 4;
    
        Node *head = create_multi_linked_list(rows, cols);
    
        printf("다중 연결 리스트 출력:\n");
        display_multi_linked_list(head);
    
        free_multi_linked_list(head);
    
        return 0;
    }
    ```
