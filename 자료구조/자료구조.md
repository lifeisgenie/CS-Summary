# 자료구조

## 리스트

- **설명**: 데이터를 순서대로 저장하며, 크기를 동적으로 조정할 수 있는 선형 자료구조. 배열과 연결 리스트를 포함하는 상위 개념이다.
- **특징**:
    - 데이터가 순서대로 저장된다.
    - 중복 데이터를 허용한다.
    - 배열 기반 리스트는 랜덤 접근이 가능 (`O(1)`), 연결 리스트는 순차 접근이 필요 (`O(n)`).
- **사용 예시)**
    - 데이터를 순차적으로 저장하고 처리하는 일반적인 작업에 사용
    - 배열이나 연결 리스트를 기반으로 구현

### 배열 (Array)

고정 크기의 연속된 메모리 공간에 데이터를 저장하며, 빠른 랜덤 접근을 지원하는 자료구조다. 크기가 고정된 고정 배열과 크기를 동적으로 조정할 수 있는 동적 배열로 나뉜다.

- **고정 크기 배열 (Fixed-size Array)**
    - **특징:**
        - 크기가 고정되어 있다.
        - 데이터를 빠르게 읽고 쓸 수 있다. (`O(1)`)
        - 데이터 삽입/삭제가 비효율적이다. (`O(n)`)
    - **사용 예시)** 정적 데이터 구조 구현 (예: 행렬 계산, 월별 데이터 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        // 고정 크기 배열
        int array[SIZE] = {1, 2, 3, 4, 5};
        printf("고정 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", array[i]);
        }
        printf("\n");
        return 0;
    }
    ```
    
- **동적 배열 (Dynamic Array)**
    - **특징:**
        - 크기가 동적으로 조정된다.
        - 데이터 접근 속도가 빠르다.
        - 크기 초과 시 메모리 재할당 비용이 발생한다.
    - **사용 예시)** 동적으로 생성되는 데이터 처리 (예: 웹 로그 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        int *dynamic_array = (int *)malloc(SIZE * sizeof(int));
        for (int i = 0; i < SIZE; i++) {
            dynamic_array[i] = i + 1;
        }
        printf("동적 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", dynamic_array[i]);
        }
        printf("\n");
    
        free(dynamic_array); // 동적 메모리 해제
        return 0;
    }
    
    ```
    

### 연결 리스트 (Linked List)

데이터를 노드(Node)에 저장하고, 각 노드가 다음 노드를 가리키는 포인터를 통해 연결되는 동적 자료구조다.

- **특징**
    - 크기가 동적으로 조정된다.
    - 배열보다 삽입/삭제가 효율적이다. (`O(1)` - 리스트 앞에서 삽입/삭제 시)
    - 임의의 요소 접근은 비효율적이다. (`O(n)`)
- **단일 연결 리스트 (Singly-Linked List)**
    - **설명**: 각 노드가 데이터와 다음 노드의 포인터를 포함하며 한 방향으로만 연결된다.
    - **사용 예시)**
        - 메모리 제약이 있는 환경에서 데이터 저장
        - 스택과 같은 간단한 자료구조 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }
    
    // 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d -> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("단일 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **이중 연결 리스트 (Doubly-Linked List)**
    - **설명**: 각 노드가 이전 노드와 다음 노드의 포인터를 포함하며 양방향으로 연결된다.
    - **사용 예시)**
        - Undo/Redo 기능 구현
        - LRU 캐시 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *prev;
        struct Node *next;
    } Node;
    
    // 이중 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->prev = NULL;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
        new_node->prev = current;
    }
    
    // 이중 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d <-> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("이중 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **원형 연결 리스트 (Circular-Linked List)**
    - **설명**: 마지막 노드가 첫 번째 노드를 가리키며 순환 구조를 형성하는 리스트.
    - **사용 예시)**
        - 프로세스 스케줄링 (라운드로빈 방식)
        - 게임의 턴 제어 시스템
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 원형 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            new_node->next = *head;
            return;
        }
    
        Node *current = *head;
        while (current->next != *head) {
            current = current->next;
        }
        current->next = new_node;
        new_node->next = *head;
    }
    
    // 원형 연결 리스트 출력
    void display(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        do {
            printf("%d -> ", current->data);
            current = current->next;
        } while (current != head);
        printf("(head)\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        Node *next_node;
        do {
            next_node = current->next;
            free(current);
            current = next_node;
        } while (current != head);
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("원형 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **다중 연결 리스트 (Multi-Linked List)**
    - **설명:** 하나의 노드가 여러 개의 연결을 가질 수 있는 구조로, 각 노드가 여러 방향으로 연결될 수 있다. 각 노드에 다수의 포인터를 가지며, 특정 데이터를 여러 개의 연결 구조로 표현할 수 있도록 한다.
    - **사용 예시)**
        - **그래프 표현**: 방향 그래프와 비방향 그래프의 인접 리스트 표현
        - **2차원 배열 동적 구현**: 동적 메모리를 사용하여 2D 배열을 구현
        - **데이터 관계 관리**: 데이터베이스와 같이 한 데이터가 여러 데이터와 관계를 가질 때
    
   ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *right; // 오른쪽 노드
        struct Node *down;  // 아래쪽 노드
    } Node;
    
    // 새 노드 생성
    Node* create_node(int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->right = NULL;
        new_node->down = NULL;
        return new_node;
    }
    
    // 다중 연결 리스트 생성 (2차원 배열과 유사)
    Node* create_multi_linked_list(int rows, int cols) {
        Node *head = NULL;
        Node *row_head = NULL;
        Node *prev_row = NULL;
    
        for (int i = 0; i < rows; i++) {
            Node *prev_col = NULL;
    
            for (int j = 0; j < cols; j++) {
                Node *new_node = create_node(i * cols + j + 1); // 노드에 값 삽입
    
                if (j == 0) {
                    if (head == NULL) {
                        head = new_node;
                    } else {
                        row_head->down = new_node;
                    }
                    row_head = new_node;
                }
    
                if (prev_col != NULL) {
                    prev_col->right = new_node;
                }
    
                if (prev_row != NULL && prev_row->right != NULL) {
                    prev_row->right->down = new_node;
                    prev_row = prev_row->right;
                }
    
                prev_col = new_node;
            }
    
            prev_row = row_head;
        }
    
        return head;
    }
    
    // 다중 연결 리스트 출력
    void display_multi_linked_list(Node *head) {
        Node *row = head;
    
        while (row != NULL) {
            Node *col = row;
            while (col != NULL) {
                printf("%d ", col->data);
                col = col->right;
            }
            printf("\n");
            row = row->down;
        }
    }
    
    // 메모리 해제
    void free_multi_linked_list(Node *head) {
        Node *row = head;
        while (row != NULL) {
            Node *col = row;
            Node *next_row = row->down;
    
            while (col != NULL) {
                Node *next_col = col->right;
                free(col);
                col = next_col;
            }
    
            row = next_row;
        }
    }
    
    int main() {
        int rows = 3, cols = 4;
    
        Node *head = create_multi_linked_list(rows, cols);
    
        printf("다중 연결 리스트 출력:\n");
        display_multi_linked_list(head);
    
        free_multi_linked_list(head);
    
        return 0;
    }
    
    // 출력 결과:
    다중 연결 리스트 출력:
    1 2 3 4
    5 6 7 8
    9 10 11 12
    ```

## 스택(Stack)

**LIFO (Last In, First Out)** 구조를 가진 자료구조로, 가장 마지막에 삽입된 데이터가 가장 먼저 제거되는 후입선출이다. 스택은 한쪽 끝에서만 데이터의 삽입과 삭제가 이루어진다.

- **동작 원리**
    - **Push (삽입)**: 데이터를 스택의 최상단(top)에 추가한다.
    - **Pop (삭제)**: 스택의 최상단(top) 데이터를 제거하고 반환한다.
    - **Peek/Top (조회)**: 데이터를 제거하지 않고 스택의 최상단 데이터를 반환한다.
    - **Empty (비었는지 확인)**: 스택에 데이터가 없는지 확인한다.
- **장단점**
    - **장점**
        - 삽입과 삭제 연산이 O(1)로 매우 빠르다.
        - 데이터 순서를 추적하는 데 효과적이다.
    - **단점**
        - 배열 기반 스택은 크기가 고정되어 있어 크기를 초과하면 재할당이 필요하다.
        - 연결 리스트 기반 스택은 포인터를 위한 추가 메모리가 필요하다.
- **사용 예시)**
    - **재귀 함수 처리**: 함수 호출 스택 관리.
    - **괄호 검사**: 수식의 괄호 균형 체크.
    - **역순 작업**: 문자열 뒤집기, 역순 데이터 처리.
    - **웹 브라우저 뒤로 가기/앞으로 가기**: 이전 페이지로 돌아가기.
    - **운영 체제**: 실행 중인 프로세스 관리 (스택 메모리).

### 배열 기반 스택 (Array-based Stack)

배열을 사용하여 스택을 구현하며, 고정된 크기를 사용하거나 동적 크기로 구현 가능하다. 배열의 마지막 요소가 스택의 최상단(top)을 나타낸다.

- **동작 방식**
    - 배열을 이용해 데이터를 선형적으로 저장한다.
    - 배열의 마지막 요소가 스택의 최상단을 나타낸다.
    - 크기를 초과할 경우, 새 배열을 할당해 복사해야 한다.
- **원리**
    - 데이터 삽입 시 `top`을 증가시키고, 해당 위치에 데이터를 저장한다.
    - 데이터 삭제 시 `top`의 데이터를 반환하고 감소시킨다.
- **사용 예시)**
    - 데이터 크기가 고정되어 있을 때 (e.g., 정해진 크기의 명령 처리).
    - 작은 규모의 데이터를 관리할 때 메모리와 성능 효율적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100 // 스택의 최대 크기

typedef struct {
    int data[MAX_SIZE];
    int top; // 스택의 최상단을 나타냄
} Stack;

// 스택 초기화
void init_stack(Stack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(Stack *stack) {
    return stack->top == -1;
}

// 스택이 가득 찼는지 확인
int is_full(Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

// 스택에 데이터 삽입
void push(Stack *stack, int value) {
    if (is_full(stack)) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;
}

// 스택에서 데이터 삭제 및 반환
int pop(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택 최상단 데이터 반환
int peek(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->data[stack->top];
}

int main() {
    Stack stack;
    init_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 연결 리스트 기반 스택 (Linked List-based Stack)

동적 메모리를 사용해 연결 리스트로 스택을 구현하며, 스택의 최상단(top)은 리스트의 헤드 노드로 표현된다.

- **동작 방식**
    - 각 노드가 데이터를 저장하며, 스택의 최상단은 연결 리스트의 첫 번째 노드를 나타낸다.
    - 동적 메모리를 사용하여 삽입과 삭제를 수행한다.
- **원리**
    - 데이터 삽입 시 새 노드를 생성하고, 기존 최상단을 새 노드의 `next`로 연결한다.
    - 데이터 삭제 시 최상단 노드를 제거하고 `next` 노드를 새로운 최상단으로 설정한다.
- **사용 예시)**
    - 데이터 크기가 가변적이고 동적 메모리 사용이 필요할 때.
    - 메모리 제약 없이 데이터 삽입/삭제가 필요한 경우.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 스택 초기화
Node* create_stack() {
    return NULL; // 초기 스택은 NULL
}

// 스택에 데이터 삽입
void push(Node **top, int value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = value;
    new_node->next = *top;
    *top = new_node;
}

// 스택에서 데이터 삭제 및 반환
int pop(Node **top) {
    if (*top == NULL) {
        printf("스택 언더플로우\n");
        return -1;
    }
    Node *temp = *top;
    int value = temp->data;
    *top = (*top)->next;
    free(temp);
    return value;
}

// 스택 최상단 데이터 반환
int peek(Node *top) {
    if (top == NULL) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return top->data;
}

int main() {
    Node *stack = create_stack();

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 최소값/최대값 추적 스택 (Min/Max Stack)

스택에서 데이터를 삽입/삭제하는 동안 최소값 또는 최대값을 추적한다. 보조 스택을 사용하여 이를 구현하며, 각 연산이 O(1)로 작동한다.

- **동작 방식**
    - 기본 스택과 보조 스택을 사용한다.
    - 데이터를 삽입할 때, 보조 스택에 최소값 또는 최대값을 업데이트하며 저장한다.
    - 데이터를 삭제할 때, 보조 스택에서도 값을 제거한다.
- **원리**
    - 데이터 삽입 시 기존의 최소값/최대값과 비교하여 보조 스택을 갱신한다.
    - 최솟값/최댓값 확인 시 보조 스택의 최상단을 반환한다.
- **사용 예시)**
    - 실시간으로 데이터의 최솟값/최댓값을 확인해야 하는 경우.
    - 예: 주식 가격의 실시간 추적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int min[MAX_SIZE];
    int top;
} MinStack;

// 스택 초기화
void init_min_stack(MinStack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(MinStack *stack) {
    return stack->top == -1;
}

// 스택에 데이터 삽입
void push(MinStack *stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;

    // 최소값 추적
    if (stack->top == 0) {
        stack->min[stack->top] = value;
    } else {
        stack->min[stack->top] = (value < stack->min[stack->top - 1]) ? value : stack->min[stack->top - 1];
    }
}

// 스택에서 데이터 삭제 및 반환
int pop(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택에서 최솟값 반환
int get_min(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->min[stack->top];
}

int main() {
    MinStack stack;
    init_min_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 5);
    push(&stack, 30);

    printf("Min: %d\n", get_min(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Min: %d\n", get_min(&stack));

    return 0;
}
```

## 큐(Queue)

**FIFO (First In, First Out)**구조를 가진 자료구조로, 주로 한쪽 끝에서 삽입하고 다른 한쪽 끝에서 삭제한다.

- **연산**
    - **Enqueue(삽입):** 데이터를 큐의 끝에 추가.
    - **Dequeue(삭제):** 데이터를 큐의 앞에서 제거하고 반환.
    - **Peek(참조):** 큐의 맨 앞 데이터를 제거하지 않고 반환.
- **원리**
    
    큐는 두 개의 포인터를 사용해 구현된다:
    
    - **Front:** 큐의 첫 번째 요소를 가리킴 (삭제 작업에서 사용).
    - **Rear:** 큐의 마지막 요소를 가리킴 (삽입 작업에서 사용).데이터는 **Front → Rear** 방향으로 이동한다.큐가 가득 차거나 비었는지 확인하기 위해 크기와 포인터 위치를 비교한다.
- **사용 예시)**
    - **프로세스 스케줄링**: CPU 스케줄링, 작업 대기열 관리.
    - **데이터 버퍼**: 프린터 스풀러, 네트워크 패킷 관리.
    - **실시간 요청 처리**: 작업 큐, 프로세스 관리.
    - **그래프 탐색**: BFS(너비 우선 탐색) 구현.

### 배열 기반 큐 (Array-based Queue)

배열을 사용해 큐를 구현하며, 크기가 고정되어 메모리를 효율적으로 사용하지만 큐가 가득 찼을 때 더 이상 삽입할 수 없다.

- **장단점**
    - **장점:** 구현이 간단하고, 특정 크기의 데이터 처리에 적합
    - **단점:** 삽입과 삭제 작업이 비효율적(연산에 O(n) 필요). 삭제 연산 시 모든 요소를 한 칸씩 이동해야 한다.
- **사용 예시)**
    - 고정된 크기의 데이터 처리 (e.g., 제한된 요청 큐).
    - 간단한 큐 연산이 필요한 작업.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

// 큐 초기화
void init_queue(Queue *queue) {
    queue->front = 0;
    queue->rear = -1;
}

// 큐가 비었는지 확인
int is_empty(Queue *queue) {
    return queue->rear < queue->front;
}

// 큐가 가득 찼는지 확인
int is_full(Queue *queue) {
    return queue->rear == MAX_SIZE - 1;
}

// 큐에 데이터 삽입
void enqueue(Queue *queue, int value) {
    if (is_full(queue)) {
        printf("큐 오버플로우\n");
        return;
    }
    queue->data[++queue->rear] = value;
}

// 큐에서 데이터 삭제 및 반환
int dequeue(Queue *queue) {
    if (is_empty(queue)) {
        printf("큐 언더플로우\n");
        return -1;
    }
    return queue->data[queue->front++];
}

// 큐의 첫 번째 데이터 반환
int peek(Queue *queue) {
    if (is_empty(queue)) {
        printf("큐가 비어 있습니다.\n");
        return -1;
    }
    return queue->data[queue->front];
}

int main() {
    Queue queue;
    init_queue(&queue);

    enqueue(&queue, 10);
    enqueue(&queue, 20);
    enqueue(&queue, 30);

    printf("Peek: %d\n", peek(&queue));
    printf("Dequeue: %d\n", dequeue(&queue));
    printf("Dequeue: %d\n", dequeue(&queue));

    return 0;
}

```

### 순환 큐 (Circular Queue)

배열의 끝이 처음과 연결되어 원형 형태를 만든다.

- **Mod 연산**을 사용해 삽입과 삭제 위치를 계산:
    - `(Rear + 1) % 큐 크기`: 다음 삽입 위치
    - `(Front + 1) % 큐 크기`: 다음 삭제 위치
- **장단점**
    - **장점:** 메모리 낭비가 적고 삭제 시 데이터 이동할 필요 없다
    - **단점:** 구현이 복잡하며 동적 크기 지원이 어렵다
- **사용 예시)**
    - 라운드 로빈 방식의 CPU 스케줄링
    - 제한된 메모리에서 데이터 순환 처리

### 연결 리스트 기반 큐 (Linked List-based Queue)

동적 메모리를 사용해 연결 리스트로 큐를 구현하며, 각 노드는 데이터를 저장하고 다음 노드를 가리키는 포인터를 포함한다.

- **동작 원리**
    - 삽입은 Rear 노드 뒤에서 수행
    - 삭제는 Front 노드에서 수행
- **장단점**
    - **장점:** 크기 제한이 없으며 동적 메모리 할당이 가능
    - **단점:** 추가적인 포인터 저장 공간 필요, 메모리 관리 복잡
- **사용 예시**
    - 크기 제한이 없는 데이터 스트림 처리
    - 동적 데이터 구조가 필요한 네트워크 패킷 처리

### 우선순위 큐 (Priority Queue)

각 데이터에 우선순위를 부여하여 높은 우선순위를 가진 데이터가 먼저 처리된다.

- **장단점**
    - **장점:** 우선순위가 있는 작업 처리에 적합
    - **단점:** 배열 기반은 삽입/삭제 시 O(n), 힙 기반은 O(log n) 필요
- **사용 예시)**
    - 작업 스케줄링 (가장 중요한 작업을 먼저 실행)
    - Dijkstra 알고리즘과 같은 그래프 최단 경로 계산
- **배열 기반 우선순위 큐:** 정렬된 배열을 사용
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 100
    
    typedef struct {
        int data[MAX_SIZE];
        int front;
        int rear;
    } Queue;
    
    void init_queue(Queue *queue) {
        queue->front = 0;
        queue->rear = -1;
    }
    
    int is_empty(Queue *queue) {
        return queue->rear < queue->front;
    }
    
    int is_full(Queue *queue) {
        return queue->rear == MAX_SIZE - 1;
    }
    
    void enqueue(Queue *queue, int value) {
        if (is_full(queue)) {
            printf("큐 오버플로우\n");
            return;
        }
        queue->data[++queue->rear] = value;
    }
    
    int dequeue(Queue *queue) {
        if (is_empty(queue)) {
            printf("큐 언더플로우\n");
            return -1;
        }
        return queue->data[queue->front++];
    }
    
    int peek(Queue *queue) {
        if (is_empty(queue)) {
            printf("큐가 비어 있습니다.\n");
            return -1;
        }
        return queue->data[queue->front];
    }
    
    int main() {
        Queue queue;
        init_queue(&queue);
    
        enqueue(&queue, 10);
        enqueue(&queue, 20);
        enqueue(&queue, 30);
    
        printf("Peek: %d\n", peek(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
    
        return 0;
    }
    ```
    
- **힙 기반 우선순위 큐:** 최소 힙 또는 최대 힙을 사용해 우선순위를 효율적으로 관리
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    #define MAX_SIZE 5
    
    typedef struct {
        int data[MAX_SIZE];
        int front;
        int rear;
    } CircularQueue;
    
    void init_queue(CircularQueue *queue) {
        queue->front = 0;
        queue->rear = 0;
    }
    
    int is_empty(CircularQueue *queue) {
        return queue->front == queue->rear;
    }
    
    int is_full(CircularQueue *queue) {
        return (queue->rear + 1) % MAX_SIZE == queue->front;
    }
    
    void enqueue(CircularQueue *queue, int value) {
        if (is_full(queue)) {
            printf("큐 오버플로우\n");
            return;
        }
        queue->data[queue->rear] = value;
        queue->rear = (queue->rear + 1) % MAX_SIZE;
    }
    
    int dequeue(CircularQueue *queue) {
        if (is_empty(queue)) {
            printf("큐 언더플로우\n");
            return -1;
        }
        int value = queue->data[queue->front];
        queue->front = (queue->front + 1) % MAX_SIZE;
        return value;
    }
    
    int peek(CircularQueue *queue) {
        if (is_empty(queue)) {
            printf("큐가 비어 있습니다.\n");
            return -1;
        }
        return queue->data[queue->front];
    }
    
    int main() {
        CircularQueue queue;
        init_queue(&queue);
    
        enqueue(&queue, 10);
        enqueue(&queue, 20);
        enqueue(&queue, 30);
    
        printf("Peek: %d\n", peek(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
        printf("Dequeue: %d\n", dequeue(&queue));
    
        return 0;
    }
    ```
