# 자료구조

## 리스트

- **설명**: 데이터를 순서대로 저장하며, 크기를 동적으로 조정할 수 있는 선형 자료구조. 배열과 연결 리스트를 포함하는 상위 개념이다.
- **특징**:
    - 데이터가 순서대로 저장된다.
    - 중복 데이터를 허용한다.
    - 배열 기반 리스트는 랜덤 접근이 가능 (`O(1)`), 연결 리스트는 순차 접근이 필요 (`O(n)`).
- **사용 예시)**
    - 데이터를 순차적으로 저장하고 처리하는 일반적인 작업에 사용
    - 배열이나 연결 리스트를 기반으로 구현

### 배열 (Array)

고정 크기의 연속된 메모리 공간에 데이터를 저장하며, 빠른 랜덤 접근을 지원하는 자료구조다. 크기가 고정된 고정 배열과 크기를 동적으로 조정할 수 있는 동적 배열로 나뉜다.

- **고정 크기 배열 (Fixed-size Array)**
    - **특징:**
        - 크기가 고정되어 있다.
        - 데이터를 빠르게 읽고 쓸 수 있다. (`O(1)`)
        - 데이터 삽입/삭제가 비효율적이다. (`O(n)`)
    - **사용 예시)** 정적 데이터 구조 구현 (예: 행렬 계산, 월별 데이터 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        // 고정 크기 배열
        int array[SIZE] = {1, 2, 3, 4, 5};
        printf("고정 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", array[i]);
        }
        printf("\n");
        return 0;
    }
    ```
    
- **동적 배열 (Dynamic Array)**
    - **특징:**
        - 크기가 동적으로 조정된다.
        - 데이터 접근 속도가 빠르다.
        - 크기 초과 시 메모리 재할당 비용이 발생한다.
    - **사용 예시)** 동적으로 생성되는 데이터 처리 (예: 웹 로그 저장)
    
    ```c
    #include <stdio.h>
    #define SIZE 5
    
    int main() {
        int *dynamic_array = (int *)malloc(SIZE * sizeof(int));
        for (int i = 0; i < SIZE; i++) {
            dynamic_array[i] = i + 1;
        }
        printf("동적 배열 요소:\n");
        for (int i = 0; i < SIZE; i++) {
            printf("%d ", dynamic_array[i]);
        }
        printf("\n");
    
        free(dynamic_array); // 동적 메모리 해제
        return 0;
    }
    
    ```
    

### 연결 리스트 (Linked List)

데이터를 노드(Node)에 저장하고, 각 노드가 다음 노드를 가리키는 포인터를 통해 연결되는 동적 자료구조다.

- **특징**
    - 크기가 동적으로 조정된다.
    - 배열보다 삽입/삭제가 효율적이다. (`O(1)` - 리스트 앞에서 삽입/삭제 시)
    - 임의의 요소 접근은 비효율적이다. (`O(n)`)
- **단일 연결 리스트 (Singly-Linked List)**
    - **설명**: 각 노드가 데이터와 다음 노드의 포인터를 포함하며 한 방향으로만 연결된다.
    - **사용 예시)**
        - 메모리 제약이 있는 환경에서 데이터 저장
        - 스택과 같은 간단한 자료구조 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }
    
    // 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d -> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("단일 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **이중 연결 리스트 (Doubly-Linked List)**
    - **설명**: 각 노드가 이전 노드와 다음 노드의 포인터를 포함하며 양방향으로 연결된다.
    - **사용 예시)**
        - Undo/Redo 기능 구현
        - LRU 캐시 구현
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *prev;
        struct Node *next;
    } Node;
    
    // 이중 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->prev = NULL;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            return;
        }
    
        Node *current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
        new_node->prev = current;
    }
    
    // 이중 연결 리스트 출력
    void display(Node *head) {
        Node *current = head;
        while (current != NULL) {
            printf("%d <-> ", current->data);
            current = current->next;
        }
        printf("NULL\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        Node *current = head;
        Node *next_node;
        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("이중 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **원형 연결 리스트 (Circular-Linked List)**
    - **설명**: 마지막 노드가 첫 번째 노드를 가리키며 순환 구조를 형성하는 리스트.
    - **사용 예시)**
        - 프로세스 스케줄링 (라운드로빈 방식)
        - 게임의 턴 제어 시스템
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *next;
    } Node;
    
    // 원형 연결 리스트에 노드 추가
    void append(Node **head, int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->next = NULL;
    
        if (*head == NULL) {
            *head = new_node;
            new_node->next = *head;
            return;
        }
    
        Node *current = *head;
        while (current->next != *head) {
            current = current->next;
        }
        current->next = new_node;
        new_node->next = *head;
    }
    
    // 원형 연결 리스트 출력
    void display(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        do {
            printf("%d -> ", current->data);
            current = current->next;
        } while (current != head);
        printf("(head)\n");
    }
    
    // 메모리 해제
    void free_list(Node *head) {
        if (head == NULL) return;
    
        Node *current = head;
        Node *next_node;
        do {
            next_node = current->next;
            free(current);
            current = next_node;
        } while (current != head);
    }
    
    int main() {
        Node *head = NULL;
    
        append(&head, 1);
        append(&head, 2);
        append(&head, 3);
    
        printf("원형 연결 리스트:\n");
        display(head);
    
        free_list(head);
        return 0;
    }
    ```
    
- **다중 연결 리스트 (Multi-Linked List)**
    - **설명:** 하나의 노드가 여러 개의 연결을 가질 수 있는 구조로, 각 노드가 여러 방향으로 연결될 수 있다. 각 노드에 다수의 포인터를 가지며, 특정 데이터를 여러 개의 연결 구조로 표현할 수 있도록 한다.
    - **사용 예시)**
        - **그래프 표현**: 방향 그래프와 비방향 그래프의 인접 리스트 표현
        - **2차원 배열 동적 구현**: 동적 메모리를 사용하여 2D 배열을 구현
        - **데이터 관계 관리**: 데이터베이스와 같이 한 데이터가 여러 데이터와 관계를 가질 때
    
   ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    // 노드 구조체 정의
    typedef struct Node {
        int data;
        struct Node *right; // 오른쪽 노드
        struct Node *down;  // 아래쪽 노드
    } Node;
    
    // 새 노드 생성
    Node* create_node(int data) {
        Node *new_node = (Node *)malloc(sizeof(Node));
        new_node->data = data;
        new_node->right = NULL;
        new_node->down = NULL;
        return new_node;
    }
    
    // 다중 연결 리스트 생성 (2차원 배열과 유사)
    Node* create_multi_linked_list(int rows, int cols) {
        Node *head = NULL;
        Node *row_head = NULL;
        Node *prev_row = NULL;
    
        for (int i = 0; i < rows; i++) {
            Node *prev_col = NULL;
    
            for (int j = 0; j < cols; j++) {
                Node *new_node = create_node(i * cols + j + 1); // 노드에 값 삽입
    
                if (j == 0) {
                    if (head == NULL) {
                        head = new_node;
                    } else {
                        row_head->down = new_node;
                    }
                    row_head = new_node;
                }
    
                if (prev_col != NULL) {
                    prev_col->right = new_node;
                }
    
                if (prev_row != NULL && prev_row->right != NULL) {
                    prev_row->right->down = new_node;
                    prev_row = prev_row->right;
                }
    
                prev_col = new_node;
            }
    
            prev_row = row_head;
        }
    
        return head;
    }
    
    // 다중 연결 리스트 출력
    void display_multi_linked_list(Node *head) {
        Node *row = head;
    
        while (row != NULL) {
            Node *col = row;
            while (col != NULL) {
                printf("%d ", col->data);
                col = col->right;
            }
            printf("\n");
            row = row->down;
        }
    }
    
    // 메모리 해제
    void free_multi_linked_list(Node *head) {
        Node *row = head;
        while (row != NULL) {
            Node *col = row;
            Node *next_row = row->down;
    
            while (col != NULL) {
                Node *next_col = col->right;
                free(col);
                col = next_col;
            }
    
            row = next_row;
        }
    }
    
    int main() {
        int rows = 3, cols = 4;
    
        Node *head = create_multi_linked_list(rows, cols);
    
        printf("다중 연결 리스트 출력:\n");
        display_multi_linked_list(head);
    
        free_multi_linked_list(head);
    
        return 0;
    }
    
    // 출력 결과:
    다중 연결 리스트 출력:
    1 2 3 4
    5 6 7 8
    9 10 11 12
    ```

## 스택(Stack)

**LIFO (Last In, First Out)** 구조를 가진 자료구조로, 데이터가 삽입(푸시)되고 삭제(팝)되는 방식이 후입선출이다. 스택은 한쪽 끝에서만 데이터의 삽입과 삭제가 이루어진다.

- **사용 예시)**
    - **재귀 함수 처리**: 함수 호출 스택 관리.
    - **괄호 검사**: 수식의 괄호 균형 체크.
    - **역순 작업**: 문자열 뒤집기, 역순 데이터 처리.
    - **웹 브라우저 뒤로 가기/앞으로 가기**: 이전 페이지로 돌아가기.
    - **운영 체제**: 실행 중인 프로세스 관리 (스택 메모리).

### 배열 기반 스택 (Array-based Stack)

배열을 사용하여 스택을 구현하며, 고정된 크기를 사용하거나 동적 크기로 구현 가능하다. 배열의 마지막 요소가 스택의 최상단(top)을 나타낸다.

- **사용 예시)**
    - 데이터 크기가 고정되어 있을 때 (e.g., 정해진 크기의 명령 처리).
    - 작은 규모의 데이터를 관리할 때 메모리와 성능 효율적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100 // 스택의 최대 크기

typedef struct {
    int data[MAX_SIZE];
    int top; // 스택의 최상단을 나타냄
} Stack;

// 스택 초기화
void init_stack(Stack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(Stack *stack) {
    return stack->top == -1;
}

// 스택이 가득 찼는지 확인
int is_full(Stack *stack) {
    return stack->top == MAX_SIZE - 1;
}

// 스택에 데이터 삽입
void push(Stack *stack, int value) {
    if (is_full(stack)) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;
}

// 스택에서 데이터 삭제 및 반환
int pop(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택 최상단 데이터 반환
int peek(Stack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->data[stack->top];
}

int main() {
    Stack stack;
    init_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 연결 리스트 기반 스택 (Linked List-based Stack)

동적 메모리를 사용해 연결 리스트로 스택을 구현하며, 스택의 최상단(top)은 리스트의 헤드 노드로 표현된다.

- **사용 예시)**
    - 데이터 크기가 가변적이고 동적 메모리 사용이 필요할 때.
    - 메모리 제약 없이 데이터 삽입/삭제가 필요한 경우.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 스택 초기화
Node* create_stack() {
    return NULL; // 초기 스택은 NULL
}

// 스택에 데이터 삽입
void push(Node **top, int value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = value;
    new_node->next = *top;
    *top = new_node;
}

// 스택에서 데이터 삭제 및 반환
int pop(Node **top) {
    if (*top == NULL) {
        printf("스택 언더플로우\n");
        return -1;
    }
    Node *temp = *top;
    int value = temp->data;
    *top = (*top)->next;
    free(temp);
    return value;
}

// 스택 최상단 데이터 반환
int peek(Node *top) {
    if (top == NULL) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return top->data;
}

int main() {
    Node *stack = create_stack();

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top: %d\n", peek(stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Pop: %d\n", pop(&stack));

    return 0;
}
```

### 최소값/최대값 추적 스택 (Min/Max Stack)

스택에서 데이터를 삽입/삭제하는 동안 최소값 또는 최대값을 추적한다. 보조 스택을 사용하여 이를 구현하며, 각 연산이 O(1)로 작동한다.

- **사용 예시)**
    - 실시간으로 데이터의 최솟값/최댓값을 확인해야 하는 경우.
    - 예: 주식 가격의 실시간 추적.

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int min[MAX_SIZE];
    int top;
} MinStack;

// 스택 초기화
void init_min_stack(MinStack *stack) {
    stack->top = -1;
}

// 스택이 비었는지 확인
int is_empty(MinStack *stack) {
    return stack->top == -1;
}

// 스택에 데이터 삽입
void push(MinStack *stack, int value) {
    if (stack->top == MAX_SIZE - 1) {
        printf("스택 오버플로우\n");
        return;
    }
    stack->data[++stack->top] = value;

    // 최소값 추적
    if (stack->top == 0) {
        stack->min[stack->top] = value;
    } else {
        stack->min[stack->top] = (value < stack->min[stack->top - 1]) ? value : stack->min[stack->top - 1];
    }
}

// 스택에서 데이터 삭제 및 반환
int pop(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택 언더플로우\n");
        return -1;
    }
    return stack->data[stack->top--];
}

// 스택에서 최솟값 반환
int get_min(MinStack *stack) {
    if (is_empty(stack)) {
        printf("스택이 비어 있습니다.\n");
        return -1;
    }
    return stack->min[stack->top];
}

int main() {
    MinStack stack;
    init_min_stack(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 5);
    push(&stack, 30);

    printf("Min: %d\n", get_min(&stack));
    printf("Pop: %d\n", pop(&stack));
    printf("Min: %d\n", get_min(&stack));

    return 0;
}
```
