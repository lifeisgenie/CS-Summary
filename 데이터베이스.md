# 데이터베이스

## 데이터베이스 개요

### 데이터베이스의 정의와 필요성

- **정의**: 데이터를 체계적으로 저장하고 관리하여 다수의 사용자가 데이터를 효율적으로 조회, 수정할 수 있도록 지원하는 시스템이다.
- **필요성**:
    - **데이터 중복 제거**: 동일한 데이터를 여러 번 저장하지 않음으로써 저장 공간을 효율적으로 활용한다.
    - **데이터 일관성 유지**: 여러 시스템이나 사용자 간에 동일한 데이터 상태를 유지하도록 한다.
    - **데이터 무결성 보장**: 데이터의 정확성과 신뢰성을 확보한다.
    - **데이터 공유 및 보안 강화**: 다수 사용자가 데이터를 안전하게 접근할 수 있도록 보장한다.

### 파일 시스템과 데이터베이스의 차이

- **파일 시스템**: 데이터를 비구조적으로 관리하며 중복, 무결성, 보안 등 여러 문제가 발생할 수 있다.
- **데이터베이스**: 구조화된 데이터 모델을 통해 효율적으로 데이터를 저장하고, 무결성, 보안, 동시성 등을 보장하여 관리한다.

### 데이터베이스의 특징

- **무결성(Integrity)**: 데이터의 정확성과 신뢰성을 유지하는 특징이다.
- **일관성(Consistency)**: 트랜잭션 후 데이터베이스가 일관된 상태로 유지되도록 보장한다.
- **보안(Security)**: 데이터 접근 권한을 제어하여 데이터 유출 및 손실을 방지한다.
- **동시성(Concurrency)**: 여러 사용자가 동시에 데이터에 접근할 수 있도록 지원한다.
- **복구성(Recovery)**: 시스템 장애 시 데이터를 복구할 수 있는 기능을 제공한다.

### 데이터베이스 관리 시스템(DBMS, DataBase Management System)의 역할과 구조

- **DBMS의 역할**:
    - 데이터 저장, 검색, 수정, 삭제 등의 작업을 효율적으로 처리한다.
    - 데이터의 무결성, 보안, 동시성, 복구 기능을 지원한다.
    - SQL 등의 언어를 통해 사용자가 데이터베이스와 상호작용할 수 있도록 한다.
- **DBMS의 구조**:
    - **사용자 인터페이스**: 사용자와 데이터베이스 간의 상호작용을 처리하는 SQL 명령어 처리 시스템.
    - **질의 처리기**: 사용자의 쿼리를 최적화하고 실행 계획을 생성한다.
    - **트랜잭션 관리자**: 데이터의 일관성과 무결성을 보장하는 시스템.
    - **스토리지 관리자**: 데이터를 물리적으로 저장하고 관리한다.
    - **버퍼 관리자**: 메모리와 디스크 간 데이터를 효율적으로 관리하여 성능을 최적화한다.

### 데이터베이스 모델의 종류

- **관계형 데이터베이스(Relational DB)**: 데이터를 테이블 형식으로 구조화하여 관리한다. (예: MySQL, PostgreSQL)
- **비관계형 데이터베이스(NoSQL)**: 유연한 데이터 모델을 제공하여 다양한 데이터 유형을 처리한다. (예: MongoDB, Cassandra)
- **계층형 모델/네트워크형 모델**: 트리 구조나 그래프 구조로 데이터를 표현하여 저장한다.

## 데이터 모델링

### 데이터 모델링 개념과 프로세스

- **개념**: 데이터베이스 구축 전에 데이터 구조를 시각화하고 체계적으로 설계하는 과정이다.
- **프로세스**:
    1. **요구사항 분석**: 
        - 데이터베이스가 지원해야 할 비즈니스 프로세스와 기능을 정의한다.
        - 사용자 요구사항과 데이터를 수집하여 데이터베이스 설계 목표 설정한다.
    2. **개념적 설계**: 
        - 데이터베이스에 저장될 주요 엔터티와 그 관계를 정의한다.
        - 데이터 구조를 시각화하기 위해 **ER 다이어그램(Entity-Relationship Diagram)** 작성한다.
    3. **논리적 설계**: 
        - 개념적 설계를 기반으로 **논리적 데이터 모델**을 설계한다.
        - 테이블, 속성, 키, 관계, 제약 조건 등을 정의한다.
        - **정규화** 과정을 통해 데이터 구조를 최적화한다.
    4. **물리적 설계**: 
        - 논리적 설계를 실제 데이터베이스 관리 시스템(DBMS)에 맞게 구현한다.
        - 저장소 구조, 인덱스, 파티셔닝 등 성능 최적화를 고려한다.

### ER(Entity-Relationship) 다이어그램

데이터 모델링 과정에서 데이터의 구조를 시각적으로 표현한 도구

- **엔터티(Entity):** 데이터베이스에 저장되는 객체나 개체를 의미한다.
    - **강한 엔터티(Strong Entity)**: 다른 엔터티에 의존하지 않는 독립적인 엔터티이다.
    - **약한 엔터티(Weak Entity)**: 강한 엔터티에 의존하며, 기본 키를 가지지 않고 외래 키를 통해 식별된다.
- **속성(Attribute):** 엔터티의 특징이나 정보를 나타낸다.
    - **기본 속성**: 엔터티가 가지는 고유한 정보
    - **복합 속성**: 여러 구성 요소로 이루어진 속성
    - **다중값 속성**: 한 엔터티에 대해 여러 값을 가질 수 있는 속성
- **관계(Relationship)**: 엔터티 간의 연관성을 표현한다.
    - 1:1 관계(One-to-One)
    - 1:N 관계(One-to-Many)
    - N:M 관계(Many-to-Many)

### 정규화

데이터 구조를 최적화하여 **중복 데이터 제거**와 **데이터 무결성 보장**을 목표로 하는 과정

- **제 1정규형(1NF)**:
    - 테이블에서 반복되는 그룹을 제거하고, 모든 속성 값을 원자값으로 구성한다.
    - **예시)** "전화번호" 속성에 여러 값(예: "010-1234-5678, 010-9876-5432")이 포함된 경우, 각 전화번호는 별도의 레코드로 나누어야 한다.
- **제 2정규형(2NF)**:
    - 1NF를 만족하고, 부분 함수 종속을 제거한다.
    - **예시**: 학생과 수업 정보를 저장한 테이블에서 학생 ID와 수업 ID가 복합 기본 키일 때, 학생 이름이 수업에 종속되면 2NF를 위반한다. 학생 이름을 별도의 테이블로 분리해야 한다.
- **제 3정규형(3NF)**:
    - 2NF를 만족하고, 이행적 함수 종속을 제거한다.
    - **예시**: A → B, B → C인 경우, A → C 관계를 제거한다. 예를 들어, 학생 ID → 교수 이름 → 교수 사무실 주소라면, 교수 사무실 주소를 교수 엔터티로 이동시켜야 한다.
- **BCNF(보이스-코드 정규형)**: 모든 결정자가 후보 키가 되도록 설계한다.
- **다섯 번째 정규형(5NF)**: 조인 종속성을 제거하여, 데이터 중복을 최소화한다.

### 비정규화와 성능 최적화

- **개념:** 성능 최적화를 위해 정규화된 데이터 구조를 의도적으로 해제하는 과정이다.
- **사용 목적**:
    - 정규화된 구조에서 발생하는 복잡한 조인 연산을 줄일 수 있다.
    - 데이터 조회 속도 향상 및 쿼리 성능 최적화가 가능하다.
- **주의점**:
    - 비정규화를 적용할 때, 데이터 무결성과 일관성 유지가 매우 중요하다.
    - 비정규화로 인해 쿼리가 빨라질 수 있지만, 데이터 중복이 발생할 수 있다.
- **예시:**
    - **정규화된 구조**: 고객과 주문 테이블이 분리되어 있고, 주문 정보를 조회할 때마다 조인 연산이 필요하다.
    - **비정규화된 구조**: 고객과 주문 정보를 하나의 테이블로 합쳐서 조인 연산을 줄이고 조회 성능을 향상시킬 수 있다.
 
## 관계형 데이터베이스

### 관계형 데이터베이스의 개념

- 데이터를 **행(row)과 열(column)**로 구성된 **테이블 형태**로 관리하는 시스템이다.
- 각 테이블은 하나의 **릴레이션(Relation)**으로 표현되며, 데이터 간 관계를 구조적으로 나타낼 수 있다.
    - 예시) **학생 테이블**은 학생ID, 이름, 나이, 전공 등의 열을 가지며, 각 행은 한 명의 학생을 나타냅니다.

### 키의 종류

- **기본 키(Primary Key):** 각 테이블의 행을 고유하게 식별할 수 있는 키
    - **유일성:** 기본 키 값은 테이블 내에서 중복될 수 없다.
    - **무결성:** 기본 키에는 **NULL 값**이 올 수 없다.
    - **예시)** 학생 테이블에서 학번(Student_ID)은 각 학생을 고유하게 식별하므로 기본 키로 설정한다.
- **후보 키(Candidate Key):** 기본 키로 선택 가능한 모든 속성 집합이다.
    - **유일성(Unique)**과 **최소성(Minimality)**을 만족한다.
    - 하나의 테이블에서 여러 후보 키가 존재할 수 있다.
    - **예시)** 학생 테이블에서 학번(Student_ID)와 이메일(Email)은 각각 고유하므로 후보 키가 될 수 있다.
- **대체 키(Alternate Key):** 후보 키 중 기본 키로 선택되지 않은 나머지 키
    - 예시) 학생 테이블에서 학번(Student_ID)을 기본 키로 설정하면, 이메일(Email)은 대체 키가 된다.
- **외래 키(Foreign Key):** 다른 테이블의 기본 키를 참조하는 키로, 테이블 간 관계를 나타낸다.
    - **참조 무결성(Referential Integrity)**을 유지한다.
    - 외래 키에 **NULL 값**은 허용되지만, 참조하는 기본 키 값이 변경되면 일관성 유지가 요구된다.
    - **예시)** 성적 테이블에서 학번(Student_ID)은 학생 테이블의 학번을 참조하는 외래 키로 설정된다.
- **슈퍼 키(Super Key):** 테이블의 튜플을 고유하게 식별할 수 있는 속성들의 집합
    - 유일성은 만족하지만 최소성은 만족하지 않을 수 있다.
    - 기본 키와 후보 키는 슈퍼 키의 하위 개념이다.
    - **예시)** [학번 + 이름]은 유일성을 가지므로 슈퍼 키가 될 수 있다.

### 릴레이션 연산

테이블에서 데이터를 **검색, 변환, 결합**하는 작업을 수행한다.

- **셀렉션(Selection):**
    - 테이블에서 특정 조건을 만족하는 **튜플(행)**을 검색한다.
    - σ조건 (릴레이션)
    - **예시)** `σ(학생ID = '2023001') (학생)`은 `학생` 테이블에서 `학생ID`가 `'2023001'`인 행을 선택한다.
- **프로젝션(Projection):**
    - 테이블에서 특정 속성(열)만 선택한다.
    - π속성 (릴레이션)
    - **예시**: `π(이름, 전공) (학생)`은 `학생` 테이블에서 `이름`과 `전공` 속성만 선택한다.
- **조인(Join):**
    - 두 개 이상의 테이블을 결합하여 데이터를 **통합**한다. 
    - **내부 조인(Inner Join):** 조건에 일치하는 튜플만 결합한다.
        - **예시)** `학생 ⋈ 성적`은 학생과 성적 테이블에서 일치하는 `학생ID`를 기준으로 데이터를 결합한다.
    - **외부 조인(Outer Join):** 조건에 일치하지 않는 튜플도 포함한다.
        - **왼쪽 외부 조인(Left Outer Join):** 왼쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟕ 성적`은 학생 테이블의 모든 행을 포함하고, 성적 테이블에서 `학생ID`가 일치하는 값을 결합한다. 성적 정보가 없는 학생은 `NULL`로 표시한다.
        - **오른쪽 외부 조인(Rigth Outer Join):** 오른쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟖ 성적` 은 성적 테이블의 모든 행을 포함하고, 학생 테이블에서 `학생ID`가 일치하는 값을 결합합니다. 학생 정보가 없는 성적은 `NULL`로 표시됩니다.
        - **완전 외부 조인(Full Outer Join):** 양쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟗ 성적` 은 학생 테이블과 성적 테이블의 모든 데이터를 포함하고, 일치하지 않는 값은 `NULL`로 표시된다.
- **집합 연산(Union, Intersection, Difference)**
    - 테이블 간의 데이터를 **집합 연산**으로 처리한다.
    - **합집합(Union):** 두 테이블의 모든 튜플을 결합한다.
        - **예시)** `R ∪ S`는 테이블 R과 S의 모든 튜플을 결합한다.
    - **교집합(Intersection):** 두 테이블에 공통으로 존재하는 튜플만 선택한다.
        - **예시)** `R ∩ S`는 테이블 R과 S에서 공통된 튜플만 선택
    - **차집합(Difference):** 첫 번째 테이블에만 존재하는 튜플 선택한다.
        - **예시)** `R - S`는 테이블 R에서 S에 없는 튜플을 선택한다.

### SQL

### SQL의 개요와 구성

SQL(Structured Query Language)은 **관계형 데이터베이스**에서 데이터를 정의, 조작, 제어하기 위해 사용하는 **표준 언어**이다.

### 데이터 정의 언어(DDL)

데이터 구조를 정의하는 명령어이다. DDL 명령어는 테이블 및 객체를 생성, 수정, 삭제할 때 사용된다.

- **CREATE:** 테이블 생성
    - **예시)** 학생 정보를 저장하는 `학생` 테이블을 생성
    
    ```sql
    CREATE TABLE 학생 (
        학생ID INT PRIMARY KEY,
        이름 VARCHAR(50),
        나이 INT,
        전공 VARCHAR(50)
    );
    ```
    
- **ALTER:** 테이블 속성 변경
    - **예시)** `학생` 테이블에 `이메일` 컬럼 추가
    
    ```sql
    ALTER TABLE 학생
    ADD 이메일 VARCHAR(100);
    ```
    
- **DROP:** 테이블 삭제
    - **예시)** `학생` 테이블 삭제
    
    ```sql
    DROP TABLE 학생;
    ```
    

### 데이터 조작 언어(DML)

데이터베이스 내의 데이터를 조회, 삽입, 수정, 삭제하는 명령어

- **SELECT:** 데이터 조회
    - **예시)** `학생` 테이블에서 모든 학생의 이름과 나이 조회
    
    ```sql
    SELECT 이름, 나이 FROM 학생;
    ```
    
- **INSERT:** 데이터 삽입
    - **예시)** `학생` 테이블에 새로운 학생 데이터 삽입
    
    ```sql
    INSERT INTO 학생 (학생ID, 이름, 나이, 전공)
    VALUES (1, '홍길동', 20, '컴퓨터공학');
    ```
    
- **UPDATE:** 데이터 수정
    - **예시)** `학생` 테이블에서 특정 학생의 전공을 '정보보호'로 수정
    
    ```sql
    UPDATE 학생
    SET 전공 = '정보보호'
    WHERE 학생ID = 1;
    ```
    
- **DELETE:** 데이터 삭제
    - **예시)** `학생` 테이블에서 `학생ID`가 1인 학생 데이터 삭제
    
    ```sql
    DELETE FROM 학생
    WHERE 학생ID = 1;
    ```
    

### JOIN과 서브쿼리

- **JOIN**: 여러 테이블을 결합하여 관련 데이터를 조회하는 방법
    - **내부 조인(Inner Join)**: 조건에 맞는 행만 결합
    - **예시)** 학생과 성적 테이블을 학생ID 기준으로 내부 조인
    
    ```sql
    SELECT 학생.이름, 성적.과목, 성적.점수
    FROM 학생
    INNER JOIN 성적 ON 학생.학생ID = 성적.학생ID;
    ```
    
- **서브쿼리**: 다른 쿼리 안에 포함된 쿼리
    - **단일 행 서브쿼리**: 서브쿼리가 하나의 결과만 반환
    - **다중 행 서브쿼리**: 서브쿼리가 여러 행을 반환
    - **인라인 뷰 (Inline View)**: 서브쿼리가 FROM 절에 포함되어 하나의 테이블처럼 사용된다.
    - **예시)** 성적이 가장 높은 학생의 이름 조회
    
    ```sql
    SELECT 이름
    FROM 학생
    WHERE 학생ID = (
        SELECT 학생ID
        FROM 성적
        ORDER BY 점수 DESC
        LIMIT 1
    );
    ```
    

### 데이터 제어 언어(DCL)

데이터베이스에 접근하고 객체들을 사용할 수 있게 권한을 제어하는 명령어

- **GRANT:** 권한 부여
    - **예시)** 사용자 `홍길동`에게 `학생` 테이블의 조회 권한 부여
    
    ```sql
    GRANT SELECT ON 학생 TO 홍길동;
    ```
    
- **REVOKE:** 권한 회수
    - **예시)** 사용자 `홍길동`에게서 `학생` 테이블의 조회 권한 회수
    
    ```sql
    REVOKE SELECT ON 학생 FROM 홍길동;
    ```
    

### 트랜잭션 제어 언어(TCL)

데이터베이스 트랜잭션을 관리하는 명령어

- **COMMIT**: 트랜잭션을 **확정**하여 데이터베이스에 반영
    - **예시)** 데이터를 삽입한 후 변경 사항을 데이터베이스에 저장
    
    ```sql
    COMMIT;
    ```
    
- **ROLLBACK**: 트랜잭션을 **되돌리기** (실행된 작업을 취소)
    - **예시)** 데이터 삽입을 취소하고 이전 상태로 되돌리기
    
    ```sql
    ROLLBACK;
    ```
    
- **SAVEPOINT**: 트랜잭션 내에서 **지점 설정** (특정 시점으로 롤백 가능)
    - **예시)** 트랜잭션 내에서 중간 저장점을 설정
    
    ```sql
    SAVEPOINT Savepoint1;
    ```

## 트랜잭션과 동시성 제어

### 트랜잭션의 개념

데이터베이스에서 하나의 논리적 작업 단위로, 데이터베이스의 상태를 변경하는 일련의 작업들을 포함한다. 트랜잭션은 **모두 성공적으로 완료되거나, 전혀 수행되지 않아야** 하는 원칙을 가진다.

- **예시):** 은행 계좌 이체에서 **A 계좌에서 금액을 출금하고 B 계좌에 입금하는** 두 작업을 하나의 트랜잭션으로 처리한다. 만약 중간에 실패하면 **두 작업 모두 롤백**되어야 한다.

### 트랜잭션 특성(ACID)

1. **Automicity (원자성)**:
    - 트랜잭션은 하나의 작업처럼 처리되며, 모든 작업이 **완전히 수행되거나** 전혀 수행되지 않아야 한다.
    - **예시)** A 계좌에서 1000원을 출금하고 B 계좌에 입금하는 두 작업이 하나의 트랜잭션으로 처리된다. 만약 입금 작업만 성공하고 출금 작업이 실패하면, 전체 트랜잭션은 실패해야 한다.
2. **Consistency (일관성)**:
    - 트랜잭션이 완료되면 데이터베이스는 항상 일관된 상태로 변환되어야 한다. 즉, 트랜잭션 전후의 데이터는 규칙을 따르고 있어야 한다.
    - **예시)** 은행 시스템에서 **계좌 잔액이 음수가 될 수 없**다는 규칙이 있다면, 트랜잭션이 완료되면 계좌 잔액이 음수 상태로 남지 않아야 한다.
3. **Durability (영속성)**:
    - 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템이 장애를 겪더라도 영구적으로 반영되어야 한다.
    - **예시)** 은행 계좌 이체가 완료되면, 시스템이 다운되더라도 해당 거래 내역은 **복구 후에도** 유지되어야 한다.
4. **Isolation (격리성)**:
    - 동시에 여러 트랜잭션이 실행되더라도 각 트랜잭션은 **다른 트랜잭션의 중간 상태를 볼 수 없어야** 한다.
    - **예시)** A 계좌에서 1000원을 출금하는 트랜잭션이 진행 중일 때, 다른 트랜잭션이 A 계좌의 잔액을 조회하면 **출금이 완료되지 않은 상태에서 잔액이 조회되지 않아야** 한다.

### 동시성 문제

- **갱신 손실 (Lost Update)**:
    - 두 개 이상의 트랜잭션이 동일한 데이터를 수정하면서 하나의 수정 결과가 손실되는 문제.
    - **예시)** 트랜잭션 T1과 T2가 동일한 계좌 잔액을 수정하는데, T1이 잔액을 1000원으로 수정하고 T2도 같은 값을 수정하면 T1의 수정이 손실된다.
- **비일관성 읽기 (Uncommitted Data Read)**:
    - 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 문제.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 변경하는 중에 트랜잭션 T2가 그 변경된 값을 읽어버리면, T2는 유효하지 않은 데이터를 읽게 된다.
- **비반복 읽기 (Non-repeatable Read)**:
    - 트랜잭션이 데이터를 한 번 읽은 후, 같은 데이터를 다시 읽을 때 값이 달라지는 문제.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회한 후, 트랜잭션 T2가 같은 계좌의 잔액을 수정하고 T1이 다시 조회했을 때 잔액이 달라지는 경우이다.

### 트랜잭션 격리 수준

트랜잭션 간의 **동시성 제어**를 위해 설정할 수 있는 수준을 정의하며, 각 수준은 동시성 문제를 어느 정도 허용하는지에 따라 다르다.

- **Read Uncommitted (읽기 미확정)**:
    - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있다. 가장 낮은 격리 수준으로 동시성 문제를 가장 많이 발생시킬 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 수정 중일 때, 트랜잭션 T2가 그 값을 읽을 수 있다.
- **Read Committed (읽기 확정)**:
    - 트랜잭션이 커밋된 데이터만 읽을 수 있다. 비일관성 읽기는 방지하지만, 비반복 읽기는 여전히 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 수정 중일 때, 트랜잭션 T2는 그 값을 읽을 수 없다.
- **Repeatable Read (반복 가능한 읽기)**:
    - 트랜잭션이 읽은 데이터는 트랜잭션 종료까지 변경될 수 없다. 비반복 읽기를 방지하지만, 갱신 손실이나 비일관성 읽기는 여전히 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회한 후, 다른 트랜잭션이 그 값을 변경할 수 없다.
- **Serializable (직렬화 가능)**:
    - 트랜잭션이 다른 트랜잭션의 영향을 전혀 받지 않으며, 모든 트랜잭션은 마치 순차적으로 실행된 것처럼 격리된다. 가장 높은 격리 수준으로 성능 저하가 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회하고 있는 동안, 다른 트랜잭션은 그 계좌에 접근할 수 없다.

### 동시성 제어 기법

- **잠금 (Locking)**:
    - 트랜잭션이 데이터를 수정할 때, 해당 데이터에 대해 **잠금을 설정**하여 다른 트랜잭션이 동시에 접근하지 못하게 한다.
        - **예시)** 트랜잭션 T1이 계좌 잔액을 수정하는 동안, T2는 그 계좌에 접근할 수 없다.
- **타임스탬프 (Timestamp Ordering)**:
    - 트랜잭션에 고유의 타임스탬프를 부여하고, 트랜잭션이 수행하는 연산을 타임스탬프 순으로 정렬하여 동시성 문제를 해결한다.
        - **예시)** 트랜잭션 T1이 1000원 출금 작업을 먼저 시작했으면, T2는 T1이 완료될 때까지 해당 계좌에 접근할 수 없다.
