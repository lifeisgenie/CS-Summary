# 데이터베이스

## 데이터베이스 개요

### 데이터베이스의 정의와 필요성

- **정의**: 데이터를 체계적으로 저장하고 관리하여 다수의 사용자가 데이터를 효율적으로 조회, 수정할 수 있도록 지원하는 시스템이다.
- **필요성**:
    - **데이터 중복 제거**: 동일한 데이터를 여러 번 저장하지 않음으로써 저장 공간을 효율적으로 활용한다.
    - **데이터 일관성 유지**: 여러 시스템이나 사용자 간에 동일한 데이터 상태를 유지하도록 한다.
    - **데이터 무결성 보장**: 데이터의 정확성과 신뢰성을 확보한다.
    - **데이터 공유 및 보안 강화**: 다수 사용자가 데이터를 안전하게 접근할 수 있도록 보장한다.

### 파일 시스템과 데이터베이스의 차이

- **파일 시스템**: 데이터를 비구조적으로 관리하며 중복, 무결성, 보안 등 여러 문제가 발생할 수 있다.
- **데이터베이스**: 구조화된 데이터 모델을 통해 효율적으로 데이터를 저장하고, 무결성, 보안, 동시성 등을 보장하여 관리한다.

### 데이터베이스의 특징

- **무결성(Integrity)**: 데이터의 정확성과 신뢰성을 유지하는 특징이다.
- **일관성(Consistency)**: 트랜잭션 후 데이터베이스가 일관된 상태로 유지되도록 보장한다.
- **보안(Security)**: 데이터 접근 권한을 제어하여 데이터 유출 및 손실을 방지한다.
- **동시성(Concurrency)**: 여러 사용자가 동시에 데이터에 접근할 수 있도록 지원한다.
- **복구성(Recovery)**: 시스템 장애 시 데이터를 복구할 수 있는 기능을 제공한다.

### 데이터베이스 관리 시스템(DBMS, DataBase Management System)의 역할과 구조

- **DBMS의 역할**:
    - 데이터 저장, 검색, 수정, 삭제 등의 작업을 효율적으로 처리한다.
    - 데이터의 무결성, 보안, 동시성, 복구 기능을 지원한다.
    - SQL 등의 언어를 통해 사용자가 데이터베이스와 상호작용할 수 있도록 한다.
- **DBMS의 구조**:
    - **사용자 인터페이스**: 사용자와 데이터베이스 간의 상호작용을 처리하는 SQL 명령어 처리 시스템.
    - **질의 처리기**: 사용자의 쿼리를 최적화하고 실행 계획을 생성한다.
    - **트랜잭션 관리자**: 데이터의 일관성과 무결성을 보장하는 시스템.
    - **스토리지 관리자**: 데이터를 물리적으로 저장하고 관리한다.
    - **버퍼 관리자**: 메모리와 디스크 간 데이터를 효율적으로 관리하여 성능을 최적화한다.

### 데이터베이스 모델의 종류

- **관계형 데이터베이스(Relational DB)**: 데이터를 테이블 형식으로 구조화하여 관리한다. (예: MySQL, PostgreSQL)
- **비관계형 데이터베이스(NoSQL)**: 유연한 데이터 모델을 제공하여 다양한 데이터 유형을 처리한다. (예: MongoDB, Cassandra)
- **계층형 모델/네트워크형 모델**: 트리 구조나 그래프 구조로 데이터를 표현하여 저장한다.

## 데이터 모델링

### 데이터 모델링 개념과 프로세스

- **개념**: 데이터베이스 구축 전에 데이터 구조를 시각화하고 체계적으로 설계하는 과정이다.
- **프로세스**: 요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계

### ER(Entity-Relationship) 다이어그램

데이터 모델링 과정에서 데이터의 구조를 시각적으로 표현한 도구

- **엔터티(Entity):** 데이터베이스에 저장되는 객체나 개체를 의미한다.
    - **강한 엔터티(Strong Entity)**: 다른 엔터티에 의존하지 않는 독립적인 엔터티이다.
    - **약한 엔터티(Weak Entity)**: 강한 엔터티에 의존하며, 기본 키를 가지지 않고 외래 키를 통해 식별된다.
- **속성(Attribute):** 엔터티의 특징이나 정보를 나타낸다.
    - **기본 속성**: 엔터티가 가지는 고유한 정보
    - **복합 속성**: 여러 구성 요소로 이루어진 속성
    - **다중값 속성**: 한 엔터티에 대해 여러 값을 가질 수 있는 속성
- **관계(Relationship)**: 엔터티 간의 연관성을 표현한다.
    - 1:1 관계(One-to-One)
    - 1:N 관계(One-to-Many)
    - N:M 관계(Many-to-Many)

### 정규화

데이터 구조를 최적화하여 **중복 데이터 제거**와 **데이터 무결성 보장**을 목표로 하는 과정

- **제 1정규형(1NF)**:
    - 테이블에서 반복되는 그룹을 제거하고, 모든 속성 값을 원자값으로 구성한다.
    - **예시)** "전화번호" 속성에 여러 값(예: "010-1234-5678, 010-9876-5432")이 포함된 경우, 각 전화번호는 별도의 레코드로 나누어야 한다.
- **제 2정규형(2NF)**:
    - 1NF를 만족하고, 부분 함수 종속을 제거한다.
    - **예시**: 학생과 수업 정보를 저장한 테이블에서 학생 ID와 수업 ID가 복합 기본 키일 때, 학생 이름이 수업에 종속되면 2NF를 위반한다. 학생 이름을 별도의 테이블로 분리해야 한다.
- **제 3정규형(3NF)**:
    - 2NF를 만족하고, 이행적 함수 종속을 제거한다.
    - **예시**: A → B, B → C인 경우, A → C 관계를 제거한다. 예를 들어, 학생 ID → 교수 이름 → 교수 사무실 주소라면, 교수 사무실 주소를 교수 엔터티로 이동시켜야 한다.
- **BCNF(보이스-코드 정규형)**: 모든 결정자가 후보 키가 되도록 설계한다.
- **다섯 번째 정규형(5NF)**: 조인 종속성을 제거하여, 데이터 중복을 최소화한다.

### 비정규화와 성능 최적화

- **개념:** 성능 최적화를 위해 정규화된 데이터 구조를 의도적으로 해제하는 과정이다.
- **사용 목적**:
    - 정규화된 구조에서 발생하는 복잡한 조인 연산을 줄일 수 있다.
    - 데이터 조회 속도 향상 및 쿼리 성능 최적화가 가능하다.
- **주의점**:
    - 비정규화를 적용할 때, 데이터 무결성과 일관성 유지가 매우 중요하다.
    - 비정규화로 인해 쿼리가 빨라질 수 있지만, 데이터 중복이 발생할 수 있다.
- **예시:**
    - **정규화된 구조**: 고객과 주문 테이블이 분리되어 있고, 주문 정보를 조회할 때마다 조인 연산이 필요하다.
    - **비정규화된 구조**: 고객과 주문 정보를 하나의 테이블로 합쳐서 조인 연산을 줄이고 조회 성능을 향상시킬 수 있다.
 
## 관계형 데이터베이스

### 관계형 데이터베이스의 개념

- 데이터를 **행(row)과 열(column)**로 구성된 **테이블 형태**로 관리하는 시스템이다.
- 각 테이블은 하나의 **릴레이션(Relation)**으로 표현되며, 데이터 간 관계를 구조적으로 나타낼 수 있다.
    - 예시) **학생 테이블**은 학생ID, 이름, 나이, 전공 등의 열을 가지며, 각 행은 한 명의 학생을 나타냅니다.

### 키의 종류

- **기본 키(Primary Key):** 각 테이블의 행을 고유하게 식별할 수 있는 키
    - **유일성:** 기본 키 값은 테이블 내에서 중복될 수 없다.
    - **무결성:** 기본 키에는 **NULL 값**이 올 수 없다.
    - **예시)** 학생 테이블에서 학번(Student_ID)은 각 학생을 고유하게 식별하므로 기본 키로 설정한다.
- **후보 키(Candidate Key):** 기본 키로 선택 가능한 모든 속성 집합이다.
    - **유일성(Unique)**과 **최소성(Minimality)**을 만족한다.
    - 하나의 테이블에서 여러 후보 키가 존재할 수 있다.
    - **예시)** 학생 테이블에서 학번(Student_ID)와 이메일(Email)은 각각 고유하므로 후보 키가 될 수 있다.
- **대체 키(Alternate Key):** 후보 키 중 기본 키로 선택되지 않은 나머지 키
    - 예시) 학생 테이블에서 학번(Student_ID)을 기본 키로 설정하면, 이메일(Email)은 대체 키가 된다.
- **외래 키(Foreign Key):** 다른 테이블의 기본 키를 참조하는 키로, 테이블 간 관계를 나타낸다.
    - **참조 무결성(Referential Integrity)**을 유지한다.
    - 외래 키에 **NULL 값**은 허용되지만, 참조하는 기본 키 값이 변경되면 일관성 유지가 요구된다.
    - **예시)** 성적 테이블에서 학번(Student_ID)은 학생 테이블의 학번을 참조하는 외래 키로 설정된다.
- **슈퍼 키(Super Key):** 테이블의 튜플을 고유하게 식별할 수 있는 속성들의 집합
    - 유일성은 만족하지만 최소성은 만족하지 않을 수 있다.
    - 기본 키와 후보 키는 슈퍼 키의 하위 개념이다.
    - **예시)** [학번 + 이름]은 유일성을 가지므로 슈퍼 키가 될 수 있다.

### 릴레이션 연산

테이블에서 데이터를 **검색, 변환, 결합**하는 작업을 수행한다.

- **셀렉션(Selection):**
    - 테이블에서 특정 조건을 만족하는 **튜플(행)**을 검색한다.
    - σ조건 (릴레이션)
    - **예시)** `σ(학생ID = '2023001') (학생)`은 `학생` 테이블에서 `학생ID`가 `'2023001'`인 행을 선택한다.
- **프로젝션(Projection):**
    - 테이블에서 특정 속성(열)만 선택한다.
    - π속성 (릴레이션)
    - **예시**: `π(이름, 전공) (학생)`은 `학생` 테이블에서 `이름`과 `전공` 속성만 선택한다.
- **조인(Join):**
    - 두 개 이상의 테이블을 결합하여 데이터를 **통합**한다. 
    - **내부 조인(Inner Join):** 조건에 일치하는 튜플만 결합한다.
        - **예시)** `학생 ⋈ 성적`은 학생과 성적 테이블에서 일치하는 `학생ID`를 기준으로 데이터를 결합한다.
    - **외부 조인(Outer Join):** 조건에 일치하지 않는 튜플도 포함한다.
        - **왼쪽 외부 조인(Left Outer Join):** 왼쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟕ 성적`은 학생 테이블의 모든 행을 포함하고, 성적 테이블에서 `학생ID`가 일치하는 값을 결합한다. 성적 정보가 없는 학생은 `NULL`로 표시한다.
        - **오른쪽 외부 조인(Rigth Outer Join):** 오른쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟖ 성적` 은 성적 테이블의 모든 행을 포함하고, 학생 테이블에서 `학생ID`가 일치하는 값을 결합합니다. 학생 정보가 없는 성적은 `NULL`로 표시됩니다.
        - **완전 외부 조인(Full Outer Join):** 양쪽 테이블의 모든 튜플을 포함한다.
            - **예시)** `학생 ⟗ 성적` 은 학생 테이블과 성적 테이블의 모든 데이터를 포함하고, 일치하지 않는 값은 `NULL`로 표시된다.
- **집합 연산(Union, Intersection, Difference)**
    - 테이블 간의 데이터를 **집합 연산**으로 처리한다.
    - **합집합(Union):** 두 테이블의 모든 튜플을 결합한다.
        - **예시)** `R ∪ S`는 테이블 R과 S의 모든 튜플을 결합한다.
    - **교집합(Intersection):** 두 테이블에 공통으로 존재하는 튜플만 선택한다.
        - **예시)** `R ∩ S`는 테이블 R과 S에서 공통된 튜플만 선택
    - **차집합(Difference):** 첫 번째 테이블에만 존재하는 튜플 선택한다.
        - **예시)** `R - S`는 테이블 R에서 S에 없는 튜플을 선택한다.

### SQL

### SQL의 개요와 구성

SQL(Structured Query Language)은 **관계형 데이터베이스**에서 데이터를 정의, 조작, 제어하기 위해 사용하는 **표준 언어**이다.

### 데이터 정의 언어(DDL)

데이터 구조를 정의하는 명령어이다. DDL 명령어는 테이블 및 객체를 생성, 수정, 삭제할 때 사용된다.

- **CREATE:** 테이블 생성
    - **예시)** 학생 정보를 저장하는 `학생` 테이블을 생성
    
    ```sql
    CREATE TABLE 학생 (
        학생ID INT PRIMARY KEY,
        이름 VARCHAR(50),
        나이 INT,
        전공 VARCHAR(50)
    );
    ```
    
- **ALTER:** 테이블 속성 변경
    - **예시)** `학생` 테이블에 `이메일` 컬럼 추가
    
    ```sql
    ALTER TABLE 학생
    ADD 이메일 VARCHAR(100);
    ```
    
- **DROP:** 테이블 삭제
    - **예시)** `학생` 테이블 삭제
    
    ```sql
    DROP TABLE 학생;
    ```
    

### 데이터 조작 언어(DML)

데이터베이스 내의 데이터를 조회, 삽입, 수정, 삭제하는 명령어

- **SELECT:** 데이터 조회
    - **예시)** `학생` 테이블에서 모든 학생의 이름과 나이 조회
    
    ```sql
    SELECT 이름, 나이 FROM 학생;
    ```
    
- **INSERT:** 데이터 삽입
    - **예시)** `학생` 테이블에 새로운 학생 데이터 삽입
    
    ```sql
    INSERT INTO 학생 (학생ID, 이름, 나이, 전공)
    VALUES (1, '홍길동', 20, '컴퓨터공학');
    ```
    
- **UPDATE:** 데이터 수정
    - **예시)** `학생` 테이블에서 특정 학생의 전공을 '정보보호'로 수정
    
    ```sql
    UPDATE 학생
    SET 전공 = '정보보호'
    WHERE 학생ID = 1;
    ```
    
- **DELETE:** 데이터 삭제
    - **예시)** `학생` 테이블에서 `학생ID`가 1인 학생 데이터 삭제
    
    ```sql
    DELETE FROM 학생
    WHERE 학생ID = 1;
    ```
    

### JOIN과 서브쿼리

- **JOIN**: 여러 테이블을 결합하여 관련 데이터를 조회하는 방법
    - **내부 조인(Inner Join)**: 조건에 맞는 행만 결합
    - **예시)** 학생과 성적 테이블을 학생ID 기준으로 내부 조인
    
    ```sql
    SELECT 학생.이름, 성적.과목, 성적.점수
    FROM 학생
    INNER JOIN 성적 ON 학생.학생ID = 성적.학생ID;
    ```
    
- **서브쿼리**: 다른 쿼리 안에 포함된 쿼리
    - **단일 행 서브쿼리**: 서브쿼리가 하나의 결과만 반환
    - **다중 행 서브쿼리**: 서브쿼리가 여러 행을 반환
    - **인라인 뷰 (Inline View)**: 서브쿼리가 FROM 절에 포함되어 하나의 테이블처럼 사용된다.
    - **예시)** 성적이 가장 높은 학생의 이름 조회
    
    ```sql
    SELECT 이름
    FROM 학생
    WHERE 학생ID = (
        SELECT 학생ID
        FROM 성적
        ORDER BY 점수 DESC
        LIMIT 1
    );
    ```
    

### 데이터 제어 언어(DCL)

데이터베이스에 접근하고 객체들을 사용할 수 있게 권한을 제어하는 명령어

- **GRANT:** 권한 부여
    - **예시)** 사용자 `홍길동`에게 `학생` 테이블의 조회 권한 부여
    
    ```sql
    GRANT SELECT ON 학생 TO 홍길동;
    ```
    
- **REVOKE:** 권한 회수
    - **예시)** 사용자 `홍길동`에게서 `학생` 테이블의 조회 권한 회수
    
    ```sql
    REVOKE SELECT ON 학생 FROM 홍길동;
    ```
    

### 트랜잭션 제어 언어(TCL)

데이터베이스 트랜잭션을 관리하는 명령어

- **COMMIT**: 트랜잭션을 **확정**하여 데이터베이스에 반영
    - **예시)** 데이터를 삽입한 후 변경 사항을 데이터베이스에 저장
    
    ```sql
    COMMIT;
    ```
    
- **ROLLBACK**: 트랜잭션을 **되돌리기** (실행된 작업을 취소)
    - **예시)** 데이터 삽입을 취소하고 이전 상태로 되돌리기
    
    ```sql
    ROLLBACK;
    ```
    
- **SAVEPOINT**: 트랜잭션 내에서 **지점 설정** (특정 시점으로 롤백 가능)
    - **예시)** 트랜잭션 내에서 중간 저장점을 설정
    
    ```sql
    SAVEPOINT Savepoint1;
    ```

## 트랜잭션과 동시성 제어

### 트랜잭션의 개념

데이터베이스에서 하나의 논리적 작업 단위로, 데이터베이스의 상태를 변경하는 일련의 작업들을 포함한다. 트랜잭션은 **모두 성공적으로 완료되거나, 전혀 수행되지 않아야** 하는 원칙을 가진다.

- **예시):** 은행 계좌 이체에서 **A 계좌에서 금액을 출금하고 B 계좌에 입금하는** 두 작업을 하나의 트랜잭션으로 처리한다. 만약 중간에 실패하면 **두 작업 모두 롤백**되어야 한다.

### 트랜잭션 특성(ACID)

1. **Automicity (원자성)**:
    - 트랜잭션은 하나의 작업처럼 처리되며, 모든 작업이 **완전히 수행되거나** 전혀 수행되지 않아야 한다.
    - **예시)** A 계좌에서 1000원을 출금하고 B 계좌에 입금하는 두 작업이 하나의 트랜잭션으로 처리된다. 만약 입금 작업만 성공하고 출금 작업이 실패하면, 전체 트랜잭션은 실패해야 한다.
2. **Consistency (일관성)**:
    - 트랜잭션이 완료되면 데이터베이스는 항상 일관된 상태로 변환되어야 한다. 즉, 트랜잭션 전후의 데이터는 규칙을 따르고 있어야 한다.
    - **예시)** 은행 시스템에서 **계좌 잔액이 음수가 될 수 없**다는 규칙이 있다면, 트랜잭션이 완료되면 계좌 잔액이 음수 상태로 남지 않아야 한다.
3. **Durability (영속성)**:
    - 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템이 장애를 겪더라도 영구적으로 반영되어야 한다.
    - **예시)** 은행 계좌 이체가 완료되면, 시스템이 다운되더라도 해당 거래 내역은 **복구 후에도** 유지되어야 한다.
4. **Isolation (격리성)**:
    - 동시에 여러 트랜잭션이 실행되더라도 각 트랜잭션은 **다른 트랜잭션의 중간 상태를 볼 수 없어야** 한다.
    - **예시)** A 계좌에서 1000원을 출금하는 트랜잭션이 진행 중일 때, 다른 트랜잭션이 A 계좌의 잔액을 조회하면 **출금이 완료되지 않은 상태에서 잔액이 조회되지 않아야** 한다.

### 동시성 문제

- **갱신 손실 (Lost Update)**:
    - 두 개 이상의 트랜잭션이 동일한 데이터를 수정하면서 하나의 수정 결과가 손실되는 문제.
    - **예시)** 트랜잭션 T1과 T2가 동일한 계좌 잔액을 수정하는데, T1이 잔액을 1000원으로 수정하고 T2도 같은 값을 수정하면 T1의 수정이 손실된다.
- **비일관성 읽기 (Uncommitted Data Read)**:
    - 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 문제.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 변경하는 중에 트랜잭션 T2가 그 변경된 값을 읽어버리면, T2는 유효하지 않은 데이터를 읽게 된다.
- **비반복 읽기 (Non-repeatable Read)**:
    - 트랜잭션이 데이터를 한 번 읽은 후, 같은 데이터를 다시 읽을 때 값이 달라지는 문제.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회한 후, 트랜잭션 T2가 같은 계좌의 잔액을 수정하고 T1이 다시 조회했을 때 잔액이 달라지는 경우이다.

### 트랜잭션 격리 수준

트랜잭션 간의 **동시성 제어**를 위해 설정할 수 있는 수준을 정의하며, 각 수준은 동시성 문제를 어느 정도 허용하는지에 따라 다르다.

- **Read Uncommitted (읽기 미확정)**:
    - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있다. 가장 낮은 격리 수준으로 동시성 문제를 가장 많이 발생시킬 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 수정 중일 때, 트랜잭션 T2가 그 값을 읽을 수 있다.
- **Read Committed (읽기 확정)**:
    - 트랜잭션이 커밋된 데이터만 읽을 수 있다. 비일관성 읽기는 방지하지만, 비반복 읽기는 여전히 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 수정 중일 때, 트랜잭션 T2는 그 값을 읽을 수 없다.
- **Repeatable Read (반복 가능한 읽기)**:
    - 트랜잭션이 읽은 데이터는 트랜잭션 종료까지 변경될 수 없다. 비반복 읽기를 방지하지만, 갱신 손실이나 비일관성 읽기는 여전히 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회한 후, 다른 트랜잭션이 그 값을 변경할 수 없다.
- **Serializable (직렬화 가능)**:
    - 트랜잭션이 다른 트랜잭션의 영향을 전혀 받지 않으며, 모든 트랜잭션은 마치 순차적으로 실행된 것처럼 격리된다. 가장 높은 격리 수준으로 성능 저하가 발생할 수 있다.
    - **예시)** 트랜잭션 T1이 계좌 잔액을 조회하고 있는 동안, 다른 트랜잭션은 그 계좌에 접근할 수 없다.

### 동시성 제어 기법

- **잠금 (Locking)**:
    - 트랜잭션이 데이터를 수정할 때, 해당 데이터에 대해 **잠금을 설정**하여 다른 트랜잭션이 동시에 접근하지 못하게 한다.
        - **예시)** 트랜잭션 T1이 계좌 잔액을 수정하는 동안, T2는 그 계좌에 접근할 수 없다.
- **타임스탬프 (Timestamp Ordering)**:
    - 트랜잭션에 고유의 타임스탬프를 부여하고, 트랜잭션이 수행하는 연산을 타임스탬프 순으로 정렬하여 동시성 문제를 해결한다.
        - **예시)** 트랜잭션 T1이 1000원 출금 작업을 먼저 시작했으면, T2는 T1이 완료될 때까지 해당 계좌에 접근할 수 없다.
     
## 데이터베이스 설계

### 데이터베이스 설계 단계

- **요구사항 분석**:
    - 데이터베이스가 지원해야 할 비즈니스 프로세스와 기능을 정의한다.
    - 사용자 요구사항과 데이터를 수집하여 데이터베이스 설계 목표 설정한다.
1. **개념적 설계**: 
    - 데이터베이스에 저장될 주요 엔터티와 그 관계를 정의한다.
    - 데이터 구조를 시각화하기 위해 **ER 다이어그램(Entity-Relationship Diagram)** 작성한다.
2. **논리적 설계**: 
    - 개념적 설계를 기반으로 **논리적 데이터 모델**을 설계한다.
    - 테이블, 속성, 키, 관계, 제약 조건 등을 정의한다.
    - **정규화** 과정을 통해 데이터 구조를 최적화한다.
3. **물리적 설계**: 
    - 논리적 설계를 실제 데이터베이스 관리 시스템(DBMS)에 맞게 구현한다.
    - 저장소 구조, 인덱스, 파티셔닝 등 성능 최적화를 고려한다.

### 스키마 설계

- **개념 스키마**:
    - 데이터베이스의 논리적인 구조를 정의한다. 데이터가 어떻게 구성될지, 그 관계는 무엇인지 등을 설명한다.
    - **예시)** 학교 데이터베이스에서 "학생", "성적", "과목" 테이블 등.
- **논리 스키마**:
    - 개념 스키마를 실제 데이터베이스에 맞게 구조화한다. 특정 DBMS에서 사용될 데이터 타입, 제약조건 등을 정의한다.
    - **예시)** "학생" 테이블의 "학생ID"는 정수형, "이름"은 문자열, "입학년도"는 연도 형식으로 설정한다.
- **물리 스키마**:
    - 데이터베이스가 데이터를 실제로 어떻게 저장할지를 정의한다. 물리적인 저장소와 관련된 세부 사항을 다룬다.
    - **예시)** 테이블 데이터를 디스크에 저장할 때, 데이터를 어떤 방식으로 블록에 나눠 저장할지 결정한다.

### 인덱스 설계

- **인덱스:** 데이터베이스 테이블의 검색 속도를 향상시키기 위해 사용하는 자료 구조
    - 일반적으로 **검색을 빠르게 하기 위해** 테이블의 특정 컬럼에 대한 포인터(주소)를 저장하는 방식으로 작동한다.
- **클러스터드 인덱스 (Clustered Index)**:
    - 데이터가 인덱스 순서대로 실제 테이블 내에서 물리적으로 저장된다. 각 테이블은 **하나의 클러스터드 인덱스**만 가질 수 있다. (기본 키가 클러스터드 인덱스인 경우가 많다.)
    - 데이터를 정렬된 순서대로 저장하기 때문에 검색이 매우 빠르지만, 데이터 삽입/삭제 시 성능 저하가 있을 수 있다.
    - **예시)** 학생 테이블에서 "학생ID"를 클러스터드 인덱스로 설정하면, 학생ID에 따라 데이터가 물리적으로 정렬되어 저장된다.
    
    ```sql
    CREATE TABLE 학생 (
        학생ID INT PRIMARY KEY,  -- 기본 키로 클러스터드 인덱스 자동 생성
        이름 VARCHAR(100),
        입학년도 INT
    );
    ```
    
- **비클러스터드 인덱스 (Non-clustered Index)**:
    - 인덱스가 데이터 테이블과 별도로 저장된다. **여러 개의 비클러스터드 인덱스**를 생성할 수 있으며, 데이터가 테이블에 물리적으로 순서대로 저장되지 않기 때문에 클러스터드 인덱스보다 검색 속도는 상대적으로 느리지만, 인덱스는 더 유연하게 관리할 수 있다.
    - **예시)** 학생 테이블에서 "이름"에 대해 비클러스터드 인덱스를 설정하여 이름을 빠르게 검색할 수 있게 한다.
    
    ```sql
    CREATE INDEX idx_이름 ON 학생(이름);
    ```
    
- **B-Tree 인덱스**:
    - 데이터가 트리 구조로 저장되어 빠르게 검색할 수 있습니다. **클러스터드 인덱스나 비클러스터드 인덱스**에서 자주 사용된다.
    - **검색, 삽입, 삭제** 등의 작업이 모두 효율적으로 처리된다.
    - **예시)** 학생 테이블의 "학생ID"를 B-Tree 인덱스로 설정하여 학생을 ID로 빠르게 찾을 수 있다.
    
    ```sql
    CREATE INDEX idx_학생ID ON 학생(학생ID);
    ```
    
    - 동작 방식:
        - `학생ID`가 작은 값에서 큰 값으로 트리 형태로 정렬되어 저장된다.
        - 예를 들어, `학생ID = 1001`을 검색하려고 하면 B-Tree 구조에서 빠르게 `학생ID` 값이 1001인 학생을 찾을 수 있다.
- **Hash 인덱스**:
    - 데이터를 해시 함수로 계산하여 특정 값에 대한 직접적인 접근을 제공한다. 특정 검색에 유용하다.
    - **동일한 값에 대해 고유한 해시 값을 생성**하여 해당 위치로 바로 접근할 수 있고, 주로 등호 연산(=)을 사용하는 경우에 유용하다.
    - 예시) 학생 테이블에서 "학생ID"를 해시 인덱스로 설정하여 학생ID에 대한 빠른 검색을 할 수 있다.
    
    ```sql
    CREATE INDEX idx_학생ID_hash ON 학생 USING HASH(학생ID);
    ```
    
    - **동작 방식:**
        - `학생ID`가 주어지면, 해당 값은 해시 함수에 의해 고유한 해시 값으로 변환된다.
        - 예를 들어, `학생ID = 1001`이 주어졌을 때, 해시 함수는 이 값을 특정 주소로 매핑하여 바로 해당 데이터를 찾아낸다.

## 데이터 무결성과 보안

### 무결성 제약 조건

- **기본 키 (Primary Key)**:
    - 테이블에서 각 행을 고유하게 식별하는 데 사용되는 키
    - 기본 키는 NULL 값을 가질 수 없으며, 테이블 내에서 유일해야 한다.
    - **예시)** 학생 테이블에서 "학생ID"가 기본 키로 설정되면, 각 학생ID는 유일하며 NULL 값을 가질 수 없다.
- **외래 키 (Foreign Key)**:
    - 다른 테이블의 기본 키를 참조하는 키로, 테이블 간 관계를 설정한다.
    - **예시)** 성적 테이블에서 "학생ID"는 학생 테이블의 기본 키를 참조하는 외래 키로 설정되어, 성적은 해당 학생에게만 할당된다.
- **고유성 (Uniqueness)**:
    - 특정 속성 값이 테이블 내에서 유일해야 한다는 제약이다.
    - **예시**: 이메일 주소는 각 사용자마다 유일해야 하므로, "이메일" 컬럼에 고유 제약을 설정할 수 있습니다.
- **도메인 제약 (Domain Constraint)**: ****
    - 각 컬럼이 가질 수 있는 값의 범위를 제한한다. 데이터 유형, 길이, 형식 등을 제약할 수 있다.
    - **예시)** "나이" 컬럼은 정수형으로만 설정하고, 0 이상의 값을 가져야 한다는 제약을 추가할 수 있다.

### 보안과 권한 관리

- **사용자 인증과 역할 (User Authentication and Roles)**:
    - **사용자 인증**: 사용자가 데이터베이스에 접근하려면 유효한 자격 증명이 필요하다. 이를 통해 사용자를 확인하고, 권한을 부여한다.
    - **역할 (Roles)**: 역할은 특정 권한을 사용자에게 부여하는 방법으로, 특정 작업을 수행할 수 있는 권한을 사용자에게 할당한다.
    - **예시)** 관리자 역할은 데이터베이스 관리 권한을, 사용자 역할은 조회만 할 수 있는 권한을 부여한다.
    
    ```sql
    CREATE ROLE 관리자;
    GRANT SELECT, INSERT, UPDATE, DELETE ON 학생 TO 관리자;
    ```
    
- **데이터 암호화와 전송 보안 (Data Encryption and Transmission Security)**:
    - **데이터 암호화**: 저장된 데이터를 암호화하여 무단 접근을 방지한다. 데이터를 읽는 사람만 복호화할 수 있어야 한다.
    - **예시)** 사용자 비밀번호를 암호화하여 저장하고, 저장된 암호화된 비밀번호를 복호화하여 로그인 검증에 사용하는 방식
    
    ```sql
    -- 비밀번호 암호화 저장 예시(MySQL에서는 AES_ENCRYPT 사용)
    INSERT INTO 사용자 (이름, 비밀번호)
    VALUES ('홍길동', AES_ENCRYPT('myPassword123', 'encryptionKey'));
    
    -- 비밀번호 복호화하여 비교 예시
    SELECT 이름
    FROM 사용자
    WHERE AES_DECRYPT(비밀번호, 'encryptionKey') = 'myPassword123';
    ```
    
    - **전송 보안**: 네트워크를 통해 전송되는 데이터를 보호하기 위해 SSL/TLS 같은 프로토콜을 사용하여 데이터를 암호화한다.
    - **예시)** 데이터베이스 서버와 클라이언트 간의 연결을 SSL/TLS로 암호화하여, 네트워크를 통한 데이터 도청을 방지한다.
 
## 데이터베이스 성능 최적화

### 실행 계획(Execution Plan) 분석

- 데이터베이스가 특정 쿼리를 실행하기 위한 최적의 경로를 결정하는 과정.
- 데이터베이스 엔진은 쿼리를 실행할 때 다양한 방법을 고려하고, 이를 기반으로 실행 계획을 생성하여 쿼리 성능을 최적화한다.
- **예시)** MySQL에서 `EXPLAIN` 명령어를 사용하여 실행 계획을 확인할 수 있다.
    - 쿼리가 어떻게 실행될지에 대한 정보(테이블 스캔, 인덱스 사용 여부 등)를 제공한다.
    
    ```sql
    EXPLAIN SELECT * FROM 학생 WHERE 나이 > 20;
    ```
    

### 쿼리 최적화

- **인덱스 활용**: 인덱스를 활용하여 데이터 검색 속도를 향상시킬 수 있다. 인덱스를 사용하면 특정 열에 대해 빠르게 검색할 수 있어 쿼리 성능을 크게 개선할 수 있다.
- **예시)** `학생` 테이블에서 `학생ID`를 기준으로 검색할 때, 해당 열에 인덱스를 추가하여 검색 성능을 향상시킬 수 있다.
    
    ```sql
    CREATE INDEX idx_student_id ON 학생(학생ID);
    ```
    

### 정규화와 비정규화의 균형

- **정규화**
    - 데이터 중복을 최소화하고 무결성을 보장하기 위한 설계 방법
    - 데이터의 중복을 줄여서 저장 공간을 절약하고, 데이터의 무결성을 유지할 수 있다.
    - 지나치게 정규화된 데이터베이스는 **조인**이 많아져 성능에 영향을 미칠 수 있는 단점이 있다.
    - **예시)** `학생` 테이블과 `성적` 테이블을 분리하여 정규화
    
    ```sql
    CREATE TABLE 학생 (
        학생ID INT PRIMARY KEY,
        이름 VARCHAR(100),
        나이 INT
    );
    
    CREATE TABLE 성적 (
        성적ID INT PRIMARY KEY,
        학생ID INT,
        과목 VARCHAR(100),
        점수 INT,
        FOREIGN KEY (학생ID) REFERENCES 학생(학생ID)
    );
    ```
    
- **비정규화**
    - 성능을 최적화하기 위해 일부 데이터를 중복하여 저장하는 방법
    - 데이터를 중복 저장함으로써 조인의 필요성을 줄이고 성능을 최적화할 수 있으며, 주로 읽기 성능을 향상시킬 수 있다.
    - 데이터 중복으로 인해 저장 공간이 늘어나고, 데이터 무결성 관리가 어려워질 수 있다.
    - 예시) `학생`과 `성적` 테이블을 비정규화하여 성적 테이블에 `이름` 컬럼을 추가
    
    ```sql
    CREATE TABLE 성적 (
        성적ID INT PRIMARY KEY,
        학생ID INT,
        이름 VARCHAR(100),
        과목 VARCHAR(100),
        점수 INT
    );
    ```
    

### 파티셔닝

**하나의 테이블을 논리적으로 나누어** 저장하는 데이터베이스 설계 기법으로, 대량의 데이터를 효율적으로 관리하고 성능을 최적화하는 데 사용된다.

- **수평 파티셔닝 (Horizontal Partitioning)**:
    - 데이터를 행 단위로 여러 테이블에 분할하여 데이터의 일부만 저장하는 방식이다. 주로 데이터를 시간, 지역 등으로 나누어 성능을 최적화한다.
    - **예시)** 사용자 데이터를 년도별로 나누어 저장할 수 있다.
    
    ```sql
    CREATE TABLE 사용자_2020 LIKE 사용자;
    CREATE TABLE 사용자_2021 LIKE 사용자;
    ```
    
- **수직 파티셔닝 (Vertical Partitioning)**:
    - 테이블의 컬럼을 기준으로 데이터를 분할하는 방식이다. 자주 조회되는 열과 자주 변경되지 않는 열을 분리하여 저장할 수 있다.
    - 필요한 데이터만 조회하여 **I/O 작업량을 줄이고 성능을 최적화**하고 테이블의 크기를 줄여 관리와 저장 효율성을 높일 수 있다.
    - 분리된 테이블에서 데이터를 다시 결합해야 할 경우 조인 비용이 발생하고, 데이터 설계가 복잡해질 수 있다.
    - **예시)** `학생` 테이블에서 학생의 기본 정보와 성적 정보를 분리하여 성능을 최적화한다.
    
    ```sql
    CREATE TABLE 학생_기본정보 (
        학생ID INT PRIMARY KEY,
        이름 VARCHAR(100),
        나이 INT
    );
    
    CREATE TABLE 학생_성적 (
        학생ID INT,
        과목 VARCHAR(100),
        점수 INT,
        FOREIGN KEY (학생ID) REFERENCES 학생_기본정보(학생ID)
    );
    ```
    

### 샤딩과 데이터 분산

- **샤딩(Sharding)**:
    - 데이터를 여러 **독립적인 데이터베이스나 서버**에 분산하여 저장하는 방식이다. 각 샤드는 데이터를 나누는 기준(지역, 사용자 ID 등)에 따라 저장되고 서로 독립적이며, 같은 데이터 스키마를 가진다.
    - 확장성이 뛰어나고 샤드 추가를 통해 저장 용량과 처리 성능을 확장할 수 있다. 대규모 데이터를 병렬로 처리할 수 있어 성능이 향상된다.
    - 데이터가 분산되므로 여러 샤드에 걸친 쿼리를 처리하기 복잡하다. 샤딩 로직(샤드 키 설정, 데이터 라우팅 등)을 직접 설계하고 관리해야 한다.
    - **예시)** 대규모 온라인 쇼핑몰에서 사용자 데이터를 지역별로 분리하여 여러 서버에 저장할 수 있다.
    
    ```sql
    CREATE TABLE 사용자_서울 LIKE 사용자;
    CREATE TABLE 사용자_부산 LIKE 사용자;
    ```
    
- **데이터 분산 (Data Distribution)**:
    - 데이터를 여러 시스템에 분산하여 저장하고, 각 시스템에서 처리하도록 하는 방법이다. 이를 통해 데이터 처리의 부하를 분산시킬 수 있다.
    - 대규모 데이터를 병렬 처리할 수 있어 효율적이. 데이터 처리 속도가 빨라지고, 시스템 부하가 감소한다.
    - 데이터 동기화 및 일관성을 유지하는 데 추가적인 관리가 필요하다. 분산 환경에서의 장애 처리 및 복구가 복잡해질 수 있다.
    - **예시)** 대용량 로그 데이터를 여러 서버에 분산하여 저장하고, 각 서버에서 데이터를 처리하는 방식이다.
    
    ```sql
    CREATE TABLE 로그_서버1 LIKE 로그;
    CREATE TABLE 로그_서버2 LIKE 로그;
    ```

## 비관계형 데이터베이스 (NoSQL)

### NoSQL 개요와 특징

**NoSQL**(Not Only SQL)은 관계형 데이터베이스와는 다른 구조를 가지며, 대규모 데이터와 분산 시스템에서 유용하게 사용된다.

- **특징:**
    - **스키마 유연성**: 고정된 스키마가 없어 데이터를 자유롭게 저장할 수 있다.
    - **대량 데이터 처리**: 분산 저장과 수평 확장이 가능해 빅데이터 처리에 적합하다.
    - **수평 확장성**: 서버를 추가하여 시스템 용량과 성능을 쉽게 확장할 수 있다.

### NoSQL의 유형

- **키-값 저장소 (Key-Value Stores)**
    - 데이터를 키와 값의 쌍으로 저장한다.
    - 읽기/쓰기 성능이 간단하고 빠르다.
    - **예시)** Redis, DynamoDB
    - **사용 사례:** 세션 정보 저장, 캐싱
    
    ```
    Key: User123
    Value: {"name": "Alice", "age": 30}
    ```
    
- **문서형 데이터베이스 (Document Databases)**
    - 데이터를 JSON, BSON과 같은 문서 형태로 저장한다.
    - 복잡한 데이터 구조를 효율적으로 관리 가능하다.
    - **예시**: MongoDB, CouchDB
    - **사용 사례**: 콘텐츠 관리 시스템(CMS), e-커머스 플랫폼
    
    ```json
    {
      "userId": "User123",
      "name": "Alice",
      "orders": [
        {"orderId": "A001", "amount": 100},
        {"orderId": "A002", "amount": 200}
      ]
    }
    ```
    
- **열 기반 데이터베이스 (Column-Family Databases)**
    - 데이터를 열 단위로 저장하여 대규모 읽기/쓰기에 적합하다.
    - 빅데이터 분석 및 실시간 데이터 처리에 효율적이다.
    - **예시**: Cassandra, HBase
    - **사용 사례**: 로그 데이터 저장, 분석 작업
    
    ```
    RowKey: User123
    Column: Name="Alice", Age=30, Location="Seoul"
    ```
    
- **그래프 데이터베이스 (Graph Databases)**
    - 데이터 간의 관계를 그래프 구조로 표현한다.
    - 관계 탐색 및 분석에 강점이다.
    - **예시**: Neo4j, ArangoDB
    - **사용 사례**: 소셜 네트워크, 추천 시스템
    
    ```
    Node: User123
    Relationships: Follows -> User456, Likes -> Post789
    ```
    

### CAP 이론과 BASE 모델

- **CAP 이론**
    - 분산 시스템에서 **Consistency(일관성)**, **Availability(가용성)**, **Partition Tolerance(파티션 허용성)** 중 두 가지만 선택할 수 있다는 이론
        - **일관성 (Consistency)**: 모든 노드에 데이터가 동일하게 반영된다.
        - **가용성 (Availability)**: 요청이 항상 응답을 받을 수 있다.
        - **파티션 허용성 (Partition Tolerance)**: 네트워크 분리 상황에서도 시스템이 동작을 유지한다.
    - 예시) DynamoDB는 **가용성**과 **파티션 허용성**을 우선시하며, MongoDB는 **일관성**과 **파티션 허용성**을 우선시하는 경우가 많다.
- **BASE 모델**
    - **Basically Available**: 시스템은 항상 동작 가능.
    - **Soft state**: 데이터는 항상 최신 상태를 보장하지 않는다.
    - **Eventual consistency**: 특정 시점 이후 데이터는 일관성을 가진다.
    - NoSQL 시스템에서 **Eventually Consistent**(결국 일관성을 유지하는 상태)를 지향한다.
    - **예시)** 소셜 네트워크에서 사용자가 게시글을 작성하면 다른 사용자에게 데이터가 약간 지연되더라도 eventually consistent 상태로 반영된다.
 
## 분산 데이터베이스

### 분산 데이터베이스의 개념

데이터를 여러 물리적 서버나 장소에 분산하여 저장하지만, **논리적으로는 하나의 데이터베이스처럼 작동**하는 시스템.

- 장애 허용성(High Availability): 특정 서버가 고장 나도 서비스 지속 가능.
- 확장성(Scalability): 시스템에 서버를 추가하여 성능 향상.
- 성능 향상: 데이터를 여러 서버에서 병렬 처리하여 성능 극대화.

### 데이터 복제

데이터를 여러 서버에 동일하게 저장하여 **가용성**과 **읽기 성능**을 향상시키는 방법.

- **마스터-슬레이브 복제(Master-Slave Replication)**
    - 한 서버(마스터)가 데이터 변경 작업을 처리하고, 다른 서버(슬레이브)는 마스터의 데이터를 복제받아 읽기 작업을 처리한다.
    - 쓰기와 읽기를 분리해 성능을 향상시키고, 읽기 요청이 많을 때 적합하다.
    - 마스터 서버 장애 시 복구 시간이 필요하다
    - **사용 사례)** 이커머스 애플리케이션에서 슬레이브 서버를 사용하여 상품 조회 요청 처리.
    
    ```
    Master: "상품 추가" → Slaves에 데이터 복제
    Slaves: "상품 목록 조회" 처리
    ```
    
- **리더-팔로워 복제(Leader-Follower Replication)**
    - 리더 서버가 모든 쓰기 작업을 처리하고, 팔로워 서버가 리더 서버의 데이터를 복제받아 읽기 요청을 처리한다.
    - 마스터-슬레이브 복제와 유사하지만, 리더와 팔로워 간 역할 변경이 가능하다.
    - **사용 사례)** 블로그 시스템에서 리더 서버가 새 게시물 저장 작업을 처리하고, 팔로워 서버가 기존 게시물 조회 작업을 처리.

### 분산 트랜잭션

여러 분산 서버에서 **데이터 일관성을 보장**하기 위해 사용하는 트랜잭션 관리 방식이다.

- **2PC(2-Phase Commit)**
    - 분산 환경에서 데이터 일관성을 보장하기 위해 사용되는 트랜잭션 프로토콜
    - 조정자(coordinator)와 참여자(participant) 간의 협의를 통해 트랜잭션을 commit 또는 rollback한다.
    - **1단계(Prepare):**
        - 조정자가 모든 참여자에게 트랜잭션 수행 가능 여부를 요청한다.
        - 참여자는 준비 상태라면 "Yes", 아니면 "No"를 응답한다.
    - **2단계(Commit):**
        - 모든 참여자가 "Yes"를 응답하면 트랜잭션 commit
        - 한 명이라도 "No"를 응답하면 rollback 수행
    - **예시)** 은행 송금 시스템:
        - A 은행에서 B 은행으로 송금.
        - A 은행에서 잔액 감소를 준비(Prepare), B 은행에서 잔액 증가를 준비(Prepare).
        - 모든 준비 완료 시 Commit, 하나라도 실패 시 Rollback.

### 분산 시스템의 데이터 일관성

데이터 복제와 분산 트랜잭션에서 **데이터 일관성**을 유지하는 것이 핵심이다.

- **강한 일관성 (Strong Consistency)**:
    - 모든 데이터 복제본이 항상 동일한 상태를 유지한다.
    - 데이터 읽기 시 최신 데이터가 보장한다.
    - 성능 저하 가능성
    - **예시)** 은행 시스템. 사용자가 돈을 이체할 때, 송금하는 계좌와 받는 계좌 모두 동시에 업데이트되어야 하므로, 모든 복제본이 동일한 상태를 유지해야 한다.
- **최종 일관성 (Eventual Consistency)**:
    - 모든 복제본이 결국 일관된 상태에 도달하는 것을 보장한다.
    - 성능은 높지만, 읽기 시점에 최신 데이터 보장이 어렵다.
    - **예시)** SNS. 사용자 게시물이 여러 서버에 분산되어 저장되지만, 사용자가 게시물을 작성하거나 수정할 때, 일시적으로 다른 사용자는 해당 게시물이 보이지 않을 수 있다. 하지만 시스템은 시간이 지나면 모든 사용자에게 동일한 게시물이 보이도록 최종적으로 일관성을 유지한다.
- **약한 일관성 (Weak Consistency)**:
    - 일관성에 대한 요구를 완화하여 성능과 확장성을 극대화한다.
    - 최신 데이터 보장이 없으며, 특정 사용 사례에서 사용한다.
    - **예시)** 캐시 시스템. 웹 애플리케이션에서 자주 요청되는 데이터를 캐시에 저장한다. 캐시된 데이터는 주기적으로 원본 데이터베이스와 동기화되지만, 사용자는 최신 데이터가 아닌 캐시된 데이터를 보게 될 수 있다.
 
## 데이터베이스 관리 및 백업

### 백업 전략

데이터베이스의 데이터를 보호하고 복구할 수 있도록 체계적인 백업 전략을 수립하는 것이 중요하다.

- **풀 백업:** 데이터베이스 전체를 백업하는 방식
    - 백업 파일만 있으면 데이터의 완전한 복구를 보장한다.
    - 백업 시간이 오래 걸리고 스토리지 공간을 많이 사용한다.
    - **예시)** 주기적으로 수행하며, 주요 업데이트 전에 실행한다.
        - 회사의 고객 관리 데이터베이스를 매주 풀 백업하여 시스템 장애 발생 시 전체 데이터를 복원
- **증분 백업:** 이전 백업 이후 변경된 데이터만 백업
    - 백업 시간이 짧고, 저장 공간 절약할 수 있는 장점이 있다.
    - 복구시 모든 증분 백업과 풀 백업을 사용해야 하므로 오래 걸릴 수 있다.
    - **예시)** 자주 변경되는 데이터베이스에 적합하다.
        - 전자상거래 시스템에서 일일 증분 백업을 수행하여 주문 데이터 손실 최소화
- **차등 백업:** 마지막 풀 백업 이후 변경된 데이터를 백업
    - 복구 시 풀 백업과 최신 차등 백업만 필요하고 증분 백업보다 복구 시간이 짧다
    - 시간이 지남에 따라 백업 크기가 증가하는 단점이 있다.
    - **예시)** 주간 풀 백업 후 일일 차등 백업 사용한다.
        - 금융 데이터베이스에서 주말에 풀 백업을 수행하고 주중에는 차등 백업으로 데이터 보호.

### 장애 복구

데이터 손실을 최소화하고 복구 시간을 단축하기 위한 방법

- **로그 기반 복구(Log-Based Recovery):** 트랜잭션 로그를 이용해 장애 시점까지 데이터를 복구하는 방식
    - 최소한의 데이터 손실로 복구 가능하고 연속적인 작업 환경을 지원한다.
    - 로그 파일 관리가 복잡하고 로그 크기 증가 시 성능 저하가 우려된다.
    - **예시)** 은행 시스템의 트랜잭션 로그를 사용해 실시간 복구
        - 고객 계좌 이체 도중 장애 발생 시 트랜잭션 로그를 활용해 데이터 무결성 유지
- **체크포인트(Checkpoint):** 데이터베이스의 상태를 특정 지점에서 저장하여 복구 시 해당 지점부터 시작할 수 있도록 하는 기술
    - 로그의 일부를 정리해 복구 시간을 단축한다.
    - 디스크와 메모리 간 데이터 동기화
    - **예시)** 대규모 트랜잭션 실행 전 체크포인트 설정
        - 대규모 재고 업데이트 전 체크포인트를 생성하여 장애 발생 시 업데이트 이전 상태로 복원.
- **즉각 복구:** 데이터 손실을 최소화하기 위해 장애 발생 직후 데이터를 복구하는 방식
    - 트랜잭션 로그와 체크포인트를 조합하여 복구
    - **예시)** 의료 데이터 시스템의 장애 즉시 복구
        - 환자 기록 시스템 장애 시 즉각 복구로 중요한 데이터를 실시간으로 복원.

### 데이터베이스 모니터링

성능과 상태를 점검하고 문제를 사전에 탐지하기 위한 과정

- **성능 모니터링**
    - CPU, 메모리, 디스크 사용률 및 쿼리 성능 점검.
    - **예시)** 데이터베이스가 과부하 상태일 때, 병목 구간 확인 및 최적화.
- **쿼리 최적화**
    - 느린 쿼리를 분석하고 인덱스를 추가하거나 리팩토링.
    - **예시)** 고객 주문 조회 속도를 개선하기 위해 인덱스 생성.
- **이벤트 로그 분석**
    - 데이터베이스 장애 및 오류 이벤트 로그를 분석하여 문제 원인 파악.
    - **예시)** 트랜잭션 실패 로그를 통해 데이터베이스 커넥션 문제 식별.
- **백업 상태 점검**
    - 백업의 최신 상태를 확인하고, 주기적 복원 테스트 수행.
    - **예시)** 주간 백업이 정상적으로 완료되었는지 점검하고 복구 테스트를 통해 신뢰성 검증.
