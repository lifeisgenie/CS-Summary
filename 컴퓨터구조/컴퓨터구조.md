# 컴퓨터 구조

## 컴퓨터구조와 개요 (Introduction to Computer Architecture)

### 컴퓨터 구조란 무엇인가?

컴퓨터 시스템의 동작 원리를 이해하기 위한 설계 및 구조적 요소를 연구하는 학문이다. 하드웨어와 소프트웨어 간의 상호작용을 분석하고, 성능 최적화를 위한 설계 원칙을 탐구한다.

- 목표: 고성능, 효율적인 자원 활용, 비용 절감을 통해 최적화된 시스템을 설계한다.
- **주요 연구 분야**: 프로세서 설계, 메모리 계층, 입출력 시스템, 병렬 처리 구조

### 컴퓨터 시스템의 발전과 역사

- **1세대 (1940년대~1950년대)**: 진공관 기반 컴퓨터
    - ENIAC(1945): 최초의 전자식 디지털 컴퓨터로 10진수 기반 계산을 수행.
    - **한계**: 크기와 전력 소모가 컸고, 유지보수가 어려웠다.
- **2세대 (1950년대~1960년대)**: 트랜지스터 도입
    - 트랜지스터 기반으로 컴퓨터 크기가 작아지고 성능이 향상됨.
    - **예시)** IBM 1401.
- **3세대 (1960년대~1970년대)**: 집적회로(IC) 도입
    - 한 칩에 다수의 트랜지스터가 집적되어 성능과 효율이 대폭 증가.
    - **예시)** IBM System/360.
- **4세대 (1970년대 이후)**: 마이크로프로세서
    - 개인용 컴퓨터(PC) 등장, 컴퓨터의 상용화 확산.
    - **예시)** Intel 4004(최초의 상용 마이크로프로세서).
- **현대**: 병렬 처리와 고성능 컴퓨팅
    - 멀티코어 프로세서, 클라우드 컴퓨팅, 인공지능 특화 하드웨어.
    - **예시)** NVIDIA GPU, Tensor Processing Unit(TPU).

### 컴퓨터의 구성 요소 (Components of a Computer System)

- **중앙처리장치 (CPU: Central Processing Unit):** 명령어를 해석하고 실행하며, 시스템의 중심적인 연산을 담당한다.
    - **구성요소:** 제어 장치, 산술논리연산장치, 레지스터
- **메모리 (주기억장치: Main Memory):** CPU에서 실행할 데이터를 저장하는 공간
    - **종류**:
        - **RAM(Random Access Memory)**: 휘발성 메모리로, 프로그램 실행 중 데이터를 저장.
        - **ROM(Read-Only Memory)**: 비휘발성 메모리로, 부팅 프로그램(예: BIOS)을 저장
- **입출력 장치 (I/O Devices):** 사용자와 컴퓨터 간의 상호작용을 제공한다.
    - **예시)** 키보드, 마우스, 모니터, 프린터
- **보조기억장치:** 데이터를 영구적으로 저장하는 장치
    - **종류**: HDD(하드디스크), SSD(솔리드 스테이트 드라이브)

### 폰노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)

- **폰노이만 아키텍처:** 프로그램과 데이터를 같은 메모리 공간에서 관리하는 구조
    - 메모리 접근 시 데이터와 명령어를 동일한 버스를 통해 처리
    - 데이터와 명령어 간 버스 병목현상 발생 가능
    - **예시)** 대부분의 현대 PC와 서버는 기본적으로 폰노이만 아키텍처를 따른다.
- **하버드 아키텍처:** 프로그램과 데이터를 별도의 메모리 공간에서 관리하는 구조
    - 명령어와 데이터가 분리된 버스를 사용하므로 병목현상을 완화.
    - 효율적인 병렬 처리가 가능.
    - **예시)** 임베디드 시스템이나 DSP(Digital Signal Processor)에서 주로 사용된다.

### 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)

- **Amdahl의 법칙 (Amdahl's Law)**
    - **내용**: 시스템의 병목 구간을 최적화해야 전체 성능이 향상됨.
    - **예시)** 멀티코어 CPU에서 병렬화가 가능한 작업을 증가시키면 성능이 대폭 향상되지만, 병렬화가 어려운 작업이 남아 있다면 성능 향상이 제한된다.
- **메모리 계층 구조**
    - **내용**: 캐시, RAM, 보조기억장치 순으로 빠른 접근 속도와 적은 용량, 느린 속도와 큰 용량의 계층을 설계한다.
    - **예시)** CPU 캐시는 데이터 접근 속도를 크게 높여 CPU 대기 시간을 줄인다.
- **명령어 수준 병렬성 (Instruction-Level Parallelism)**
    - **내용**: 파이프라이닝, 슈퍼스칼라 기술을 통해 한 사이클에 여러 명령어를 처리.
    - **예시)** 최신 프로세서는 명령어를 분리하고 병렬 처리하여 성능을 극대화한다.
- **전력 효율**
    - **내용**: 성능을 유지하면서 소비 전력을 줄이는 것이 중요하다.
    - **예시)** ARM 프로세서는 모바일 장치에서 높은 전력 효율을 제공한다.
 
## 명령어 집합 구조(ISA, Instruction Set Architecture)

하드웨어와 소프트웨어 간의 인터페이스를 정의하는 컴퓨터 아키텍처의 중요한 구성 요소

- **역할**
    - 프로세서가 실행할 수 있는 명령어의 집합과 해당 명령어의 형식을 정의.
    - 운영 체제와 애플리케이션 소프트웨어가 하드웨어를 제어하는 방법을 제공.
- 구성 요소:
    - **명령어 형식**: 명령어의 구조와 필드(예: opcode, 피연산자).
    - **주소 지정 모드**: 명령어가 데이터를 참조하는 방법.
    - **데이터 형식**: 정수, 부동소수점, 벡터 데이터 등.
    - **레지스터 집합**: 프로세서가 직접 접근할 수 있는 고속 메모리 영역
- **예시)** x86과 ARM은 대표적인 ISA로, 각각 CISC와 RISC 설계를 기반으로 한다.

### CISC (Complex Instruction Set Computer)

복잡한 명령어 집합 구조를 갖춘 컴퓨터 설계 방식

- **특징**
    - **명령어의 복잡성**: 단일 명령어가 다수의 작업(예: 메모리 접근, 연산)을 처리.
    - **명령어 수의 다양성**: 수백 개에서 수천 개의 명령어를 포함.
    - **메모리 접근 빈도**: 명령어가 메모리를 직접 접근하여 작업하는 경우가 많음.
    - **명령어 길이 가변**: 명령어 길이가 고정되지 않고 다양하게 설계됨.
    - **마이크로코드 사용**: 복잡한 명령어를 구현하기 위해 하드웨어 내 마이크로코드 사용.
- **장점**
    - **프로그래머 친화적:** 고수준 명령어로 인해 어셈블리 코드를 작성하기 쉬움.
    - **메모리 절약:** 복잡한 명령어가 적은 수의 명령어로 동일 작업을 수행하므로 프로그램 크기가 작아질 수 있음.
- **단점**
    - 복잡한 하드웨어 설계로 인해 전력 소모와 제조 비용 증가.
    - 실행 시간이 명령어마다 다르므로 병렬 처리 효율이 낮음.
- **예시)**
    - **x86 아키텍처** (Intel, AMD)
        - **예시 명령어)** `MUL AX, BX`는 AX 레지스터의 값과 BX 레지스터의 값을 곱한 후 결과를 AX에 저장한다.
        - **적용 사례**: 데스크톱, 서버, 고성능 컴퓨팅.

### RISC (Reduced Instruction Set Computer)

단순하고 효율적인 명령어 집합 구조를 갖춘 컴퓨터 설계 방식

- **특징**
    - **단순한 명령어**: 대부분의 명령어는 한 사이클에서 실행되며, 고정된 길이를 가짐.
    - **명령어 수 감소**: 상대적으로 적은 수의 명령어 포함.
    - **레지스터 중심 설계**: 메모리 접근 대신 레지스터 기반 연산을 선호.
    - **고속 실행**: 명령어가 간단하므로 파이프라이닝과 같은 병렬 처리 기술에 최적화.
    - **컴파일러 의존**: 단순한 명령어를 통해 복잡한 연산을 구현하므로 컴파일러 설계가 중요.
- **장점**
    - **고성능:** 단순한 명령어가 하드웨어의 효율적 설계와 병렬 처리 가능.
    - **저전력:** 명령어 실행 효율이 높아 전력 소모가 적음.
    - **확장성:** 하드웨어 설계가 간단하여 새로운 기술 적용이 용이.
- **단점**
    - **프로그램 크기 증가:** 복잡한 작업을 여러 개의 명령어로 분해해야 하므로 코드 길이가 길어질 수 있음.
    - **프로그래밍 난이도 증가:** 고수준 언어 컴파일러가 복잡한 작업을 효율적으로 변환해야 함.
- **예시**
    - **ARM 아키텍처**(스마트폰, IoT)
        - **예시 명령어)** `ADD R0, R1, R2`는 R1과 R2의 값을 더한 결과를 R0에 저장한다.
        - **적용 사례**: 모바일 장치, 임베디드 시스템.
