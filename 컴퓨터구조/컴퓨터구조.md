# 컴퓨터 구조

## 컴퓨터구조와 개요 (Introduction to Computer Architecture)

### 컴퓨터 구조란 무엇인가?

컴퓨터 시스템의 동작 원리를 이해하기 위한 설계 및 구조적 요소를 연구하는 학문이다. 하드웨어와 소프트웨어 간의 상호작용을 분석하고, 성능 최적화를 위한 설계 원칙을 탐구한다.

- **목표:** 고성능, 효율적인 자원 활용, 비용 절감을 통해 최적화된 시스템을 설계한다.
- **주요 연구 분야**: 프로세서 설계, 메모리 계층, 입출력 시스템, 병렬 처리 구조

### 컴퓨터 시스템의 발전과 역사

- **1세대 (1940년대~1950년대)**: 진공관 기반 컴퓨터
    - ENIAC(1945): 최초의 전자식 디지털 컴퓨터로 10진수 기반 계산을 수행.
    - **한계**: 크기와 전력 소모가 컸고, 유지보수가 어려웠다.
- **2세대 (1950년대~1960년대)**: 트랜지스터 도입
    - 트랜지스터 기반으로 컴퓨터 크기가 작아지고 성능이 향상됨.
    - **예시)** IBM 1401.
- **3세대 (1960년대~1970년대)**: 집적회로(IC) 도입
    - 한 칩에 다수의 트랜지스터가 집적되어 성능과 효율이 대폭 증가.
    - **예시)** IBM System/360.
- **4세대 (1970년대 이후)**: 마이크로프로세서
    - 개인용 컴퓨터(PC) 등장, 컴퓨터의 상용화 확산.
    - **예시)** Intel 4004(최초의 상용 마이크로프로세서).
- **현대**: 병렬 처리와 고성능 컴퓨팅
    - 멀티코어 프로세서, 클라우드 컴퓨팅, 인공지능 특화 하드웨어.
    - **예시)** NVIDIA GPU, Tensor Processing Unit(TPU).

### 컴퓨터의 구성 요소 (Components of a Computer System)

- **중앙처리장치 (CPU: Central Processing Unit):** 명령어를 해석하고 실행하며, 시스템의 중심적인 연산을 담당한다.
    - **구성요소:** 제어 장치, 산술논리연산장치, 레지스터
- **메모리 (주기억장치: Main Memory):** CPU에서 실행할 데이터를 저장하는 공간
    - **종류**:
        - **RAM(Random Access Memory)**: 휘발성 메모리로, 프로그램 실행 중 데이터를 저장.
        - **ROM(Read-Only Memory)**: 비휘발성 메모리로, 부팅 프로그램(예: BIOS)을 저장
- **입출력 장치 (I/O Devices):** 사용자와 컴퓨터 간의 상호작용을 제공한다.
    - **예시)** 키보드, 마우스, 모니터, 프린터
- **보조기억장치:** 데이터를 영구적으로 저장하는 장치
    - **종류**: HDD(하드디스크), SSD(솔리드 스테이트 드라이브)

### 폰노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)

- **폰노이만 아키텍처:** 프로그램과 데이터를 같은 메모리 공간에서 관리하는 구조
    - 메모리 접근 시 데이터와 명령어를 동일한 버스를 통해 처리
    - 데이터와 명령어 간 버스 병목현상 발생 가능
    - **예시)** 대부분의 현대 PC와 서버는 기본적으로 폰노이만 아키텍처를 따른다.
- **하버드 아키텍처:** 프로그램과 데이터를 별도의 메모리 공간에서 관리하는 구조
    - 명령어와 데이터가 분리된 버스를 사용하므로 병목현상을 완화.
    - 효율적인 병렬 처리가 가능.
    - **예시)** 임베디드 시스템이나 DSP(Digital Signal Processor)에서 주로 사용된다.

### 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)

- **Amdahl의 법칙 (Amdahl's Law)**
    - **내용**: 시스템의 병목 구간을 최적화해야 전체 성능이 향상됨.
    - **예시)** 멀티코어 CPU에서 병렬화가 가능한 작업을 증가시키면 성능이 대폭 향상되지만, 병렬화가 어려운 작업이 남아 있다면 성능 향상이 제한된다.
- **메모리 계층 구조**
    - **내용**: 캐시, RAM, 보조기억장치 순으로 빠른 접근 속도와 적은 용량, 느린 속도와 큰 용량의 계층을 설계한다.
    - **예시)** CPU 캐시는 데이터 접근 속도를 크게 높여 CPU 대기 시간을 줄인다.
- **명령어 수준 병렬성 (Instruction-Level Parallelism)**
    - **내용**: 파이프라이닝, 슈퍼스칼라 기술을 통해 한 사이클에 여러 명령어를 처리.
    - **예시)** 최신 프로세서는 명령어를 분리하고 병렬 처리하여 성능을 극대화한다.
- **전력 효율**
    - **내용**: 성능을 유지하면서 소비 전력을 줄이는 것이 중요하다.
    - **예시)** ARM 프로세서는 모바일 장치에서 높은 전력 효율을 제공한다.
 
## 명령어 집합 구조(ISA, Instruction Set Architecture)

하드웨어와 소프트웨어 간의 인터페이스를 정의하는 컴퓨터 아키텍처의 중요한 구성 요소

- **역할**
    - 프로세서가 실행할 수 있는 명령어의 집합과 해당 명령어의 형식을 정의.
    - 운영 체제와 애플리케이션 소프트웨어가 하드웨어를 제어하는 방법을 제공.
- 구성 요소:
    - **명령어 형식**: 명령어의 구조와 필드(예: opcode, 피연산자).
    - **주소 지정 모드**: 명령어가 데이터를 참조하는 방법.
    - **데이터 형식**: 정수, 부동소수점, 벡터 데이터 등.
    - **레지스터 집합**: 프로세서가 직접 접근할 수 있는 고속 메모리 영역
- **예시)** x86과 ARM은 대표적인 ISA로, 각각 CISC와 RISC 설계를 기반으로 한다.

### CISC (Complex Instruction Set Computer)

복잡한 명령어 집합 구조를 갖춘 컴퓨터 설계 방식

- **특징**
    - **명령어의 복잡성**: 단일 명령어가 다수의 작업(예: 메모리 접근, 연산)을 처리.
    - **명령어 수의 다양성**: 수백 개에서 수천 개의 명령어를 포함.
    - **메모리 접근 빈도**: 명령어가 메모리를 직접 접근하여 작업하는 경우가 많음.
    - **명령어 길이 가변**: 명령어 길이가 고정되지 않고 다양하게 설계됨.
    - **마이크로코드 사용**: 복잡한 명령어를 구현하기 위해 하드웨어 내 마이크로코드 사용.
- **장점**
    - **프로그래머 친화적:** 고수준 명령어로 인해 어셈블리 코드를 작성하기 쉬움.
    - **메모리 절약:** 복잡한 명령어가 적은 수의 명령어로 동일 작업을 수행하므로 프로그램 크기가 작아질 수 있음.
- **단점**
    - 복잡한 하드웨어 설계로 인해 전력 소모와 제조 비용 증가.
    - 실행 시간이 명령어마다 다르므로 병렬 처리 효율이 낮음.
- **예시)**
    - **x86 아키텍처** (Intel, AMD)
        - **예시 명령어)** `MUL AX, BX`는 AX 레지스터의 값과 BX 레지스터의 값을 곱한 후 결과를 AX에 저장한다.
        - **적용 사례**: 데스크톱, 서버, 고성능 컴퓨팅.

### RISC (Reduced Instruction Set Computer)

단순하고 효율적인 명령어 집합 구조를 갖춘 컴퓨터 설계 방식

- **특징**
    - **단순한 명령어**: 대부분의 명령어는 한 사이클에서 실행되며, 고정된 길이를 가짐.
    - **명령어 수 감소**: 상대적으로 적은 수의 명령어 포함.
    - **레지스터 중심 설계**: 메모리 접근 대신 레지스터 기반 연산을 선호.
    - **고속 실행**: 명령어가 간단하므로 파이프라이닝과 같은 병렬 처리 기술에 최적화.
    - **컴파일러 의존**: 단순한 명령어를 통해 복잡한 연산을 구현하므로 컴파일러 설계가 중요.
- **장점**
    - **고성능:** 단순한 명령어가 하드웨어의 효율적 설계와 병렬 처리 가능.
    - **저전력:** 명령어 실행 효율이 높아 전력 소모가 적음.
    - **확장성:** 하드웨어 설계가 간단하여 새로운 기술 적용이 용이.
- **단점**
    - **프로그램 크기 증가:** 복잡한 작업을 여러 개의 명령어로 분해해야 하므로 코드 길이가 길어질 수 있음.
    - **프로그래밍 난이도 증가:** 고수준 언어 컴파일러가 복잡한 작업을 효율적으로 변환해야 함.
- **예시**
    - **ARM 아키텍처**(스마트폰, IoT)
        - **예시 명령어)** `ADD R0, R1, R2`는 R1과 R2의 값을 더한 결과를 R0에 저장한다.
        - **적용 사례**: 모바일 장치, 임베디드 시스템.

## 데이터 표현 및 연산 (Data Representation and Operations)

### 수의 체계 (Number Systems)

- **이진수 (Binary)**
    - 컴퓨터가 사용하는 2진법 숫자 체계.
    - 0과 1로만 구성되며, 각 자리는 2의 거듭제곱 값을 가짐.
    - **예시)** `1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 11₁₀`
- **10진수 (Decimal)**
    - 일반적으로 사용하는 10진법 숫자 체계.
    - 0부터 9까지 사용하며, 각 자리는 10의 거듭제곱 값을 가짐.
    - **예시)** `356₁₀ = 3×10² + 5×10¹ + 6×10⁰`
        
- **8진수 (Octal)**
    - 이진수를 3자리씩 묶어 표현.
    - 0부터 7까지 사용.
    - **예시)** `110101₂ = (110)(101)₂ = 65₈`
- **16진수 (Hexadecimal)**
    - 이진수를 4자리씩 묶어 표현.
    - 09와 AF(10~15) 사용.
    - **예시)** `11010110₂ = (1101)(0110)₂ = D6₁₆`
- **체계 간 변환**
    - **이진수 → 10진수**
        - 각 자리 값에 2의 거듭제곱을 곱해 합산.
        - **예시)** `1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 11₁₀`
    - **10진수 → 이진수**
        - 2로 나누고 나머지를 기록, 역순으로 읽음.
        - **예시)** `13₁₀ → 1101₂`
    - **이진수 ↔ 8진수**
        - 이진수를 3자리씩 묶어 변환.
        - **예시)** `110101₂ = (110)(101)₂ = 65₈`
    - **이진수 ↔ 16진수**
        - 이진수를 4자리씩 묶어 변환.
        - **예시)** `11010110₂ = (1101)(0110)₂ = D6₁₆`

### 정수와 실수 표현 (Integer and Floating-Point Representation)

- **정수 표현 (Integer Representation)**
    - **고정소수점 (Fixed-Point)**: 소수점 위치가 고정된 숫자 표현 방식
        - 부호 있는 정수는 MSB(Most Significant Bit)를 부호 비트로 사용
        - **예시)** 8비트에서 `10011001₂`는 -103 (2의 보수 표현)
- **실수 표현 (Floating-Point Representation)**
    - 부동소수점: 숫자를 가수(Mantissa)와 지수(Exponent)의 조합으로 표현
    - **IEEE 754 표준**을 사용하여 부동소수점 표현
        - **32비트 (단정밀도)**: 1비트 부호 + 8비트 지수 + 23비트 가수
        - **64비트 (배정밀도)**: 1비트 부호 + 11비트 지수 + 52비트 가수
        - 지수는 **바이어스 값**(단정밀도는 127)을 더해 저장
    - **예시)**
        1. 실수 `5.75`를 IEEE 754로 표현:
            - 부호: `0` (양수)
            - 10진수를 이진수로 변환: `101.11₂`
            - 정규화: `1.0111 × 2²`
            - IEEE 754 표현: `0 10000001 01110000000000000000000`
    - **IEEE 754 표준 (IEEE 754 Standard)**
        - **정밀도**: 단정밀도(32비트), 배정밀도(64비트)
        - **반올림 방식**: 가장 가까운 짝수로 반올림 (Round to Nearest Even)
        - **예외 상태**: NaN(Not a Number), Infinity

### 데이터 연산 (Data Operations)

- **산술 연산 (Arithmetic Operations)**
    - 덧셈, 뺄셈, 곱셈, 나눗셈 등 기본 연산 수행
- **논리 연산 (Logical Operations)**
    - **AND, OR, NOT, XOR** 등 비트 수준에서 수행
    - **예시)**
        - `1101 AND 1010 = 1000`
        - `1101 XOR 1010 = 0111`
- **시프트 연산 (Shift Operations)**
    - **논리 시프트 (Logical Shift)**: 빈 공간에 0을 채움
    - **산술 시프트 (Arithmetic Shift)**: 부호를 유지하며 시프트
    - **순환 시프트 (Rotate Shift)**: 데이터를 순환 이동
    - **예시)**
        - `1010 << 1 = 10100` (왼쪽 시프트)
        - `1101 >> 1 = 0110` (오른쪽 논리 시프트)

### Signed vs. Unsigned 데이터

- **Signed 데이터**
    - 음수와 양수를 모두 표현하며, MSB가 부호 비트로 사용됨.
    - 음수는 2의 보수(Two’s Complement)로 표현.
    - **예시)**
        - 8비트에서 `11111101₂`는 -3을 나타냄.
- **Unsigned 데이터**
    - 양수만 표현하며, MSB는 데이터의 일부로 사용됨.
    - **예시)**
        - 8비트에서 `11111101₂`는 253을 나타냄.
     
## 중앙처리장치 (CPU, Central Processing Unit)

### CPU의 구조와 구성 요소 (CPU Architecture and Components)

- **산술 논리 장치(ALU, Arithmetic Logic Unit)**
    - **역할**: 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, XOR 등)을 수행.
    - **구성**: 산술 유닛, 논리 유닛, 누산기(Accumulator).
    - **예시)**
        - 덧셈 연산: `5 + 3` → ALU가 이를 처리하여 결과를 레지스터에 저장.
        - 논리 연산: `1011 AND 1100` → 결과 `1000`
- **레지스터 (Registers)**
    - **역할**: CPU 내부에서 데이터, 주소, 명령어 등을 임시로 저장.
    - **종류**:
        - **범용 레지스터 (General-Purpose Registers)**: 데이터 저장.
        - **특수 레지스터 (Special-Purpose Registers)**: 프로그램 카운터(PC), 명령어 레지스터(IR), 스택 포인터(SP) 등.
    - **예시)**
        - **프로그램 카운터:** 다음에 실행할 명령어의 메모리 주소를 저장.
        - **명령어 레지스터:** 현재 실행 중인 명령어를 저장.
- **제어 유닛(Control Unit)**
    - **역할**: 명령어를 해독하고 CPU의 다른 구성 요소를 제어.
        - 명령어 인출(Fetch), 해독(Decode), 실행(Execute) 과정 관리.
        - 메모리와 입출력 장치와의 통신 담당.
    - **예시)** 제어 유닛이 메모리에서 명령어를 가져오고, ALU에 명령을 전달하여 연산 수행

### 명령어 사이클 (Instruction Cycle)

CPU가 명령어를 처리하는 기본 작업 흐름

- **명령어 인출(Fetch)**
    - 메모리에서 다음 실행할 명령어를 가져옴.
    - **과정**:
        1. 프로그램 카운터(PC)가 명령어의 주소를 가리킴.
        2. 제어 유닛이 해당 주소에서 명령어를 가져와 명령어 레지스터(IR)에 저장.
    - **예시)** PC = 0x0010 → 메모리[0x0010]에서 명령어 `MOV R1, #5`를 가져옴.
- **해독(Decode)**
    - 가져온 명령어를 해석하여 실행할 작업을 결정.
    - **과정**: 명령어의 연산 코드(OPCODE)와 피연산자(Operands)를 분석.
    - **예시)** `MOV R1, #5`: R1에 값 5를 저장하는 명령어로 해석.
- **실행(Execute)**
    - 해석된 명령어를 실행.
    - **과정**: ALU, 레지스터, 메모리, I/O 장치 등이 동작.
    - **예시)** `ADD R1, R2`: ALU가 R1과 R2의 값을 더해 결과를 R1에 저장.
- **메모리접근(Memory Access)**
    - 필요 시 메모리에서 데이터 읽기 또는 쓰기.
    - **예시)** `LOAD R1, 0x1000`: 메모리 주소 0x1000의 데이터를 읽어 R1에 저장.
- **쓰기 단계 (Write Back)**
    - 연산 결과를 레지스터나 메모리에 저장.
    - **예시)** ALU가 계산한 결과를 메모리 주소 0x2000에 저장.

### 메모리 접근 방식 (Memory Access Methods)

- **직접 메모리 접근 (Direct Memory Access, DMA):** CPU의 개입 없이 I/O 장치가 메모리에 직접 접근하여 데이터를 읽거나 쓴다.
    - **장점**: CPU 부하 감소, 데이터 전송 속도 향상.
    - **예시)** 대용량 파일 전송 시 DMA가 CPU 대신 메모리에서 데이터를 읽음.
- **메모리 계층 구조 (Memory Hierarchy):** CPU 접근 속도를 높이기 위해 메모리를 계층적으로 구성한다.
    - **예시)** CPU가 자주 사용하는 데이터를 캐시에 저장하여 처리 속도 향상.
- **페이지 메모리 접근 (Paging):** 메모리를 고정된 크기의 페이지로 나누어 관리한다.
    - **장점**: 메모리 단편화 감소, 가상 메모리 지원
    - **예시)** 4KB 크기의 페이지를 사용하여 10MB 데이터를 메모리에 분산 저장
- **캐시 메모리와 지역성 (Cache Memory and Locality)**
    - **시간 지역성**: 최근 사용한 데이터에 다시 접근할 확률이 높음.
    - **공간 지역성**: 가까운 주소의 데이터를 자주 접근
    - **예시)** 반복문에서 동일한 데이터에 연속적으로 접근할 때 캐시가 속도를 높인다.
 
## 메모리 구조 (Memory Architecture)

### 메모리 계층 구조 (Memory Hierarchy)

컴퓨터 시스템에서 메모리는 접근 속도, 용량, 비용에 따라 계층적으로 구성된다.

- **속도**: 레지스터 > 캐시 > 주기억장치 > 보조기억장치
- **예시)**
    - CPU는 자주 사용하는 데이터를 캐시에서 먼저 검색하여 빠르게 처리한다.
    - 대용량 데이터는 보조기억장치에서 필요 시 주기억장치로 로드한다.
- **계층 구성**
    - **레지스터(Register)**: CPU 내부에 위치하며 가장 빠른 메모리.
    - **캐시(Cache)**: CPU와 주기억장치 사이에서 데이터 접근 속도를 높임.
    - **주기억장치(Main Memory)**: 실행 중인 프로그램과 데이터를 저장.
    - **보조기억장치(Storage)**: 하드디스크(HDD), SSD 등 대용량 저장장치.

### 캐시 메모리 (Cache Memory)

CPU와 주기억장치 간 데이터 전송 속도를 향상시키기 위해 사용되는 고속 메모리

- **직접 매핑(Direct Mapping)**
    - 메모리 블록이 특정 캐시 라인에 고정적으로 매핑.
    - **장점**: 간단한 구현.
    - **단점**: 충돌(Collision) 발생 가능성 높음.
    - **예시)** 블록 5와 블록 21이 같은 캐시 라인을 점유하면 충돌 발생.
- **집합 연관(Set-Associative)**
    - 캐시를 여러 집합(Set)으로 나누고, 각 집합은 여러 캐시 라인을 포함.
    - **장점**: 충돌 감소.
    - **예시)** 블록 5와 블록 21이 서로 다른 집합에 매핑되어 충돌 방지.
- **완전 연관(Fully Associative)**
    - 메모리 블록이 어떤 캐시 라인에든 저장 가능.
    - **장점**: 충돌 없음.
    - **단점**: 검색 속도 저하.
    - **예시)** 특정 데이터를 캐시 전체에서 검색해야 하므로 비교 작업이 많아짐.
- **캐시 적중률(Cache Hit Rate)**
    - CPU가 필요한 데이터를 캐시에서 찾는 비율 (캐시 메모리의 적중 횟수/전체 메모리의 참조 횟수)
    - **예시)** 100번 메모리 접근 중 90번 캐시에 데이터 존재 → 캐시 적중률 90%

### 가상 메모리 (Virtual Memory)

물리 메모리 크기에 관계없이 큰 프로그램 실행을 가능하게 하는 메모리 관리 기법. 논리 주소(Logical Address)를 물리 주소(Physical Address)로 변환한다.

- **페이징(Paging)**
    - 메모리를 고정된 크기(Page)로 나누어 관리.
    - **장점**: 내부 단편화 해결.
    - **예시)**
        - 페이지 크기: 4KB
        - 프로세스 메모리 요구: 10KB → 3개의 페이지로 나눔.
- **세그멘테이션(Segmentation)**
    - 메모리를 가변 크기(Segment)로 나누어 관리.
    - **장점**: 프로세스 논리 구조를 반영한 메모리 관리.
    - **예시)**
        - 코드 세그먼트: 2MB, 데이터 세그먼트: 3MB.
- **페이지 교체 알고리즘(Page Replacement Algorithms)**
    - **FIFO (First-In-First-Out)**: 가장 먼저 메모리에 들어온 페이지를 교체.
        - **예시)** 페이지 1, 2, 3, 4가 순서대로 들어왔을 때:
            - 메모리 상태: [1, 2, 3]
            - 페이지 4가 들어오면 가장 먼저 들어온 페이지 1을 교체.
            - 결과 상태: [4, 2, 3]
    - **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지를 교체.
        - **예시)** 페이지 1, 2, 3, 4가 순서대로 접근되었을 때:
            - 최근 접근 순서: 4 → 3 → 2 → 1
            - 페이지 5 요청 시 가장 오랫동안 사용되지 않은 페이지 1을 교체.
            - 결과 상태: [5, 2, 3]
    - **NRU (Not Recently Used)**: 최근 사용되지 않은 페이지를 교체.
        - **예시)** 페이지 1, 2, 3, 4의 참조 비트와 수정 비트 상태가 다음과 같을 때:
            - 페이지 1: (참조 1, 수정 0)
            - 페이지 2: (참조 0, 수정 0)
            - 페이지 3: (참조 1, 수정 1)
            - 페이지 4: (참조 0, 수정 1)
            - 교체 기준에 따라 최근 사용되지 않고 수정되지 않은 페이지 2를 교체.
    - **MFU (Most Frequently Used)**: 가장 자주 사용된 페이지를 교체.
        - **예시)** 페이지 1, 2, 3, 4의 참조 횟수가 다음과 같을 때:
            - 페이지 1: 15회
            - 페이지 2: 5회
            - 페이지 3: 10회
            - 페이지 4: 3회
            - 가장 자주 사용된 페이지 1을 교체.
    - **LFU (Least Frequently Used)**: 가장 적게 사용된 페이지를 교체.
        - **예시)** 페이지 1, 2, 3, 4의 참조 횟수가 다음과 같을 때:
            - 페이지 1: 15회
            - 페이지 2: 5회
            - 페이지 3: 10회
            - 페이지 4: 3회
            - 가장 적게 사용된 페이지 4를 교체.
    - **최적 교체 (Optimal Replacement)**: 앞으로 가장 오랫동안 사용되지 않을 페이지 교체.
        - **예시)** 페이지 접근 순서가 [7, 0, 1, 2, 0, 3, 0, 4]일 때:
            - 메모리 상태: [7, 0, 1]
            - 페이지 2 요청 시, 앞으로 가장 오랫동안 사용되지 않을 페이지 1을 교체.
            - 결과 상태: [7, 0, 2]

### TLB (Translation Lookaside Buffer)

가상 주소를 물리 주소로 변환하는 속도를 높이기 위한 캐시. 

- **특징:** 페이지 테이블(Page Table) 접근 횟수 감소
- **동작 원리**
    - CPU가 TLB에서 주소 변환 정보를 검색.
    - TLB 적중 시, 변환된 물리 주소로 직접 접근.
    - TLB 실패 시, 페이지 테이블 참조 후 TLB 갱신
- **TLB 적중률**
    - **정의**: TLB에서 주소 변환 정보를 찾은 비율.
    - **예시)**
        - 총 1000번 메모리 접근 중 950번 TLB 적중 → TLB 적중률 95%.
     
## 입출력 시스템 (I/O Systems)

### 입출력 장치와 동작 원리 (I/O Devices and Operations)

- 입출력 장치의 종류
    - **입력 장치**: 키보드, 마우스, 스캐너, 센서 등 데이터를 입력하는 장치.
    - **출력 장치**: 모니터, 프린터, 스피커 등 데이터를 출력하는 장치.
    - **입출력 혼합 장치**: 하드디스크, 네트워크 카드 등 데이터를 입출력하는 장치.
- **동작 원리**
    - CPU와 메모리 간 데이터를 교환하거나 외부 장치와의 데이터를 처리.
    - 장치 컨트롤러가 하드웨어와 소프트웨어 간 인터페이스 역할을 수행.
    - **예시)**
        - 키보드 입력: 키보드 → 장치 컨트롤러 → CPU로 데이터 전달.
        - 파일 출력: CPU → 메모리 → 하드디스크로 데이터 저장.

### 입출력 제어 방식 (I/O Control Mechanisms)

- **프로그램 제어(Programmed I/O)**
    - CPU가 명령어를 통해 직접 입출력을 제어.
    - **장점**: 간단한 구조.
    - **단점**: CPU가 장치 상태를 지속적으로 확인(바쁜 대기 Busy Waiting).
    - **예시)**
        - CPU가 프린터의 준비 상태를 반복적으로 확인 후 데이터를 전송.
- **인터럽트 방식(Interrupt-driven I/O)**
    - 입출력 장치가 작업 완료 시 CPU에 신호(인터럽트)를 보냄.
    - **장점**: CPU가 다른 작업 수행 가능.
    - **단점**: 빈번한 인터럽트 발생 시 처리 부담 증가.
    - **예시)**
        - 키보드 입력: 키를 누를 때마다 인터럽트를 발생시켜 데이터를 CPU로 전달.
- **DMA(Direct Memory Access)**
    - 데이터 전송 시 CPU 개입 없이 장치가 메모리와 직접 통신.
    - **장점**: CPU 부하 감소, 빠른 데이터 전송.
    - **단점**: DMA 컨트롤러 추가 비용 발생.
    - **예시)**
        - 대용량 파일 전송: 하드디스크 → DMA → 메모리로 직접 전송.

### 인터럽트 (Interrupts)

입출력 장치 또는 외부 이벤트가 발생했을 때 CPU에 작업 중단 요청을 보내는 메커니즘

- **종류**
    - **하드웨어 인터럽트**: 키보드 입력, 마우스 클릭 등 하드웨어 신호에 의해 발생
    - **소프트웨어 인터럽트**: 프로그램에서 명령어로 요청(예: 시스템 호출)
- **동작 과정**
    - 입출력 장치가 인터럽트를 발생시킴
    - CPU는 현재 작업을 중단하고 인터럽트 처리 루틴(Interrupt Service Routine, ISR)을 실행
    - 작업 완료 후 중단된 작업을 재개
- **우선순위 처리**
    - 여러 인터럽트가 동시에 발생하면 우선순위(Priority)를 기준으로 처리.
    - **예시)**
        - 키보드 인터럽트보다 네트워크 인터럽트를 우선 처리.

### I/O 버스와 데이터 전송 (I/O Bus and Data Transfer)

- **I/O 버스**
    - CPU, 메모리, 입출력 장치를 연결하는 데이터 통로
    - **종류**:
        - **데이터 버스(Data Bus)**: 데이터를 전송
        - **주소 버스(Address Bus)**: 데이터 위치를 지정
        - **제어 버스(Control Bus)**: 데이터 흐름을 제어
- **데이터 전송 방식**
    - **동기 전송(Synchronous Transfer)**: 클럭 신호에 맞춰 데이터를 전송.
        - **장점**: 안정적인 데이터 전송.
        - **단점**: 전송 속도가 클럭 신호에 의존.
        - **예시)** CPU와 메모리 간 동기 데이터 전송.
    - **비동기 전송(Asynchronous Transfer)**: 송수신 측 신호로 전송 타이밍 결정.
        - **장점**: 유연한 데이터 전송.
        - **단점**: 동기화 과정이 필요.
        - **예시)** CPU와 주변 장치 간 데이터 전송.

## 프로세서 설계 (Processor Design)

### 데이터 경로 설계 (Datapath Design)

- **단일 사이클(Single-Cycle Design)**
    - **특징**:
        - 하나의 명령어가 단일 클럭 주기 내에 완료된다.
        - 데이터 경로는 Fetch, Decode, Execute, Memory Access, Write Back 단계를 포함한다.
    - **장점:** 설계가 단순하고 이해하기 쉽다.
    - **단점**: 모든 명령어가 동일한 클럭 주기를 사용하므로 비효율적이다. (특히 복잡한 명령어에서 클럭 주기가 길어진다.)
    - **예시)** R-type 명령어: `add $t1, $t2, $t3` (레지스터 $t2와 $t3의 값을 더해 $t1에 저장한다.)
- **멀티 사이클(Multi-Cycle Design)**
    - **특징**:
        - 명령어를 여러 클럭 주기에 걸쳐 실행하여 각 단계별로 최적화
        - 동일한 하드웨어를 여러 번 재사용 가능
    - **장점**: 복잡한 명령어에서 효율적이며, 전체 클럭 주기 감소 가능
    - **단점**: 설계가 복잡해진다.
    - **예시)** Load 명령어:
        - 명령어 인출(Fetch)
        - 주소 계산(Decode + Address Calculation)
        - 메모리 접근(Memory Access)
        - 결과 레지스터에 저장(Write Back)

### 제어 유닛 설계 (Control Unit Design)

- 하드와이어드 제어 (Hardwired Control)
    - **특징**:
        - 제어 신호를 고정된 논리 회로로 생성
        - 빠르고 효율적이며 고속 프로세서에 적합
    - **장점**: 실행 속도가 빠름
    - **단점:** 유연성이 부족하며 수정이 어려움
    - **예시)** 단순한 고정 논리 회로로 명령어에 따라 제어 신호를 생성
- 마이크로프로그램 제어 (Microprogrammed Control)
    - **특징**:
        - 제어 신호를 마이크로코드로 생성하여 유연성 제공
        - 마이크로코드는 제어 메모리에 저장되어 필요 시 수정 가능
    - **장점**: 복잡한 명령어 집합에 적합하며 유연성이 높음
    - **단점**: 실행 속도가 느림
    - **예시)**마이크로 명령어:
        
        ```css
        IF1: PC -> MAR; READ;
        IF2: MDR -> IR; INC(PC);
        ```
        

### 파이프라인 처리 (Pipelining)

- **파이프라인의 개념과 이점**
    - **개념**:
        - 명령어의 각 단계를 겹쳐 실행하여 처리 속도를 높임.
        - 마치 생산 라인처럼 동작하여 CPU의 효율성 증가.
    - **이점**:
        - 클럭 주기당 처리량(Throughput) 증가.
        - CPU 자원의 활용 극대화.
    - **예시)**
        - 5단계 파이프라인: Fetch → Decode → Execute → Memory Access → Write Back.
        - 한 명령어가 실행되는 동안 다른 명령어는 인출 또는 해독 중.
- **위험 요소(Hazards)**
    - **데이터 위험(Data Hazards)**
        - **원인:** 명령어 간 데이터 종속성.
        - **종류:**
            - RAW(Read After Write): 이전 명령어가 데이터를 기록하기 전에 다음 명령어가 읽으려 함.
            - WAR(Write After Read): 이전 명령어가 데이터를 읽기 전에 다음 명령어가 기록하려 함.
            - WAW(Write After Write): 두 명령어가 같은 레지스터에 기록하려 함.
        - **해결:** 데이터 포워딩, 스톨(Stall) 삽입.
        - **예시)**
            - 명령어 1: `add $t1, $t2, $t3`
            - 명령어 2: `sub $t4, $t1, $t5` (RAW 발생 가능).
    - **제어 위험(Control Hazards)**
        - **원인:** 분기(branch) 명령어로 인해 파이프라인의 흐름이 변경될 때 발생.
        - **해결:**
            - 분기 예측(Branch Prediction).
            - 분기 지연 슬롯(Branch Delay Slot).
        - **예시)**
            - 명령어 1: `beq $t1, $t2, label`
            - 이후 명령어가 잘못 예측될 경우 파이프라인이 잘못된 명령어를 처리.
    - **구조적 위험(Structural Hazards)**
        - **원인:** 하드웨어 자원을 여러 명령어가 동시에 요구.
        - **해결:**
            - 자원 추가.
            - 자원 공유를 위한 스케줄링.
        - **예시)** 명령어 1과 명령어 2가 동시에 메모리 접근 시 메모리 자원 부족.
